<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法学习之路-回溯篇</title>
      <link href="/2023/01/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%9B%9E%E6%BA%AF%E7%AF%87/"/>
      <url>/2023/01/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%9B%9E%E6%BA%AF%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.png" alt="回溯算法"></p><span id="more"></span><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF--%E5%9B%9E%E6%BA%AF%E7%AF%87">算法学习之路–回溯篇</a><ul><li><a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">回溯算法理论基础</a><ul><li><a href="#1%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">1、回溯算法是什么</a></li><li><a href="#2%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87">2、回溯法的效率</a></li><li><a href="#3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">3、回溯算法解决的问题</a></li><li><a href="#4%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">4、理解回溯算法</a></li><li><a href="#5%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF">5、回溯法模板</a></li></ul></li><li><a href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98">组合问题</a><ul><li><a href="#77%E7%BB%84%E5%90%88">77、组合</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li><li><a href="#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96">剪枝优化</a></li></ul></li><li><a href="#216%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Ciii">216、组合总和III</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-1">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-1">实现</a></li><li><a href="#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96-1">剪枝优化</a></li></ul></li><li><a href="#17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88">17、电话号码的字母组合</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-2">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-2">实现</a></li></ul></li><li><a href="#39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C">39、组合总和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-3">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-3">实现</a></li><li><a href="#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96-2">剪枝优化</a></li></ul></li><li><a href="#40%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii">40、组合总和II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-4">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-4">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-4">实现</a></li></ul></li></ul></li><li><a href="#%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98">分割问题</a><ul><li><a href="#131%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2">131、分割回文串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-5">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-5">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-5">实现</a></li></ul></li><li><a href="#93%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80">93、复原IP地址</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-6">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-6">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-6">实现</a></li></ul></li></ul></li><li><a href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98">子集问题</a><ul><li><a href="#78%E5%AD%90%E9%9B%86">78、子集</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-7">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-7">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-7">实现</a></li></ul></li><li><a href="#90%E5%AD%90%E9%9B%86ii">90、子集II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-8">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-8">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-8">实现</a></li></ul></li></ul></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a><ul><li><a href="#491%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">491、递增子序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-9">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-9">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-9">实现</a></li></ul></li><li><a href="#332%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B">332、重新安排行程</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-10">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-10">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-10">实现</a></li></ul></li></ul></li><li><a href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98">排列问题</a><ul><li><a href="#46%E5%85%A8%E6%8E%92%E5%88%97">46、全排列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-11">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-11">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-11">实现</a></li></ul></li><li><a href="#47%E5%85%A8%E6%8E%92%E5%88%97ii">47、全排列II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-12">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-12">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-12">实现</a></li><li><a href="#%E6%89%A9%E5%B1%95">扩展</a></li></ul></li></ul></li><li><a href="#%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98">棋盘问题</a><ul><li><a href="#51n%E7%9A%87%E5%90%8E">51、N皇后</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-13">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-13">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-13">实现</a></li></ul></li><li><a href="#37%E8%A7%A3%E6%95%B0%E7%8B%AC">37、解数独</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-14">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-14">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-14">实现</a></li></ul></li></ul></li><li><a href="#%E8%A1%A5%E5%85%85%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">补充：性能分析</a><ul><li><a href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98-1">子集问题</a></li><li><a href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98-1">排列问题</a></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><blockquote><p>教程地址：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p></blockquote><h1 id="算法学习之路–回溯篇"><a href="#算法学习之路–回溯篇" class="headerlink" title="算法学习之路–回溯篇"></a>算法学习之路–回溯篇</h1><h2 id="回溯算法理论基础"><a href="#回溯算法理论基础" class="headerlink" title="回溯算法理论基础"></a>回溯算法理论基础</h2><h3 id="1、回溯算法是什么"><a href="#1、回溯算法是什么" class="headerlink" title="1、回溯算法是什么"></a>1、回溯算法是什么</h3><p>1）回溯法也可叫做回溯搜索法，它是一种搜索的方式。</p><p>2）回溯是递归的副产品，只要有递归就会有回溯。</p><p>3）回溯函数也就是递归函数，指向的都是一个函数</p><h3 id="2、回溯法的效率"><a href="#2、回溯法的效率" class="headerlink" title="2、回溯法的效率"></a>2、回溯法的效率</h3><p><strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么很高效的方法，</strong>它的本质是<strong>穷举</strong>，穷举所有可能，然后选出我们想要的答案。如果想让回溯法高效一些，可以加一些剪枝操作，但是也改变不了回溯法就是穷举的本质。</p><blockquote><p>为什么回溯法并不高效还要使用它呢？</p><p>因为没得选，一些问题能暴力搜出来就不错了，顶多在剪枝一下，还没有更高效的方法</p></blockquote><h3 id="3、回溯算法解决的问题"><a href="#3、回溯算法解决的问题" class="headerlink" title="3、回溯算法解决的问题"></a>3、回溯算法解决的问题</h3><p>回溯法，一般可以解决如下的几种问题：</p><ol><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后、解数独等问题</li></ol><blockquote><p><strong>组合不强调元素顺序，排列强调元素顺序</strong></p></blockquote><h3 id="4、理解回溯算法"><a href="#4、理解回溯算法" class="headerlink" title="4、理解回溯算法"></a>4、理解回溯算法</h3><p>1）<strong>回溯法解决的问题都可以抽象为树形结构</strong></p><p>2）因为回溯法解决的都是在集合中递归查找自己，集合的大小就构成了树的宽度，递归的深度就构成了树的深度</p><p>3）只要是递归，就要有终止条件，所以必然是一颗高度有限的数（N叉树）</p><h3 id="5、回溯法模板"><a href="#5、回溯法模板" class="headerlink" title="5、回溯法模板"></a>5、回溯法模板</h3><ol><li><p>回溯函数模板返回值以及参数</p><p>在回溯算法中，个人习惯给函数起名<code>backtracking</code>，回溯算法中函数的返回值一般为<code>void</code></p><p>回溯算法需要的参数不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><pre><code class="java">void backtracking(params)</code></pre></li><li><p>回溯函数终止条件</p><p>回溯既然是树形结构，就一定要有终止条件</p><p>什么时候达到了终止条件，树中就可以看出来，一般来说搜索到叶子结点，也就找到了满足条件的一条答案，把这个答案保存起来，并结束本层递归</p><pre><code class="java">if(终止条件) &#123;    存放结果;    return;&#125;</code></pre></li><li><p>回溯搜索的遍历过程</p><p>回溯算法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成了树的深度</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231101331107.png" alt="image-20221231101331107"></p><p>注意图中举例的时候集合大小和节点的大小是相等的。</p><pre><code class="java">for(选择：本层集合中的元素（树中节点孩子的数量就是集合的大小）) &#123;    处理节点;    backtracking(路径, 选择列表); // 递归    回溯，撤销处理结果&#125;</code></pre><p>for循环就是在遍历集合区间，可以理解为一个节点有多少个孩子结点，这个for循环就遍历多少次</p><p><code>backtracking</code>这里实现递归</p><p>从图中可以看出，<strong>for循环可以理解成横向遍历，backtracking（递归）就是纵向遍历</strong>，这样把整棵树都遍历一遍，一般来说，搜索叶子结点就是找到其中一个结果了。</p></li></ol><p>&#x3D;&gt; 回溯算法模板框架：</p><pre><code class="java">void backtracking(params) &#123;    if(终止条件) &#123;        存放结果;        return;    &#125;    for(选择：本层集合中的元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径, 选择列表); // 递归        回溯，撤销处理结果    &#125;&#125;</code></pre><hr><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="77、组合"><a href="#77、组合" class="headerlink" title="77、组合"></a>77、组合</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a>**</p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 4, k = 2输出：[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1, k = 1输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><em>本题是回溯法的经典题目</em></p><p>直接的解法当然是使用for循环，总共k层循环，每层n次。</p><blockquote><p>当n和k很大时，for循环根本无从下手。</p><p>回溯搜索法虽然也是暴力，但是至少能写出来。</p></blockquote><p><strong>回溯法使用递归解决暴力写法的嵌套层数的问题</strong>，递归做层叠嵌套（可以理解为是开k层for循环），<strong>每一次递归中嵌套了一个for循环</strong>，那么递归就可以用于解决多层嵌套循环的问题了<strong>。</strong></p><p><strong>为了便于理解，一定一定要画树形结构！！！</strong></p><p>组合问题可以抽象成如下树形结构</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231104843102.png" alt="image-20221231104843102"></p><p>从图中可以看出，<strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩。调整可选择的范围</strong></p><p><strong>图中可以发现，n相当于树的宽度，k相当于树的深度</strong></p><p>收集结果集：<strong>图中每次搜索到叶子结点，就找熬了一个结果</strong>，相当于只要把达到叶子节点的结果收集起来，就可以得到n个数中k个数的组合集合</p><p>回溯三部曲：</p><ol><li><p>回溯函数的返回值和参数</p><p>在这里要定义两个全局变量，一个用来存放符合条件的单一结果，一个用来存放符合条件结果的集合</p><pre><code class="java">// 存放符合条件结果的集合List&lt;List&lt;Integer&gt;&gt; result;// 存放符合条件的结果LinkedList&lt;Integer&gt; path;</code></pre><blockquote><p>其实此处不定义这两个全局变量也是可以的，可以把这两个变量放入回溯函数的参数中，但是函数中参数太多影响可读性。</p></blockquote><p>函数里一定要有的两个参数：n 和 k。然后还需要一个参数，为<code>int</code>类型的<code>startIndex</code>，这个参数用于记录本层递归中集合([1,2,…,n])从哪里开始遍历。</p><p><code>startIndex</code>的必要性：每次从集合中选取元素，<strong>可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</strong></p><p>从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归就要在[2,3,4]中取数，那么一下层递归就是靠<code>startIndex</code>知道从[2,3,4]中取数</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231110007838.png" alt="image-20221231110007838"></p><pre><code class="java">// 存放符合条件结果的集合List&lt;List&lt;Integer&gt;&gt; result;// 存放符合条件的结果LinkedList&lt;Integer&gt; path;void backtracking(int n, int k, int startIndex)</code></pre></li><li><p>回溯函数终止条件</p><p>到达叶子结点的标志：path这个集合的大小如果到达了k，就说明找到了一个子集大小为k的组合了，在图中path保存的就是根结点到叶子结点的路径，如下图红色部分：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231110655885.png" alt="image-20221231110655885"></p><p>此时使用result集合把path保存起来，并终止本次递归</p><pre><code class="java">// 终止条件代码if(path.size() == k) &#123;    result.add(new ArrayList&lt;&gt;(path));    return;&#125;</code></pre></li><li><p>单层搜索的过程</p><p>回溯法的搜索过程就是一个树形结构的遍历过程，for循环用来横向遍历，递归的过程是纵向遍历</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221231110957339.png" alt="image-20221231110957339"></p><p>for循环每次从<code>startIndex</code>开始遍历，然后使用<code>path</code>保存节点i</p><pre><code class="java">for(int i = startIndex; i &lt;= n; i++) &#123;    // 处理节点    path.add(i);    // 递归：控制树的纵向遍历，注意下一层搜索要从 i+1 开始    backtracking(n, k, i + 1);    // 回溯，撤销处理的节点    path.removeLast();&#125;</code></pre><p><code>backtracking</code>（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子结点，遇到叶子结点就返回。</p><p><code>backtracking</code>的下面部分就是回溯的操作了，撤销本次的处理结果</p></li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">class Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; result;    private LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        backtracking(n, k, 1);        return result;    &#125;    private void backtracking(int n, int k, int stratIndex) &#123;        if(path.size() == k) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        for(int i = stratIndex; i &lt;= n; i++) &#123;            path.add(i);            backtracking(n, k, i + 1);            path.removeLast();        &#125;    &#125;&#125;</code></pre><h4 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h4><p><em>回溯算法虽然是暴力搜索，但有时候也可以进行剪枝优化的</em></p><p>在遍历的过程中，有如下代码：</p><pre><code class="java">for(int i = stratIndex; i &lt;= n; i++) &#123;    path.add(i);    backtracking(n, k, i + 1);    path.removeLast();&#125;</code></pre><p>这个遍历的范围是可以剪枝优化的</p><p>【举例】<code>n = 4, k = 4</code>，那么第一层for循环，从元素2开始都没有意义了，第二层for循环从元素3开始都没有意义了</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230101091238992.png" alt="image-20230101091238992"></p><p>图中的每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历</p><p>&#x3D;&gt; 所以，<strong>可以剪枝的地方就在递归中每一层的for循环所选择的起始位置</strong>，如果for循环选择的起始位置之后的元素已经不足我们需要的元素了，那么就没有必要再搜索了。</p><p>注意代码中的<code>i</code>，就是for循环里选择的起始位置</p><pre><code class="java">for(int i = stratIndex; i &lt;= n; i++) &#123;</code></pre><p>优化的过程：</p><ol><li><p>已经选择的元素个数：<code>path.size()</code></p></li><li><p>还需要选择的元素个数：<code>k - path.size()</code></p></li><li><p>在集合n中至多要从该起始位置：<code>n - (k - path.size()) + 1</code>开始遍历</p><blockquote><p><code>+ 1</code>的原因：</p><p>因为包括起始位置，我们需要的是一个左闭右闭的集合</p><p>举个栗子：<code>n = 4, k = 3</code>，目前已经选择元素个数为0(<code>path.size() = 0</code>)，<code>n - (k - 1) + 1 = 4 - (3 - 0) + 1 = 2</code>，从2开始搜索都是合理的，可以是组合<code>[2,3,4]</code></p></blockquote></li></ol><p>&#x3D;&gt; 优化之后的for循环：</p><pre><code class="java">for(int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) &#123;    // i 为本次搜索的起始位置&#125;</code></pre><p>优化后的代码实现：</p><pre><code class="java">class Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; result;    private LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        backtracking(n, k, 1);        return result;    &#125;    private void backtracking(int n, int k, int stratIndex) &#123;        if(path.size() == k) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        for(int i = stratIndex; i &lt;= n - (k - path.size()) + 1; i++) &#123;            path.add(i);            backtracking(n, k, i + 1);            path.removeLast();        &#125;    &#125;&#125;</code></pre><h3 id="216、组合总和III"><a href="#216、组合总和III" class="headerlink" title="216、组合总和III"></a>216、组合总和III</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III - 力扣（LeetCode）</a>**</p><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><pre><code>输入: k = 3, n = 7输出: [[1,2,4]]解释:1 + 2 + 4 = 7没有其他符合的组合了。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]]解释:1 + 2 + 6 = 91 + 3 + 5 = 92 + 3 + 4 = 9没有其他符合的组合了。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: k = 4, n = 1输出: []解释: 不存在有效的组合。在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</code></pre><p><strong>提示:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>本题就是在<code>[1,2,3,4,5,6,7,8,9]</code>这个集合中找到和为n的k个数的组合</p><p>相比于**<a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a>**，只是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的<code>[1,2,3,4,5,6,7,8,9]</code></p><p>本题 k 相当于树的深度， 9 （也就是集合的长度）就是树的宽度</p><p>【例子】<code>k = 2, n = 4</code>，就是在集合<code>[1,2,3,4,5,6,7,8,9]</code>中求 k （个数）&#x3D; 2，n（和） &#x3D; 4的组合</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230101094423175.png" alt="image-20230101094423175"></p><p>图中可以看出，只有组合[1,3]符合条件</p><p>回溯三部曲：</p><ol><li><p>确定回溯函数的参数</p><p>和**<a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a>**一样，依然需要集合<code>path</code>来存放符合条件的结果，集合<code>result</code>来存放结果集</p><pre><code class="java">// 存放符合条件结果的集合List&lt;List&lt;Integer&gt;&gt; result;// 存放符合条件的结果LinkedList&lt;Integer&gt; path;</code></pre><p>参数：</p><ul><li><code>targetSum(int)</code>目标和，也就是题目中的n</li><li><code>k(int)</code>，就是题目中的k</li><li><code>sum(int)</code>为已经收集的元素的总和，也就是<code>path</code>里的元素的总和</li><li><code>startIndex(int)</code>为下一层for循环搜索的起始位置</li></ul><pre><code class="java">// 存放符合条件结果的集合List&lt;List&lt;Integer&gt;&gt; result;// 存放符合条件的结果LinkedList&lt;Integer&gt; path;void backtracking(int targetSum, int k, int sum, int startIndex)</code></pre><p>其实这个<code>sum(int)</code>参数可以省略，每次<code>targetSum</code>减去选取元素的数值，然后判断<code>targetSum ?= 0</code>，如果是，说明收集到符合条件的结果了</p><blockquote><p>强调一点：回溯法中递归函数的参数很难一次性确定下来，一般先写逻辑，需要啥参数再填写啥参数</p></blockquote></li><li><p>确定终止条件</p><p>上述 k 其实就已经限制了树的深度，因为就取k个元素，树再往下深没有意义，所以如果<code>path.size() == k</code>，就终止，如果此时<code>path</code>里收集到的元素和(<code>sum</code>)和<code>targetSum</code>（就是题目中描述的n)相等，就用<code>result</code>收集当前的结果</p><pre><code class="java">if(path.size() == k) &#123;    if(sum == targetSum) result.add(new ArrayList&lt;&gt;(path));    return; // 如果`path.size() == k 而 sum != targetSum 直接返回&#125;</code></pre></li><li><p>单层搜索逻辑</p><p>本题和**<a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a>**区别之一就是集合固定就是9个数[1,2,3,4,5,6,7,8,9]，所以for循环固定为<code>i &lt;= 9</code></p><p>处理过程就是<code>path</code>收集每次选取的元素，相当于树型结构里的边，<code>sum</code>来统计<code>path</code>里元素的总和</p><pre><code class="java">for(int i = startIndex; i &lt;= 9; i++) &#123;    sum += i;    path.add(i);    backtracking(targetSum, k, sum, i + 1); // 注意startIndex 调整为 i + 1    sum -= i; // 回溯    path.removeLast(); // 回溯&#125;</code></pre><p><strong>处理过程和回溯过程是一一对应的，处理有加，回溯就要有减</strong></p></li></ol><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>java代码：</p><pre><code class="java">class Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; result;    private LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        traversal(n, k, 0, 1);        return result;    &#125;    private void traversal(int targetSum, int k, int sum, int startIndex) &#123;        if(path.size() == k) &#123;            if(targetSum == sum) &#123;                result.add(new ArrayList&lt;&gt;(path));            &#125;            return;        &#125;        for(int i = startIndex; i &lt;= 9; i++) &#123;            path.add(i);            sum += i;            traversal(targetSum, k, sum, i + 1);            sum -= i;            path.removeLast();        &#125;    &#125;&#125;</code></pre><h4 id="剪枝优化-1"><a href="#剪枝优化-1" class="headerlink" title="剪枝优化"></a>剪枝优化</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230101100545915.png" alt="image-20230101100545915"></p><p>已选元素总和如果大于n了，那么再往后遍历就没有意义了，直接剪枝</p><p>那么剪枝的地方一定是在递归终止的地方</p><pre><code class="java">if(sum &gt; targetSum) &#123;    // 剪枝操作    return;&#125;</code></pre><p>for循环范围也可以剪枝，<code>i &lt;= 9 - (k - path.size()) + 1</code>就可以了</p><p>剪枝优化后代码：</p><pre><code class="java">class Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; result;    private LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        traversal(n, k, 0, 1);        return result;    &#125;    private void traversal(int targetSum, int k, int sum, int startIndex) &#123;        if(sum &gt; targetSum) &#123;            return;        &#125;        if(path.size() == k) &#123;            if(targetSum == sum) &#123;                result.add(new ArrayList&lt;&gt;(path));            &#125;            return;        &#125;        for(int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) &#123;            path.add(i);            sum += i;            traversal(targetSum, k, sum, i + 1);            sum -= i;            path.removeLast();        &#125;    &#125;&#125;</code></pre><h3 id="17、电话号码的字母组合"><a href="#17、电话号码的字母组合" class="headerlink" title="17、电话号码的字母组合"></a>17、电话号码的字母组合</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合 - 力扣（LeetCode）</a>**</p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><pre><code>输入：digits = &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：digits = &quot;&quot;输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：digits = &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>理解题意之后，要解决三个问题：</p><ol><li>数字和字母如何映射</li><li>解决for多重循环</li><li>输入<code>1*#</code>按键等等异常情况</li></ol><p><strong>数字和字母如何映射</strong></p><p>使用Map或者定义一个二维数组，此处使用Map集合</p><pre><code class="java">Map&lt;Character,String&gt; phoneMap = new HashMap&lt;&gt;()&#123;&#123;    put('2',"abc");    put('3', "def");    put('4', "ghi");    put('5', "jkl");    put('6', "mno");    put('7', "pqrs");    put('8', "tuv");    put('9', "wxyz");&#125;&#125;;</code></pre><p><strong>回溯法解决n个for循环的问题</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230102102458661.png" alt="image-20230102102458661"></p><p>图中可以看出遍历的深度就是输入”23”的长度，而叶子结点就是要收集的结果，输出[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>回溯三部曲：</p><ol><li><p>确定回溯函数的参数</p><p>首先需要一个字符串集合result保存结果，需要一个<code>StringBuffer</code>来收集结果（此处放到参数列表），这两个可以定义为全局变量</p><p>参数指定是有题目给定的<code>dights</code>，还需要一个参数就是<code>int</code>型的<code>index</code>，记录遍历到第几个数字了，就是用来遍历<code>dights</code>的，同时<code>index</code>也表示是树的深度</p><pre><code class="java">List&lt;String&gt; result;void backtracking(String dights, int index, StringBuffer s;)</code></pre></li><li><p>确定终止条件</p><p>输入几个数字就递归几层，所以终止条件就是如果<code>index == dights.size()</code>，然后就收集结果，结束本层递归</p><pre><code class="java">if(index == dights.size()) &#123;    result.add(s.toString());    return;&#125;</code></pre></li><li><p>确定单层遍历的逻辑</p><p>首先要取<code>index</code>指向的数字，并找到对应的字符集（手机键盘的字符集）</p><p>然后使用for循环来处理这个for循环</p><pre><code class="java">char ch = dights.charAt(index);// 取数字对应的字符集String letters = phoneMap.get(ch);for(int i = 0; i &lt; letters.length(); i++) &#123;    // 处理    s.append(letters.charAt(i));    // 递归，注意index+1，下一层要处理下一个数字了    backtracking(dights, index + 1, s);    // 回溯    s.deleteCharAt(index);&#125;</code></pre><p>此处的for循环是从0开始的，因为本题每个数字代表的是不同集合，也就是求不同集合之间的组合，而<code>LeetCode 76</code>和<code>LeetCode 216</code>都是求同一个集合中的组合！</p></li></ol><p><strong>注意：输入<code>1*#</code>按键等等异常情况</strong></p><p>代码中最好考虑此类异常情况（加个if判断即可，如果是则跳过或者报异常），考虑到测试数据中没有异常情况和的数据，此处不加。<strong>面试的时候问到一定要考虑到</strong></p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    private List&lt;String&gt; result;    private Map&lt;Character, String&gt; phoneMap = new HashMap&lt;&gt;()&#123;&#123;                put('2',"abc");                put('3', "def");                put('4', "ghi");                put('5', "jkl");                put('6', "mno");                put('7', "pqrs");                put('8', "tuv");                put('9', "wxyz");            &#125;&#125;;    public List&lt;String&gt; letterCombinations(String digits) &#123;        result = new ArrayList&lt;&gt;();        if(digits.length() == 0) return result;        backtracking(digits, 0, new StringBuffer());        return result;    &#125;    private void backtracking(String digits, int index, StringBuffer s) &#123;        if(index == digits.length()) &#123;            result.add(s.toString());            return;        &#125;        char ch = digits.charAt(index);        String letters = phoneMap.get(ch);        for(int i = 0; i &lt; letters.length(); i++) &#123;            s.append(letters.charAt(i));            backtracking(digits, index + 1, s);            s.deleteCharAt(index);        &#125;    &#125;&#125;</code></pre><h3 id="39、组合总和"><a href="#39、组合总和" class="headerlink" title="39、组合总和"></a>39、组合总和</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a>**</p><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><pre><code>输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入: candidates = [2], target = 1输出: []</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><blockquote><p>题目中提示<code>2 &lt;= candidates[i] &lt;= 40</code>，所以不需要考虑0</p></blockquote><p>本题和<code>LeetCode 77</code>、<code>LeetCode 216</code>的区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制</p><p>以<code>candidates = [2,5,8], target = 4</code>为例</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230102112125217.png" alt="image-20230102112125217"></p><p>注意图中叶子结点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过<code>target</code>就返回</p><p>回溯三部曲：</p><ol><li><p>确定递归函数的参数</p><p>两个集合：<code>result</code>存放结果集、<code>path</code>存放符合条件的结果</p><p>参数：集合<code>candidates</code>、目标值<code>target</code>、<code>sum(int)</code>来统一单一结果<code>path</code>里的总和，其实也可以不要，每次使用<code>target</code>做减法就可以了，最后如果<code>target == 0</code>就说明找到符合的结果了</p><p>本题还需要<code>startIndex</code>来控制for循环的起始位置</p><blockquote><p>对于<strong>组合问题</strong>，什么时候需要<code>startIndex</code>呢？</p><ul><li>如果是⼀个集合来求组合的话，就需要<code>startIndex</code></li><li>如果是多个集合取组合，各个集合之间相互不影响，那么就不用<code>startIndex</code></li></ul></blockquote><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; result;LinkedList&lt;Integer&gt; path;void backtracking(int[] candidates, int target, int sum, int startIndex)</code></pre></li><li><p>递归终止条件</p><p>从上图叶子结点可以清晰看出，终止只有两种情况，<code>sum &gt; target</code>、<code>sum == target</code></p><pre><code class="java">if(sum &gt; target) return;if(sum == target) &#123;    result.add(new ArrayList&lt;&gt;(path));    return;&#125;</code></pre></li><li><p>单层搜索的逻辑</p><p>单层for循环依然是从<code>startIndex</code>开始，搜索<code>candidates</code>集合</p><p>注意：<strong>本题的元素为可重复选取</strong></p><pre><code class="java">for(int i = startIndex; i &lt;= candidates.length; i++) &#123;    sum += candidates[i];    path.add(candidates[i]);    backtracking(candidates, target, sum, i); // 关键点：不使用 i+1，表示可以重复读取当前数    // 回溯    sum -= candidates[i];    path.removeLast();&#125;</code></pre></li></ol><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; result;    private LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        backtracking(candidates, target, 0, 0);        return result;    &#125;    private void backtracking(int[] candidates, int target, int sum, int startIndex) &#123;        if(sum &gt; target) return;        if(sum == target) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        for(int i = startIndex; i &lt; candidates.length; i++) &#123;            sum += candidates[i];            path.add(candidates[i]);            backtracking(candidates, target, sum, i);            sum -= candidates[i];            path.removeLast();        &#125;    &#125;&#125;</code></pre><h4 id="剪枝优化-2"><a href="#剪枝优化-2" class="headerlink" title="剪枝优化"></a>剪枝优化</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230102123647370.png" alt="image-20230102123647370"></p><p>在未优化之前，对于<code>sum &gt; target</code>的情况，依然是进入下一层递归，只是下一层递归结束判断的时候，会判断出<code>sum &gt; target</code>就返回</p><p>其实如果已经知道下一层的<code>sum &gt; target</code>，就没有必要进入下一层循环了</p><p>可以再for循环的搜索范围上做文章，<strong>对总集合排序之后，如果下一层的sum（就是本层的sum + candidates[i]）已经大于target，就可以结束本轮的for循环遍历</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230102124726423.png" alt="image-20230102124726423"></p><p>for循环剪枝代码：</p><pre><code class="java">for(int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++)</code></pre><p>剪枝优化后代码实现：</p><pre><code class="java">class Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; result;    private LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        // 排序        Arrays.sort(candidates);        backtracking(candidates, target, 0, 0);        return result;    &#125;    private void backtracking(int[] candidates, int target, int sum, int startIndex) &#123;        if(sum == target) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        // 如果 sum + candidates[i] &gt; target直接结束本层的for循环        for(int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;            sum += candidates[i];            path.add(candidates[i]);            backtracking(candidates, target, sum, i);            sum -= candidates[i];            path.removeLast();        &#125;    &#125;&#125;</code></pre><h3 id="40、组合总和II"><a href="#40、组合总和II" class="headerlink" title="40、组合总和II"></a>40、组合总和II</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（LeetCode）</a>**</p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><pre><code>输入: candidates = [10,1,2,7,6,1,5], target = 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: candidates = [2,5,2,1,2], target = 5,输出:[[1,2,2],[5]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>本题和<code>LeetCode39 组合总和</code>有如下区别：</p><ul><li>本题<code>candidates</code>中的每个数字在每个组合中只能使用一次</li><li>本题数组<code>candidates</code>的元素是有重复的，而<code>LeetCode39</code>是无重复元素的数组<code>candidates</code></li></ul><p>最后要求都是一样的：解集不能包含重复的组合</p><p>本题的难点：<strong>集合（数组candidates）包含重复元素，但是不能有重复的组合</strong></p><blockquote><p>方案一：先求出所有组合，再使用<code>Set</code>或者<code>Map</code>去重 &#x3D;&gt; 容易超时</p><p>方案二：在搜索的过程中就去掉重复组合 ✔</p></blockquote><p><strong>组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是在同一树层上使用过。</strong></p><p>题目中描述的是：元素在同一个组合内是可以重复的，但两个组合不能重复 &#x3D;&gt; <strong>要去重的是同一树层上“使用过”，同一树枝上都是一个组合里的元素，不需要去重</strong></p><p><strong>树层去重，需要对数组排序</strong></p><p>【例子】<code>candidates=[1,1,2]，target=3</code></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230103085550824.png" alt="image-20230103085550824"></p><p>图中可以看出，每个节点都加了<code>used</code>数组，用来记录同一树枝上的元素是否使用过</p><p>回溯三部曲：</p><ol><li><p>确认递归函数参数以及返回值</p><p>和<code>LeetCode 39</code>套路相同，此题还需要加一个<code>boolean</code>类型的集合<code>used</code>，用来记录同一树枝上的元素是否使用过（集合去重）</p><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; result;LinkedList&lt;Integer&gt; path;void backtracking(int[] candidates, int target, int sum, int startIndex, boolean[] used)</code></pre></li><li><p>确定终止条件</p><p>终止条件为：<code>sum &gt; target</code>和<code>sum == target</code></p><pre><code class="java">if(sum &gt; target) return; // 这个条件可以省略，剪枝优化的时候if(sum == target) &#123;    result.add(new ArrayList&lt;&gt;(path));    return;&#125;</code></pre></li><li><p>单层搜索的逻辑</p><p>判断同一树层上的元素（相同的元素）是否使用过：<strong>如果<code>candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false</code>，就说明前一个树枝使用了<code>candidiates[i]</code>，也就是说同一树层使用过<code>candidates[i - 1]</code>，</strong>此时for循环里应该做<code>continue</code>操作</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230103090946393.png" alt="image-20230103090946393"></p><p>从图中可以看出，当<code>candidates[i] == candidates[i - 1]</code>时</p><ul><li><code>used[i - 1] = true</code>，说明在同一树枝<code>candidates[i - 1]</code>使用过</li><li><code>used[i - 1] = false</code>，说明在同一树层<code>candidates[i - 1]</code>使用过</li></ul><pre><code class="java">for(int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;    // 对在同一树层上使用过的元素跳过    if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) &#123;        continue;    &#125;    sum += candidates[i];    path.add(candidates[i]);    used[i] = true;    backtracking(candidates, target, sum, i + 1, used);    // 回溯    sum -= candidates[i];    path.removeLast();    used[i] = false;&#125;</code></pre></li></ol><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>Java 代码</p><pre><code class="java">class Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; result;    private LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        // 排序，让相同的元素都挨在⼀起        Arrays.sort(candidates);        backtracking(candidates, target, 0, 0, new boolean[candidates.length]);        return result;    &#125;    private void backtracking(int[] candidates, int target, int sum, int startIndex, boolean[] used) &#123;        if(sum == target) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;         &#125;        for(int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;            // 对在同一树层上使用过的元素跳过            if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) &#123;                continue;            &#125;            sum += candidates[i];            path.add(candidates[i]);            used[i] = true;            backtracking(candidates, target, sum, i + 1, used);            // 回溯            sum -= candidates[i];            path.removeLast();            used[i] = false;        &#125;    &#125;&#125;</code></pre><h2 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h2><h3 id="131、分割回文串"><a href="#131、分割回文串" class="headerlink" title="131、分割回文串"></a>131、分割回文串</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a>**</p><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;a&quot;输出：[[&quot;a&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>本题涉及的两个关键问题：</p><ul><li>切割问题，有不同的切割方式</li><li>判断回文</li></ul><blockquote><p>回溯法是如何切割字符串的：</p><p>对于字符串<code>abcdef</code></p><ul><li>组合问题：选取一个a之后，在bcdef中再去选第二个，选取b之后再在cdef中选取第三个……</li><li>切割问题：切割一个a之后，在bcdef中再切割第二段，切割b之后再在cdef中切割第三段……</li></ul></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230103093900030.png" alt="image-20230103093900030"></p><p>递归用来纵向遍历，for循环用来横向遍历，切割线（图中的红线）切割到字符串的结尾，说明找到了一个切割方法</p><p>回溯三部曲：</p><ol><li><p>确定递归函数的参数</p><p>两个集合：<code>result</code>存放结果集、<code>path</code>存放符合切割后的回文的子串</p><p>参数需要<code>startIndex</code>来控制for循环的起始位置，因为切割过的地方不能重复切割</p><pre><code class="java">List&lt;List&lt;String&gt;&gt; result;Deque&lt;String&gt; path;void backtracking(String s, int startIndex)</code></pre></li><li><p>确认递归函数终止条件</p><p>从上图中可以看出，切割线到了字符串的最后面，就说明找到了一种切割方法，此时就是本层递归的终止条件</p><p>代码中的切割线：在处理组合问题的时候，递归函数需要传入<code>startIndex</code>，表示下一轮递归遍历的起始位置，这个<code>startIndex</code>就是切割线</p><pre><code class="java">if(startIndex &gt;= s.length()) &#123;    result.add(new ArrayList&lt;&gt;(path));    return;&#125;</code></pre></li><li><p>单层搜索的逻辑</p><p>在for循环中，定义了起始位置，那么<code>[startIndex, i]</code>就是要截取的子串</p><p>首先判断这个子串是不是回文，如果是回文，就加入到<code>path</code>中</p><pre><code class="java">for(int i = startIndex; i &lt; s.length(); i++) &#123;    if(isPalindrome(s, startIndex, i)) &#123;        // 是回文子串        String str = s.substring(startIndex, i + 1);        path.addLast(str);    &#125; else &#123;        // 不是则跳过        continue;    &#125;    // 寻找以 i+1 为起始位置的子串    backtracking(s, i + 1);    path.removeLast();&#125;</code></pre><p><strong>注意切割过的位置，不能重复切割，所以backtracking(s, i + 1)，传入下一层的起始位置为i+1</strong></p><p>判断回文子串，使用双指针即可</p><pre><code class="java">boolean isPalindrome(String s, int start, int end) &#123;    for(int i = start, j = end; i &lt; j; i++, j--) &#123;        if(s.charAt(i) != s.charAt(j)) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre></li></ol><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    private List&lt;List&lt;String&gt;&gt; result;    private Deque&lt;String&gt; path;    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        backtraking(s, 0);        return result;    &#125;    private void backtraking(String s, int startIndex) &#123;        if(startIndex &gt;= s.length()) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        for(int i = startIndex; i &lt; s.length(); i++) &#123;            if(isPalindrome(s, startIndex, i)) &#123;                String str = s.substring(startIndex, i + 1);                path.addLast(str);            &#125; else &#123;                continue;            &#125;            backtraking(s, i + 1);            path.removeLast();        &#125;    &#125;    private boolean isPalindrome(String s, int start, int end) &#123;        for(int i = start, j = end; i &lt; j; i++, j--) &#123;            if(s.charAt(i) != s.charAt(j)) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><h3 id="93、复原IP地址"><a href="#93、复原IP地址" class="headerlink" title="93、复原IP地址"></a>93、复原IP地址</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址 - 力扣（LeetCode）</a>**</p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;0000&quot;输出：[&quot;0.0.0.0&quot;]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;101023&quot;输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题是切割问题，<strong>切割问题就可以使用回溯搜索法把可能性搜索出来</strong></p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230104153603092.png" alt="image-20230104153603092"></p><p>回溯三部曲：</p><ol><li><p>确定递归函数的参数</p><p>参数：<code>startIndex</code>，因为不能重复分割，所以需要记录下一层递归分割的起始位置</p><p>还需要一个变量<code>pointNum</code>，记录添加逗点的数量</p><pre><code class="java">List&lt;String&gt; result;void backtraking(String s, int startIndex, int pointNum)</code></pre></li><li><p>确定终止条件</p><p>本题明确要求只会<strong>分割成4段</strong>，所以不能使用切割线切到最后作为终止条件，而是分割的段数作为终止条件</p><p><code>pointNum</code>表示逗点数量，所以<code>pointNum == 3</code>就说明字符串分成了4段，然后验证第四段是否合法，如果合法就添加到结果集</p><pre><code class="java">if(pointNum == 3) &#123;    if(isValid(s, startIndex, s.length() - 1)) &#123;        result.add(s);    &#125;&#125;</code></pre></li><li><p>确认单层搜索的逻辑</p><p>在for循环中，定义了起始位置，那么<code>[startIndex, i]</code>就是要截取的子串</p><p>首先判断这个子串是否合法，如果合法就在字符串后面加上符号<code>.</code>表示已经分割，如果不合法就结束本层循环，就如上图剪去的分支</p><p>然后就是递归和回溯的过程，下一层递归的<code>startIndex</code>要从<code>i+2</code>开始（因为需要在字符串中加入分隔符<code>.</code>），同时记录分隔符的数量的变量<code>pointNum</code>要加一，回溯的时候撤销上述递归的过程</p><pre><code class="java">for (int i = startIndex; i &lt; s.length(); i++) &#123;    if (isValid(s, startIndex, i)) &#123;        s = s.substring(0, i + 1) + &quot;.&quot; + s.substring(i + 1);    //在str的后⾯插⼊⼀个逗点        pointNum++;        backTrack(s, i + 2, pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2        pointNum--;// 回溯        s = s.substring(0, i + 1) + s.substring(i + 2);// 回溯删掉逗点    &#125; else &#123;        break;    &#125;&#125;</code></pre></li></ol><p><strong>判断子串是否合法</strong></p><p>主要考虑以下三点：</p><ul><li>子串以0为开头的数字不合法</li><li>子串中有非正整数字符不合法</li><li>子串如果大于了255不合法</li></ul><pre><code class="java">boolean isValid(String s, int start, int end) &#123;    if (start &gt; end) &#123;        return false;    &#125;    if (s.charAt(start) == &#39;0&#39; &amp;&amp; start != end) &#123; // 0开头的数字不合法        return false;    &#125;    int num = 0;    for (int i = start; i &lt;= end; i++) &#123;        if (s.charAt(i) &gt; &#39;9&#39; || s.charAt(i) &lt; &#39;0&#39;) &#123; // 遇到⾮数字字符不合法            return false;        &#125;        num = num * 10 + (s.charAt(i) - &#39;0&#39;);        if (num &gt; 255) &#123; // 如果⼤于255了不合法            return false;        &#125;    &#125;    return true;&#125;</code></pre><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>版本一：</p><pre><code class="java">class Solution &#123;    List&lt;String&gt; result;    public List&lt;String&gt; restoreIpAddresses(String s) &#123;        result = new ArrayList&lt;&gt;();        if(s.length() &gt; 12) return result;        backtracking(s, 0, 0);        return result;    &#125;    private void backtracking(String s, int startIndex, int pointNum) &#123;        if(pointNum == 3) &#123;            if(isValid(s, startIndex, s.length() - 1)) &#123;                result.add(s);                return;            &#125;        &#125;        for(int i = startIndex; i &lt; s.length(); i++) &#123;            if(isValid(s, startIndex, i)) &#123;                s = s.substring(0, i + 1) + &quot;.&quot; + s.substring(i + 1);                pointNum++;                backtracking(s, i + 2, pointNum);                pointNum--;                s = s.substring(0, i + 1) + s.substring(i + 2);            &#125; else break;        &#125;    &#125;    private boolean isValid(String s, int start, int end) &#123;        if(start &gt; end) return false;        if(s.charAt(start) == &#39;0&#39; &amp;&amp; start != end) return false;        int num = 0;        for(int i = start; i &lt;= end; i++) &#123;            char ch = s.charAt(i);            if(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;                return false;            &#125;            num = num * 10 + (ch - &#39;0&#39;);            if(num &gt; 255) return false;        &#125;        return true;    &#125;&#125;</code></pre><p>版本二（更好的剪枝优化）</p><pre><code class="java">class Solution &#123;    List&lt;String&gt; result = new ArrayList&lt;String&gt;();    StringBuilder stringBuilder = new StringBuilder();    public List&lt;String&gt; restoreIpAddresses(String s) &#123;        backtracking(s, 0, 0);        return result;    &#125;    // number表示stringbuilder中ip段的数量    public void backtracking(String s, int start, int number) &#123;        // 如果start等于s的长度并且ip段的数量是4，则加入结果集，并返回        if (start == s.length() &amp;&amp; number == 4) &#123;            result.add(stringBuilder.toString());            return;        &#125;        // 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回        if (start == s.length() || number == 4) &#123;            return;        &#125;        // 剪枝：ip段的长度最大是3，并且ip段处于[0,255]        for (int i = start; i &lt; s.length() &amp;&amp; i - start &lt; 3 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &gt;= 0                &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &lt;= 255; i++) &#123;            // 如果ip段的长度大于1，并且第一位为0的话，continue            if (i + 1 - start &gt; 1 &amp;&amp; s.charAt(start) - &#39;0&#39; == 0) &#123;                continue;            &#125;            stringBuilder.append(s.substring(start, i + 1));            // 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点            if (number &lt; 3) &#123;                stringBuilder.append(&quot;.&quot;);            &#125;            number++;            backtracking(s, i + 1, number);            number--;            // 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题            stringBuilder.delete(start + number, i + number + 2);        &#125;    &#125;&#125;</code></pre><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><h3 id="78、子集"><a href="#78、子集" class="headerlink" title="78、子集"></a>78、子集</h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/subsets/">78. 子集 - 力扣（LeetCode）</a>**</p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0]输出：[[],[0]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><blockquote><p>求<strong>子集问题</strong>和求<strong>组合、分割</strong>问题思路变化</p><p>如果把子集问题、组合问题、分割问题都抽象成一棵树的话，那么<strong>组合问题和分割问题都是收集树的叶子结点，而子集问题是找树的所有节点</strong></p></blockquote><p>其实子集问题也是一种组合问题，因为它的集合是无序的，子集<code>&#123;1,2&#125;</code>和子集<code>&#123;2,1&#125;</code>是一样的</p><p>&#x3D;&gt; <strong>既然是无序，取过的元素不会重复取，写回溯算法的时候，for循环就要从startIndex开始，而不是从0开始</strong></p><blockquote><p>从0开始的是<strong>排列问题</strong></p></blockquote><p>以<code>&#123;1,2,3&#125;</code>为例，把求子集抽象为树形结构</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230104163542142.png" alt="image-20230104163542142"></p><p>从图中的红色部分，可以看出遍历整棵树的时候，把所有节点都记录下来，就是要求的子集集合</p><p>回溯三部曲：</p><ol><li><p>确认递归函数的参数</p><pre><code class="java">// 存放符合条件结果的集合List&lt;List&lt;Integer&gt;&gt; result;// 存放符合条件的结果Deque&lt;Integer&gt; path;void backtracking(int[] nums, int startIndex)</code></pre></li><li><p>确认终止条件</p><p>从上图可以看出，剩余集合为空的时候，就是叶子结点，也就是当<code>startIndex &gt;= nums.length</code>时，就终止了，因为没有元素可取了</p><pre><code class="java">if(startIndex &gt;= nums.length) &#123;    return;&#125;</code></pre><p>其实可以不需要加终止条件，因为<code>startIndex &gt;= nums.length</code>的时候，本层for循环本来也要结束了</p></li><li><p>确认单层搜索逻辑</p><p><strong>求取子集问题，不需要任何的剪枝操作，因为子集就是要遍历整棵树</strong></p><pre><code class="java">for(int i = stratIndex; i &lt; nums.length; i++) &#123;    path.addLast(nums[i]);    backtracking(nums, startIndex);    path.removeLast();&#125;</code></pre></li></ol><h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    private List&lt;List&lt;Integer&gt;&gt; result;    private Deque&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        backtracking(nums, 0);        return result;    &#125;    private void backtracking(int[] nums, int startIndex) &#123;        result.add(new ArrayList&lt;&gt;(path)); // 收集⼦集，要放在终⽌添加的上面，否则会漏掉⾃⼰                // 可以不加终止条件，因为每次都是从 i+1开始        if(startIndex &gt;= nums.length) &#123;            return;        &#125;        for(int i = startIndex; i &lt; nums.length; i++) &#123;            path.addLast(nums[i]);            backtracking(nums, i + 1);            path.removeLast();        &#125;    &#125;&#125;</code></pre><h3 id="90、子集II"><a href="#90、子集II" class="headerlink" title="90、子集II"></a>90、子集II</h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II - 力扣（LeetCode）</a>**</p><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0]输出：[[],[0]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>本题和**<a href="https://leetcode.cn/problems/subsets/">78. 子集 - 力扣（LeetCode）</a><strong>区别就是集合里有重复元素了，而且求取的子集需要去重</strong>树层去重**</p><p>以示例<code>&#123;1, 2, 2&#125;</code>为例（<strong>注意去重需要先对集合进行排序</strong>）</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230104231023461.png" alt="image-20230104231023461"></p><h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><p>java代码</p><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; result;    Deque&lt;Integer&gt; path;        public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        Arrays.sort(nums);        backtracking(nums, 0, new boolean[nums.length]);        return result;    &#125;    private void backtracking(int[] nums, int startIndex, boolean[] used) &#123;        result.add(new ArrayList&lt;&gt;(path));        for(int i = startIndex; i &lt; nums.length; i++) &#123;            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123;                continue;            &#125;            path.addLast(nums[i]);            used[i] = true;            backtracking(nums, i + 1, used);            used[i] = false;            path.removeLast();        &#125;    &#125;&#125;</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="491、递增子序列"><a href="#491、递增子序列" class="headerlink" title="491、递增子序列"></a>491、递增子序列</h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列 - 力扣（LeetCode）</a>**</p><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [4,6,7,7]输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [4,4,3,2,1]输出：[[4,4]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 15</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><blockquote><p>这个递增子序列比较像是取有序的子集，而且本题也要求不能有相同的递增子序列。</p><p>&#x3D;&gt; 子集，去重</p><p>本题思路类似于<strong>求子集问题</strong>，在<code>LeetCode 90</code>中，是通过排序，再加一个标记数组来达到去重的目的。</p><p>而本题求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了，所以不能使用之间的去重逻辑。</p><p><em>本题给出的示例还是一个有序数组[4, 6, 7, 7]，更具有误导性，引导往排序的思路去做</em></p></blockquote><p>以<code>[4, 7, 6, 7]</code>为例：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230104233220419.png" alt="image-20230104233220419"></p><p>回溯三部曲：</p><ol><li><p>确定递归函数的参数</p><p>本题求的是子序列，很明显一个元素不能重复使用，所以需要<code>startIndex</code>，调整下一层递归的起始位置</p><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; result;Deque&lt;Integer&gt; path;void backtracking(int[] nums, int startIndex)</code></pre></li><li><p>确定终止条件</p><p>本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和<strong>求子集问题</strong>一样，可以不加终止条件，<code>startIndex</code>每次都会加1，并不会无限递归</p><p>但是本题收集结果有所不同，题目要求递增子序列大小至少为2，所以代码如下：</p><pre><code class="java">if(path.size() &gt; 1) &#123;    result.add(new ArrayList&lt;&gt;(path));    // 注意这里不需要return，因为要取树上的所有节点&#125;</code></pre></li><li><p>单层搜索逻辑</p><p>如上图，<strong>同一父结点下的同层上使用过的元素就不能再重复使用了</strong>，判断是否使用过：</p><ul><li>使用<code>map</code></li><li>使用数组</li></ul></li></ol><h4 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h4><p>使用<code>map</code></p><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; result;    Deque&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        backtracking(nums, 0);        return result;    &#125;    private void backtracking(int[] nums, int startIndex) &#123;        if(path.size() &gt; 1) &#123;            result.add(new ArrayList&lt;&gt;(path));        &#125;         Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for(int i = startIndex; i &lt; nums.length; i++) &#123;            if(!path.isEmpty() &amp;&amp; path.getLast() &gt; nums[i]) continue;            // 当前数层使用过当前数字            if(map.getOrDefault(nums[i], 0) &gt; 0) &#123;                continue;            &#125;            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);            path.addLast(nums[i]);            backtracking(nums, i + 1);            path.removeLast();        &#125;    &#125;&#125;</code></pre><p>使用数组</p><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; result;    Deque&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        backtracking(nums, 0);        return result;    &#125;    private void backtracking(int[] nums, int startIndex) &#123;        if(path.size() &gt; 1) &#123;            result.add(new ArrayList&lt;&gt;(path));        &#125;         int[] used = new int[201];                for(int i = startIndex; i &lt; nums.length; i++) &#123;            if(!path.isEmpty() &amp;&amp; path.getLast() &gt; nums[i]) continue;            // 当前数层使用过当前数字, +100保证数组不越界            if(used[nums[i] + 100] == 1) &#123;                continue;            &#125;            used[nums[i] + 100] = 1;            path.addLast(nums[i]);            backtracking(nums, i + 1);            path.removeLast();        &#125;    &#125;&#125;</code></pre><h3 id="332、重新安排行程"><a href="#332、重新安排行程" class="headerlink" title="332、重新安排行程"></a>332、重新安排行程</h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/reconstruct-itinerary/">332. 重新安排行程 - 力扣（LeetCode）</a>**</p><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><ul><li>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</li></ul><p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/itinerary1-graph.jpg" alt="img"></p><pre><code>输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/itinerary2-graph.jpg" alt="img"></p><pre><code>输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tickets.length &lt;= 300</code></li><li><code>tickets[i].length == 2</code></li><li><code>fromi.length == 3</code></li><li><code>toi.length == 3</code></li><li><code>fromi</code> 和 <code>toi</code> 由大写英文字母组成</li><li><code>fromi != toi</code></li></ul><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题直观上来看跟回溯法没有关系，更像是图论中的深度优先搜索</p><p>实际上确实是dfs，但这是dfs中使用到了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。</p></blockquote><p><strong>难点</strong></p><ul><li>一个行程中，如果航班处理不好容易变成一个圈，成为死循环</li><li>有多种解法，字母序靠前排在前面，如何记录映射关系</li><li>使用回溯法（也可以说是dfs）的终止条件是什么</li><li>搜索的过程中，如何遍历一个机场所对应的所有机场</li></ul><p><strong>理解死循环</strong></p><img src="E:/MyFile/TyporaImgs/image-20230106094652769.png" alt="image-20230106094652769" style="zoom:67%;" /><p>从上图中可以看出，出发机场和到达机场也会重复的，如果<strong>在解题的过程中，没有对集合元素处理好，就会死循环</strong></p><p><strong>记录映射关系</strong></p><p>使用如下的数据结构：</p><pre><code class="java">Map&lt;String, Map&lt;String, Integer&gt;&gt; targets;// =&gt; Map&lt;出发机场, Map&lt;到达机场, 航班次数&gt;&gt; targets</code></pre><p>搜索的过程一定要<strong>增删元素</strong>，因为出发机场和到达机场是会重复的，搜索的过程没能及时删除目的机场就会死循环。</p><p>在遍历<code>targets</code>的过程中，<strong>可以使用“航班次数”这个字段的数字做相应的增减，来标记机场是否使用过了</strong>。如果“航班次数”大于0，说明目的地还可以飞，如果“航班次数”等于0，说明目的地不能飞了，而不用对集合做删除或者增加元素的操作了 &#x3D;&gt; 逻辑删除，只是做了一个标记</p><p><strong>回溯法</strong></p><p>以<code>[[&quot;JFK&quot;,&quot;KUL&quot;],[&quot;JFK&quot;,&quot;NRT&quot;]，[&quot;NRT&quot;,&quot;JFK&quot;]]</code>为例</p><img src="E:/MyFile/TyporaImgs/image-20230106100407960.png" alt="image-20230106100407960" style="zoom:67%;" /><p>回溯三部曲：</p><ol><li><p>递归函数参数</p><p>需要<code>targets</code>记录航班的映射关系，定义为全局变量（也可以写入参数列表）</p><p>还需要一个全局变量<code>result</code>来记录行程信息（也可以写入参数列表）</p><p>参数中还需要<code>ticketNum</code>，来表示有多少个航班。</p><pre><code class="java">Deque&lt;String&gt; result;Map&lt;String, Map&lt;String, Integer&gt;&gt; targets;boolean backtracking(int ticketNum);</code></pre><p><strong>注意函数的返回值为boolean</strong></p><p>本题需要返回值是因为我们只需要找到一个行程，就是在树形结构中唯一一条通向叶子结点的路线（如上图），找到了这个叶子结点就直接返回。</p><blockquote><p><strong>如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。</strong></p></blockquote><p>初始化<code>targets</code>和<code>result</code></p><pre><code class="java">targets = new HashMap&lt;&gt;();result = new LinkedList&lt;&gt;();// 记录映射关系for(List&lt;String&gt; t : tickets)&#123;    Map&lt;String, Integer&gt; temp;    if(targets.containsKey(t.get(0)))&#123;        temp = targets.get(t.get(0));        temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);    &#125;else&#123;        //升序Map        temp = new TreeMap&lt;&gt;();        temp.put(t.get(1), 1);    &#125;    targets.put(t.get(0), temp);&#125;// 初识机场result.add(&quot;JFK&quot;);</code></pre></li><li><p>递归终止条件</p><p>以题目中所给的示例为例，<code>[[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]</code>，有4个航班，那么只要找出一种行程，行程里的机场个数是5就可以了</p><p>所以终止条件是：在回溯遍历的过程中，遇到的机场个数如果达到了 航班数量 ＋ 1，那么就说明找到了一个行程，把所有航班串在一起</p><pre><code class="java">if(result.size() == ticketNum + 1) &#123;    return true;&#125;</code></pre><blockquote><p>此处不需要在叶子节点收集结果，因为本题的path(result)记录的路径只有一条，在单层搜索的时候就已经添加元素了</p></blockquote></li><li><p>单层搜索的逻辑</p><pre><code class="java">String last = result.getLast();if(targets.containsKey(last))&#123;//防止出现null    for(Map.Entry&lt;String, Integer&gt; target : targets.get(last).entrySet())&#123;        int count = target.getValue();        // 记录到达机场是否飞过了        if(count &gt; 0)&#123;             result.add(target.getKey());            target.setValue(count - 1);            if(backTracking(ticketNum)) return true;            result.removeLast();            target.setValue(count);        &#125;    &#125;&#125;return false;</code></pre><p>利用<code>int count = target.getValue();</code>来判断集合里的机场是否使用过，避免了直接去删除元素</p></li></ol><h4 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h4><p>使用Map实现</p><pre><code class="java">class Solution &#123;    private Deque&lt;String&gt; result;    private Map&lt;String, Map&lt;String, Integer&gt;&gt; targets;    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;        result = new LinkedList&lt;&gt;();        targets = new HashMap&lt;&gt;();        // 初始化        for(List&lt;String&gt; ticket : tickets) &#123;            Map&lt;String, Integer&gt; temp;            if(targets.containsKey(ticket.get(0))) &#123;                temp = targets.get(ticket.get(0));                temp.put(ticket.get(1), temp.getOrDefault(ticket.get(1), 0) + 1);            &#125; else &#123;                temp = new TreeMap&lt;&gt;();                temp.put(ticket.get(1), 1);            &#125;            targets.put(ticket.get(0), temp);        &#125;        result.add(&quot;JFK&quot;);        backtraking(tickets.size());        return new ArrayList&lt;&gt;(result);    &#125;    private boolean backtraking(int ticketNum) &#123;        if(result.size() == ticketNum + 1) &#123;            return true;        &#125;        String last = result.getLast();        if(targets.containsKey(last)) &#123;            for(Map.Entry&lt;String, Integer&gt; target : targets.get(last).entrySet()) &#123;                int count = target.getValue();                if(count &gt; 0) &#123;                    result.addLast(target.getKey());                    target.setValue(count - 1);                    if(backtraking(ticketNum)) return true;                    result.removeLast();                    target.setValue(count);                &#125;            &#125;        &#125;        return false;    &#125;&#125;</code></pre><p>使用LinkedList实现</p><pre><code class="java">class Solution &#123;    private LinkedList&lt;String&gt; res;    private LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;();    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;        Collections.sort(tickets, (a, b) -&gt; a.get(1).compareTo(b.get(1)));        path.add(&quot;JFK&quot;);        boolean[] used = new boolean[tickets.size()];        backTracking((ArrayList) tickets, used);        return res;    &#125;    public boolean backTracking(ArrayList&lt;List&lt;String&gt;&gt; tickets, boolean[] used) &#123;        if (path.size() == tickets.size() + 1) &#123;            res = new LinkedList(path);            return true;        &#125;        for (int i = 0; i &lt; tickets.size(); i++) &#123;            if (!used[i] &amp;&amp; tickets.get(i).get(0).equals(path.getLast())) &#123;                path.add(tickets.get(i).get(1));                used[i] = true;                if (backTracking(tickets, used)) &#123;                    return true;                &#125;                used[i] = false;                path.removeLast();            &#125;        &#125;        return false;    &#125;&#125;</code></pre><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><h3 id="46、全排列"><a href="#46、全排列" class="headerlink" title="46、全排列"></a>46、全排列</h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/permutations/">46. 全排列 - 力扣（LeetCode）</a>**</p><p>定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1]输出：[[0,1],[1,0]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1]输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>以集合<code>&#123;1, 2, 3&#125;</code>为例</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230105091456503.png" alt="image-20230105091456503"></p><p>回溯三部曲：</p><ol><li><p>确认递归函数的参数</p><p>首先排列是有序的，也就是说<code>&#123;1, 2&#125;</code>和<code>&#123;2, 1&#125;</code>是两个不同的集合，这是和<strong>子集</strong>以及<strong>组合</strong>有所不同的地方。可以看出元素1在<code>&#123;1, 2&#125;</code>使用过一次，在<code>&#123;2, 1&#125;</code>还要使用一次，所以处理排列问题就不能再使用<code>startIndex</code>了，但是排列问题需要一个标记数组<code>used</code>，标记已经选择的元素</p><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; result;Deque&lt;Integer&gt; path;void backtracking(int[] nums, boolean[] used)</code></pre></li><li><p>确定递归终止条件</p><p>从上图可以看出，叶子结点就是要收集结果的地方。</p><p>到达叶子结点的时机：当收集元素的集合<code>path</code>的大小和<code>num</code>数组一样大的时候，说明找到了一个全排列，也表明到达了叶子结点</p><pre><code class="java">if(path.size() == nums.length) &#123;    result.add(new ArrayList&lt;&gt;(path));    return;&#125;</code></pre></li><li><p>单层搜索逻辑</p><p>此处<code>for</code>循环里不需要使用<code>startIndex</code>了，因为排列问题，每次都要从头开始搜索，需要多次使用一个元素。而<code>used</code>数组，就是记录此时<code>path</code>里都使用了哪些元素，一个排列里一个元素只能使用一次。</p><pre><code class="java">for(int i = 0; i &lt; nums.length; i++) &#123;    // path已经收录的元素，直接跳过    if(used[i]) continue;    used[i] = true;    path.addLast(nums[i]);    backtracking(nums, used);    path.removeLast();    used[i] = false;&#125;</code></pre></li></ol><h4 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h4><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; result;    Deque&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        backtracking(nums, new boolean[nums.length]);        return result;    &#125;    private void backtracking(int[] nums, boolean[] used) &#123;        if(path.size() == nums.length) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        for(int i = 0; i &lt; nums.length; i++) &#123;            if(used[i]) continue;            path.addLast(nums[i]);            used[i] = true;            backtracking(nums, used);            used[i] = false;            path.removeLast();        &#125;    &#125;&#125;</code></pre><h3 id="47、全排列II"><a href="#47、全排列II" class="headerlink" title="47、全排列II"></a>47、全排列II</h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II - 力扣（LeetCode）</a>**</p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>本题和<code>LeetCode 46</code>的区别在于<strong>给定一个包含重复数字的序列，要返回所有不重复的全排列</strong> &#x3D;&gt; <strong>去重（对元素进行排序）</strong></p><p>以序列<code>&#123;1, 1, 2&#125;</code>为例</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230105094902780.png" alt="image-20230105094902780"></p><p>图中同一树层的元素要进行去重。一般来说，<strong>组合问题和排列问题是在树形结构的叶子结点上收集结果，而子集问题就是取树上所有节点的结果</strong></p><h4 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h4><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; result;    Deque&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;        result = new ArrayList&lt;&gt;();        path = new LinkedList&lt;&gt;();        Arrays.sort(nums);        backtracking(nums, new boolean[nums.length]);        return result;    &#125;    private void backtracking(int[] nums, boolean[] used) &#123;        if(path.size() == nums.length) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        for(int i = 0; i &lt; nums.length; i++) &#123;            if(i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !used[i - 1]) &#123;                continue;            &#125;            //如果同⼀树⽀nums[i]没使⽤过开始处理            if(!used[i]) &#123;                path.addLast(nums[i]);                used[i] = true;                backtracking(nums, used);                used[i] = false;                path.removeLast();            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p><strong>树枝去重</strong> &amp;&amp; <strong>树层去重</strong></p><p>上述代码去重关键代码：</p><p><strong>树层去重</strong></p><pre><code class="java">if(i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !used[i - 1]) &#123;    continue;&#125;</code></pre><p><strong>树枝去重</strong></p><p>如果改成<code>used[i] == true</code> ，也是正确的</p><pre><code class="java">if(i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; used[i - 1]) &#123;    continue;&#125;</code></pre><p><strong>对于排列问题，二者都可以，但是树层去重效率更高</strong></p><p>以输入<code>&#123;1, 1, 1&#125;</code>为例</p><p><strong>树层去重</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230105101809761.png" alt="image-20230105101809761"></p><p><strong>树枝去重</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230105102655074.png" alt="image-20230105102655074"></p><p>上图可以看出，<strong>树层去重</strong>对前一位去重非常彻底，效率很高，<strong>树枝去重</strong>对前一位去重虽然最后可以得到答案，但是做了很多无用的搜索。</p><h2 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h2><h3 id="51、N皇后"><a href="#51、N皇后" class="headerlink" title="51、N皇后"></a>51、N皇后</h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a>**</p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/queens.jpg" alt="img"></p><pre><code>输入：n = 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1输出：[[&quot;Q&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>本题的约束条件</p><ul><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ul><p>搜索皇后的位置 &#x3D;&gt; 抽象为一棵树</p><p>以<code>n = 3</code>为例</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230107101152385.png" alt="image-20230107101152385"></p><p>从图中可以看出二维矩阵中矩阵的搞就是这棵树的高度，矩阵的宽就是树形结构中每个节点的宽度 &#x3D;&gt; 利用皇后的约束条件来回溯搜索这棵树，<strong>只要搜索到了树的叶子结点，说明就找到了皇后们的合理位置</strong></p><p>回溯三部曲：</p><ol><li><p>确认递归函数参数</p><p>定义全局变量<code>result</code>来记录最终的结果</p><p>参数：<code>n</code>是棋盘的大小，<code>row</code>记录当前遍历到棋盘的第几层了，<code>chessboard</code>记录每种结果</p><pre><code class="java">List&lt;List&lt;String&gt;&gt; result;void backtracking(int n, int row, char[][] chessboard)</code></pre></li><li><p>递归终止条件</p><p>收集叶子结点</p><pre><code class="java">if(row == n) &#123;    result.add(Array2List(chessboard));&#125;</code></pre></li><li><p>单层搜索的逻辑</p><p>递归深度就是row控制棋盘的行，每一层的for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置</p><p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始</p><pre><code class="java">for(int col = 0; col &lt; n; col++) &#123;    if(isValid(row, col, chessboard, n)) &#123;        // 验证合法        // 放置皇后        chessboard[row][col] = &#39;Q&#39;;         backtracking(n, row + 1, chessboard);        // 回溯，撤销皇后        chessboard[row][col] = &#39;.&#39;;    &#125;&#125;</code></pre></li></ol><p><strong>验证棋盘是否合法</strong></p><p>按照本题的约束条件</p><ul><li>不能同行</li><li>不能同列</li><li>不能同斜线（45°或者135°角）</li></ul><pre><code class="java">boolean isValid(int row, int col, int n, char[][] chessboard) &#123;    // 检查列    for (int i = 0; i &lt; row; i++) &#123; // 相当于剪枝        if (chessboard[i][col] == &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    // 检查45度对角线    for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;        if (chessboard[i][j] == &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    // 检查135度对角线    for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt;= n - 1; i--, j++) &#123;        if (chessboard[i][j] == &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><p>上述代码没有对行进行检查，因为在单层搜索的过程中，每一层的递归，只会选取for循环（也就是同一行）里的元素，所以不需要去重了</p><h4 id="实现-13"><a href="#实现-13" class="headerlink" title="实现"></a>实现</h4><pre><code class="java">class Solution &#123;    private List&lt;List&lt;String&gt;&gt; result;    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;        result = new ArrayList&lt;&gt;();        char[][] chessboard = new char[n][n];        for(char[] c : chessboard) &#123;            Arrays.fill(c, &#39;.&#39;);        &#125;                backtracking(n, 0, chessboard);        return result;    &#125;    private void backtracking(int n, int row, char[][] chessboard) &#123;        if(n == row) &#123;            result.add(Array2List(chessboard));            return;        &#125;        for(int col = 0; col &lt; n; col++) &#123;            if(isValid(row, col, n, chessboard)) &#123;                chessboard[row][col] = &#39;Q&#39;;                backtracking(n, row + 1, chessboard);                chessboard[row][col] = &#39;.&#39;;            &#125;        &#125;    &#125;    private List&lt;String&gt; Array2List(char[][] chessboard) &#123;        List&lt;String&gt; chessboardList = new ArrayList&lt;&gt;();        for(char[] c : chessboard) &#123;            chessboardList.add(String.copyValueOf(c));        &#125;        return chessboardList;    &#125;    private boolean isValid(int row, int col, int n, char[][] chessboard) &#123;        for(int i = 0; i &lt; row; i++) &#123;            if(chessboard[i][col] == &#39;Q&#39;) return false;        &#125;        for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;            if(chessboard[i][j] == &#39;Q&#39;) return false;        &#125;        for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;            if(chessboard[i][j] == &#39;Q&#39;) return false;        &#125;        return true;    &#125;&#125;</code></pre><pre><code class="java">// 方法2：使用boolean数组表示已经占用的直(斜)线class Solution &#123;    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();    boolean[] usedCol, usedDiag45, usedDiag135;    // boolean数组中的每个元素代表一条直(斜)线    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;        usedCol = new boolean[n];                  // 列方向的直线条数为 n        usedDiag45 = new boolean[2 * n - 1];       // 45°方向的斜线条数为 2 * n - 1        usedDiag135 = new boolean[2 * n - 1];      // 135°方向的斜线条数为 2 * n - 1        //用于收集结果, 元素的index表示棋盘的row，元素的value代表棋盘的column        int[] board = new int[n];        backTracking(board, n, 0);        return res;    &#125;    private void backTracking(int[] board, int n, int row) &#123;        if (row == n) &#123;            //收集结果            List&lt;String&gt; temp = new ArrayList&lt;&gt;();            for (int i : board) &#123;                char[] str = new char[n];                Arrays.fill(str, &#39;.&#39;);                str[i] = &#39;Q&#39;;                temp.add(new String(str));            &#125;            res.add(temp);            return;        &#125;        for (int col = 0; col &lt; n; col++) &#123;            if (usedCol[col] | usedDiag45[row + col] | usedDiag135[row - col + n - 1]) &#123;                continue;            &#125;            board[row] = col;            // 标记该列出现过            usedCol[col] = true;            // 同一45°斜线上元素的row + col为定值, 且各不相同            usedDiag45[row + col] = true;            // 同一135°斜线上元素row - col为定值, 且各不相同            // row - col 值有正有负, 加 n - 1 是为了对齐零点            usedDiag135[row - col + n - 1] = true;            // 递归            backTracking(board, n, row + 1);            usedCol[col] = false;            usedDiag45[row + col] = false;            usedDiag135[row - col + n - 1] = false;        &#125;    &#125;&#125;</code></pre><h3 id="37、解数独"><a href="#37、解数独" class="headerlink" title="37、解数独"></a>37、解数独</h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a>**</p><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p><pre><code>输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</code></pre> <img src="E:/MyFile/TyporaImgs/image-20230107104550879.png" alt="image-20230107104550879" style="zoom:50%;" /><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p><strong>二维递归</strong></p><p>N皇后问题是因为每⼀⾏每⼀列只放⼀个皇后，只需要⼀层for循环遍历⼀⾏，递归来来遍历列，然后⼀⾏⼀列确定皇后的唯⼀位置。</p><p>而本题中<strong>棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更深更宽</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20230107105615997.png" alt="image-20230107105615997"></p><p>回溯三部曲：</p><ol><li><p>确认递归函数以及参数</p><p><strong>递归函数的返回值需要是boolean类型</strong>，因为解数独找到一个符合条件（树的叶子结点）立即返回，相当于从根结点到叶子结点一条唯一路径，所以需要使用<code>boolean</code>返回值</p><pre><code class="java">void backtracking(char[][] board)</code></pre></li><li><p>确认递归终止条件</p><p>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子结点就立即返回</p><p>不用终止条件不会死循环 &#x3D;&gt; 递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止，所以不需要终止条件</p></li><li><p>单层搜索逻辑</p><p>从上图可以看出本题需要的是一个二维的递归（也就是两个for煦暖嵌套着递归）</p><p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历的这个位置放9个数字的可能性</strong></p><pre><code class="java">boolean backtracking(char[][] board)&#123;    //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，    // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」    for (int i = 0; i &lt; 9; i++)&#123; // 遍历行        for (int j = 0; j &lt; 9; j++)&#123; // 遍历列            if (board[i][j] != &#39;.&#39;)&#123; // 跳过原始数字                continue;            &#125;            for (char k = &#39;1&#39;; k &lt;= &#39;9&#39;; k++)&#123; // (i, j) 这个位置放k是否合适                if (isValid(i, j, k, board))&#123;                    board[i][j] = k;                    if (backtracking(board))&#123; // 如果找到合适一组立刻返回                        return true;                    &#125;                    board[i][j] = &#39;.&#39;;                &#125;            &#125;            // 9个数都试完了，都不行，那么就返回false            return false;            // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！            // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」        &#125;    &#125;    // 遍历完没有返回false，说明找到了合适棋盘位置了    return true;&#125;</code></pre><p>注意此处<code>return false</code>的位置，因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解，那么会直接返回，<strong>这是为什么没有终止条件也不会永远填不满棋盘而无限递归下去</strong></p></li></ol><p><strong>判断棋盘是否合法</strong></p><p>判断合法的三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>九宫格内是否重复</li></ul><pre><code class="java">boolean isValid(int row, int col, char val, char[][] board)&#123;    // 同行是否重复    for (int i = 0; i &lt; 9; i++)&#123;        if (board[row][i] == val)&#123;            return false;        &#125;    &#125;    // 同列是否重复    for (int j = 0; j &lt; 9; j++)&#123;        if (board[j][col] == val)&#123;            return false;        &#125;    &#125;    // 9宫格里是否重复    int startRow = (row / 3) * 3;    int startCol = (col / 3) * 3;    for (int i = startRow; i &lt; startRow + 3; i++)&#123;        for (int j = startCol; j &lt; startCol + 3; j++)&#123;            if (board[i][j] == val)&#123;                return false;            &#125;        &#125;    &#125;    return true;&#125;</code></pre><h4 id="实现-14"><a href="#实现-14" class="headerlink" title="实现"></a>实现</h4><pre><code class="java">class Solution &#123;    public void solveSudoku(char[][] board) &#123;        backtracking(board);    &#125;    private boolean backtracking(char[][] board) &#123;        for(int i = 0; i &lt; 9; i++) &#123;            for(int j = 0; j &lt; 9; j++) &#123;                if(board[i][j] != &#39;.&#39;) &#123;                    continue;                &#125;                for(char k = &#39;1&#39;; k &lt;= &#39;9&#39;; k++) &#123;                    if(isValid(i, j, k, board)) &#123;                        board[i][j] = k;                        if(backtracking(board)) &#123;                            return true;                        &#125;                        board[i][j] = &#39;.&#39;;                    &#125;                &#125;                return false;            &#125;        &#125;        return true;    &#125;    private boolean isValid(int row, int col, char val, char[][] board) &#123;        // 同行是否重复        for (int i = 0; i &lt; 9; i++)&#123;            if (board[row][i] == val)&#123;                return false;            &#125;        &#125;        // 同列是否重复        for (int j = 0; j &lt; 9; j++)&#123;            if (board[j][col] == val)&#123;                return false;            &#125;        &#125;        // 九宫格内是否重复        int startRow = (row / 3) * 3;        int startCol = (col / 3) * 3;        for (int i = startRow; i &lt; startRow + 3; i++)&#123;            for (int j = startCol; j &lt; startCol + 3; j++)&#123;                if (board[i][j] == val)&#123;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><h2 id="补充：性能分析"><a href="#补充：性能分析" class="headerlink" title="补充：性能分析"></a>补充：性能分析</h2><h3 id="子集问题-1"><a href="#子集问题-1" class="headerlink" title="子集问题"></a>子集问题</h3><ul><li>时间复杂度：<code>O(n * 2^n)</code>，因为每⼀个元素的状态⽆外乎取与不取，所以时间复杂度为<code>O(2^n)</code>，构造每⼀组⼦集都需要填进数组，又有需要<code>O(n)</code>，最终时间复杂度：<code>O(n * 2^n)</code></li><li>空间复杂度：<code>O(n)</code>，递归深度为n，所以系统栈所⽤空间为<code>O(n)</code>，每⼀层递归所⽤的空间都是常数级别，注意代码⾥的result和path都是全局变量，就算是放在参数⾥，传的也是引⽤，并不会新申请内存空间，最终空间复杂度为<code>O(n)</code></li></ul><h3 id="排列问题-1"><a href="#排列问题-1" class="headerlink" title="排列问题"></a>排列问题</h3><ul><li>时间复杂度：<code>O(n!)</code>，这个可以从排列的树形图中很明显发现，每⼀层节点为n，第 ⼆层每⼀个分⽀都延伸了n-1个分⽀，再往下又是n-2个分⽀，所以⼀直到叶⼦节 点⼀共就是 <code>n * n-1 * n-2 * ..... 1 = n!</code>。</li><li>空间复杂度：<code>O(n)</code>，和⼦集问题同理。</li></ul><p><strong>组合问题</strong></p><ul><li>时间复杂度：<code>O(n * 2^n)</code>，组合问题其实就是⼀种⼦集的问题，所以组合问题最坏 的情况，也不会超过⼦集问题的时间复杂度。</li><li>空间复杂度：<code>O(n)</code>，和子集问题同理</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> BackTracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义SpringIOC</title>
      <link href="/2023/01/03/%E8%87%AA%E5%AE%9A%E4%B9%89SpringIOC/"/>
      <url>/2023/01/03/%E8%87%AA%E5%AE%9A%E4%B9%89SpringIOC/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89springioc">自定义SpringIOC</a><ul><li><a href="#%E4%B8%80springioc%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E7%BB%93%E6%9E%84">一、SpringIOC核心功能结构</a><ul><li><a href="#1bean%E6%A6%82%E8%BF%B0">1、bean概述</a></li></ul></li><li><a href="#%E4%BA%8Cspring-ioc%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90">二、Spring IOC相关接口分析</a><ul><li><a href="#1beanfactory%E8%A7%A3%E6%9E%90">1、BeanFactory解析</a></li><li><a href="#2beandefinition%E8%A7%A3%E6%9E%90">2、BeanDefinition解析</a></li><li><a href="#3beandefinitionreader%E8%A7%A3%E6%9E%90">3、BeanDefinitionReader解析</a></li><li><a href="#4beandefinitionregistry%E8%A7%A3%E6%9E%90">4、BeanDefinitionRegistry解析</a></li><li><a href="#5%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8">5、创建容器</a></li></ul></li><li><a href="#%E4%B8%89%E8%87%AA%E5%AE%9A%E4%B9%89springioc">三、自定义SpringIOC</a><ul><li><a href="#741-%E5%AE%9A%E4%B9%89bean%E7%9B%B8%E5%85%B3%E7%9A%84pojo%E7%B1%BB">7.4.1 定义bean相关的pojo类</a><ul><li><a href="#7411-propertyvalue%E7%B1%BB">7.4.1.1 PropertyValue类</a></li><li><a href="#7412-mutablepropertyvalues%E7%B1%BB">7.4.1.2 MutablePropertyValues类</a></li><li><a href="#7413-beandefinition%E7%B1%BB">7.4.1.3 BeanDefinition类</a></li></ul></li><li><a href="#742-%E5%AE%9A%E4%B9%89%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%B1%BB">7.4.2 定义注册表相关类</a><ul><li><a href="#7421-beandefinitionregistry%E6%8E%A5%E5%8F%A3">7.4.2.1 BeanDefinitionRegistry接口</a></li><li><a href="#7422-simplebeandefinitionregistry%E7%B1%BB">7.4.2.2 SimpleBeanDefinitionRegistry类</a></li></ul></li><li><a href="#743-%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9B%B8%E5%85%B3%E7%B1%BB">7.4.3 定义解析器相关类</a><ul><li><a href="#7431-beandefinitionreader%E6%8E%A5%E5%8F%A3">7.4.3.1 BeanDefinitionReader接口</a></li><li><a href="#7432-xmlbeandefinitionreader%E7%B1%BB">7.4.3.2 XmlBeanDefinitionReader类</a></li></ul></li><li><a href="#744-ioc%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E7%B1%BB">7.4.4 IOC容器相关类</a><ul><li><a href="#7441-beanfactory%E6%8E%A5%E5%8F%A3">7.4.4.1 BeanFactory接口</a></li><li><a href="#7442-applicationcontext%E6%8E%A5%E5%8F%A3">7.4.4.2 ApplicationContext接口</a></li><li><a href="#7443-abstractapplicationcontext%E7%B1%BB">7.4.4.3 AbstractApplicationContext类</a></li><li><a href="#7444-classpathxmlapplicationcontext%E7%B1%BB">7.4.4.4 ClassPathXmlApplicationContext类</a></li></ul></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h1 id="自定义SpringIOC"><a href="#自定义SpringIOC" class="headerlink" title="自定义SpringIOC"></a>自定义SpringIOC</h1><blockquote><p>完整代码地址：<a href="https://gitee.com/ding-xinliang/my-spring-ioc">MySpringIOC: 自定义SpringIOC 功能，简陋版 (gitee.com)</a></p></blockquote><h2 id="一、SpringIOC核心功能结构"><a href="#一、SpringIOC核心功能结构" class="headerlink" title="一、SpringIOC核心功能结构"></a>一、SpringIOC核心功能结构</h2><p>Spring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为:</p><p>核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是 Spring 框架的总体架构图：</p><img src="E:/MyFile/TyporaImgs/image-20200429111324770.png" alt="image-20200429111324770" style="zoom:67%;" /><p>核心容器由 <code>beans</code>、<code>core</code>、<code>context </code>和 <code>expression</code>（Spring Expression Language，SpEL）4个模块组成。</p><ul><li><code>spring-beans</code>和<code>spring-core</code>模块是<code>Spring</code>框架的核心模块，包含了控制反转（<code>Inversion of Control，IOC</code>）和依赖注入（<code>Dependency Injection，DI</code>）。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。BeanFactory属于延时加载，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该 Bean 进行实例化与依赖关系的装配。</li><li><code>spring-context</code>模块构架于核心模块之上，扩展了<code>BeanFactory</code>，为它添加了<code>Bean</code>生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，<code>ApplicationContext </code>是该模块的核心接口，它的超类是 <code>BeanFactory</code>。与<code>BeanFactory</code>不同，<code>ApplicationContext</code>实例化后会自动对所有的单实例<code>Bean</code>进行实例化与依赖关系的装配，使之处于待用状态。</li><li><code>spring-context-support</code>模块是对<code>Spring IoC</code>容器及<code>IoC</code>子容器的扩展支持。</li><li><code>spring-context-indexer</code>模块是Spring的类管理组件和Classpath扫描组件。</li><li><code>spring-expression </code>模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同<code>Spring IoC</code>进行交互。</li></ul><h3 id="1、bean概述"><a href="#1、bean概述" class="headerlink" title="1、bean概述"></a>1、bean概述</h3><p>Spring 就是面向 <code>Bean</code> 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring IoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。</p><p>为什么Bean如此重要呢？</p><ul><li>spring 将bean对象交由一个叫IOC容器进行管理。</li><li>bean对象之间的依赖关系在配置文件中体现，并由spring完成。</li></ul><h2 id="二、Spring-IOC相关接口分析"><a href="#二、Spring-IOC相关接口分析" class="headerlink" title="二、Spring IOC相关接口分析"></a>二、Spring IOC相关接口分析</h2><h3 id="1、BeanFactory解析"><a href="#1、BeanFactory解析" class="headerlink" title="1、BeanFactory解析"></a>1、BeanFactory解析</h3><p>Spring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200429185050396.png" alt="image-20200429185050396"></p><p>其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。</p><p>那么为何要定义这么多层次的接口呢？</p><p>每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如，</p><ul><li>ListableBeanFactory接口表示这些Bean可列表化。</li><li>HierarchicalBeanFactory表示这些Bean 是有继承关系的，也就是每个 Bean 可能有父 Bean</li><li>AutowireCapableBeanFactory 接口定义Bean的自动装配规则。</li></ul><p>这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是BeanFactory，来看一下它的源码：</p><pre><code class="java">public interface BeanFactory &#123;    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;    //根据bean的名称获取IOC容器中的的bean对象    Object getBean(String name) throws BeansException;    //根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了    &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;    Object getBean(String name, Object... args) throws BeansException;    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;        &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType);    &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType);    //判断容器中是否包含指定名称的bean对象    boolean containsBean(String name);    //根据bean的名称判断是否是单例    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;    boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;    boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;    @Nullable    Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;    String[] getAliases(String name);&#125;</code></pre><p>在BeanFactory里只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。</p><p>BeanFactory有一个很重要的子接口，就是ApplicationContext接口，该接口主要来规范容器中的bean对象是非延时加载，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200430220155371.png" alt="image-20200430220155371"></p><p>要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如：</p><ul><li>ClasspathXmlApplicationContext : 根据类路径加载xml配置文件，并创建IOC容器对象。</li><li>FileSystemXmlApplicationContext ：根据系统路径加载xml配置文件，并创建IOC容器对象。</li><li>AnnotationConfigApplicationContext ：加载注解类配置，并创建IOC容器。</li></ul><h3 id="2、BeanDefinition解析"><a href="#2、BeanDefinition解析" class="headerlink" title="2、BeanDefinition解析"></a>2、BeanDefinition解析</h3><p>Spring IoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以BeanDefinition来描述的，如下面配置文件</p><pre><code class="xml">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;!--bean标签还有很多属性：    scope、init-method、destory-method等。--&gt;</code></pre><p>其继承体系如下图所示</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200429204239868.png" alt="image-20200429204239868"></p><h3 id="3、BeanDefinitionReader解析"><a href="#3、BeanDefinitionReader解析" class="headerlink" title="3、BeanDefinitionReader解析"></a>3、BeanDefinitionReader解析</h3><p>Bean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200429204700956.png" alt="image-20200429204700956"></p><p>看看BeanDefinitionReader接口定义的功能来理解它具体的作用：</p><pre><code class="java">public interface BeanDefinitionReader &#123;    //获取BeanDefinitionRegistry注册器对象    BeanDefinitionRegistry getRegistry();    @Nullable    ResourceLoader getResourceLoader();    @Nullable    ClassLoader getBeanClassLoader();    BeanNameGenerator getBeanNameGenerator();    /*        下面的loadBeanDefinitions都是加载bean定义，从指定的资源中    */    int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException;    int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException;    int loadBeanDefinitions(String location) throws BeanDefinitionStoreException;    int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException;&#125;</code></pre><h3 id="4、BeanDefinitionRegistry解析"><a href="#4、BeanDefinitionRegistry解析" class="headerlink" title="4、BeanDefinitionRegistry解析"></a>4、BeanDefinitionRegistry解析</h3><p>BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry。</p><pre><code class="java">public interface BeanDefinitionRegistry extends AliasRegistry &#123;    //往注册表中注册bean    void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)            throws BeanDefinitionStoreException;    //从注册表中删除指定名称的bean    void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;    //获取注册表中指定名称的bean    BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;        //判断注册表中是否已经注册了指定名称的bean    boolean containsBeanDefinition(String beanName);        //获取注册表中所有的bean的名称    String[] getBeanDefinitionNames();        int getBeanDefinitionCount();    boolean isBeanNameInUse(String beanName);&#125;</code></pre><p>继承结构图如下：</p><p><img src="E:/MyFile/TyporaImgs/image-20200429211132185-16727463277121.png" alt="image-20200429211132185"></p><p>从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个：</p><ul><li><p>DefaultListableBeanFactory</p><p>在该类中定义了如下代码，就是用来注册bean</p><pre><code class="java">private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</code></pre></li></ul><ul><li><p>SimpleBeanDefinitionRegistry</p><p>在该类中定义了如下代码，就是用来注册</p><pre><code class="java">x 1private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(64);</code></pre></li></ul><h3 id="5、创建容器"><a href="#5、创建容器" class="headerlink" title="5、创建容器"></a>5、创建容器</h3><p><code>ClassPathXmlApplicationContext</code>对<code>Bean</code>配置资源的载入是从<code>refresh（）</code>方法开始的。<code>refresh（）</code>方法是一个模板方法，规定了 IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean 配置资源进行载入，<code>ClassPathXmlApplicationContext</code>通过调用其父类<code>AbstractApplicationContext</code>的r<code>efresh（）</code>方法启动整个IoC容器对Bean定义的载入过程。</p><h2 id="三、自定义SpringIOC"><a href="#三、自定义SpringIOC" class="headerlink" title="三、自定义SpringIOC"></a>三、自定义SpringIOC</h2><p>现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="7-4-1-定义bean相关的pojo类"><a href="#7-4-1-定义bean相关的pojo类" class="headerlink" title="7.4.1 定义bean相关的pojo类"></a>7.4.1 定义bean相关的pojo类</h3><h4 id="7-4-1-1-PropertyValue类"><a href="#7-4-1-1-PropertyValue类" class="headerlink" title="7.4.1.1 PropertyValue类"></a>7.4.1.1 PropertyValue类</h4><p>用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。</p><pre><code class="java">public class PropertyValue &#123;  private String name;  private String ref;  private String value;  public PropertyValue() &#123;  &#125;  public PropertyValue(String name, String ref,String value) &#123;    this.name = name;    this.ref = ref;    this.value = value;  &#125;  public String getName() &#123;    return name;  &#125;  public void setName(String name) &#123;    this.name = name;  &#125;  public String getRef() &#123;    return ref;  &#125;  public void setRef(String ref) &#123;    this.ref = ref;  &#125;  public String getValue() &#123;    return value;  &#125;  public void setValue(String value) &#123;    this.value = value;  &#125;&#125;</code></pre><h4 id="7-4-1-2-MutablePropertyValues类"><a href="#7-4-1-2-MutablePropertyValues类" class="headerlink" title="7.4.1.2 MutablePropertyValues类"></a>7.4.1.2 MutablePropertyValues类</h4><p>一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来存储并管理多个PropertyValue对象。</p><pre><code class="java">public class MutablePropertyValues implements Iterable&lt;PropertyValue&gt; &#123;    private final List&lt;PropertyValue&gt; propertyValueList;    public MutablePropertyValues() &#123;        this.propertyValueList = new ArrayList&lt;PropertyValue&gt;();    &#125;    public MutablePropertyValues(List&lt;PropertyValue&gt; propertyValueList) &#123;        this.propertyValueList = (propertyValueList != null ? propertyValueList : new ArrayList&lt;PropertyValue&gt;());    &#125;    public PropertyValue[] getPropertyValues() &#123;        return this.propertyValueList.toArray(new PropertyValue[0]);    &#125;    public PropertyValue getPropertyValue(String propertyName) &#123;        for (PropertyValue pv : this.propertyValueList) &#123;            if (pv.getName().equals(propertyName)) &#123;                return pv;            &#125;        &#125;        return null;    &#125;    @Override    public Iterator&lt;PropertyValue&gt; iterator() &#123;        return propertyValueList.iterator();    &#125;    public boolean isEmpty() &#123;        return this.propertyValueList.isEmpty();    &#125;    public MutablePropertyValues addPropertyValue(PropertyValue pv) &#123;        for (int i = 0; i &lt; this.propertyValueList.size(); i++) &#123;            PropertyValue currentPv = this.propertyValueList.get(i);            if (currentPv.getName().equals(pv.getName())) &#123;                this.propertyValueList.set(i, new PropertyValue(pv.getName(),pv.getRef(), pv.getValue()));                return this;            &#125;        &#125;        this.propertyValueList.add(pv);        return this;    &#125;    public boolean contains(String propertyName) &#123;        return getPropertyValue(propertyName) != null;    &#125;&#125;</code></pre><h4 id="7-4-1-3-BeanDefinition类"><a href="#7-4-1-3-BeanDefinition类" class="headerlink" title="7.4.1.3 BeanDefinition类"></a>7.4.1.3 BeanDefinition类</h4><p>BeanDefinition类用来封装bean信息的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。</p><pre><code class="java">public class BeanDefinition &#123;    private String id;    private String className;    private MutablePropertyValues propertyValues;    public BeanDefinition() &#123;        propertyValues = new MutablePropertyValues();    &#125;    public String getId() &#123;        return id;    &#125;    public void setId(String id) &#123;        this.id = id;    &#125;    public String getClassName() &#123;        return className;    &#125;    public void setClassName(String className) &#123;        this.className = className;    &#125;    public void setPropertyValues(MutablePropertyValues propertyValues) &#123;        this.propertyValues = propertyValues;    &#125;    public MutablePropertyValues getPropertyValues() &#123;        return propertyValues;    &#125;&#125;</code></pre><h3 id="7-4-2-定义注册表相关类"><a href="#7-4-2-定义注册表相关类" class="headerlink" title="7.4.2 定义注册表相关类"></a>7.4.2 定义注册表相关类</h3><h4 id="7-4-2-1-BeanDefinitionRegistry接口"><a href="#7-4-2-1-BeanDefinitionRegistry接口" class="headerlink" title="7.4.2.1 BeanDefinitionRegistry接口"></a>7.4.2.1 BeanDefinitionRegistry接口</h4><p>BeanDefinitionRegistry接口定义了注册表的相关操作，定义如下功能：</p><ul><li>注册BeanDefinition对象到注册表中</li><li>从注册表中删除指定名称的BeanDefinition对象</li><li>根据名称从注册表中获取BeanDefinition对象</li><li>判断注册表中是否包含指定名称的BeanDefinition对象</li><li>获取注册表中BeanDefinition对象的个数</li><li>获取注册表中所有的BeanDefinition的名称</li></ul><pre><code class="java">public interface BeanDefinitionRegistry &#123;    //注册BeanDefinition对象到注册表中    void registerBeanDefinition(String beanName, BeanDefinition beanDefinition);    //从注册表中删除指定名称的BeanDefinition对象    void removeBeanDefinition(String beanName) throws Exception;    //根据名称从注册表中获取BeanDefinition对象    BeanDefinition getBeanDefinition(String beanName) throws Exception;    boolean containsBeanDefinition(String beanName);    int getBeanDefinitionCount();    String[] getBeanDefinitionNames();&#125;</code></pre><h4 id="7-4-2-2-SimpleBeanDefinitionRegistry类"><a href="#7-4-2-2-SimpleBeanDefinitionRegistry类" class="headerlink" title="7.4.2.2 SimpleBeanDefinitionRegistry类"></a>7.4.2.2 SimpleBeanDefinitionRegistry类</h4><p>该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。</p><pre><code class="java">public class SimpleBeanDefinitionRegistry implements BeanDefinitionRegistry &#123;    private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new HashMap&lt;String, BeanDefinition&gt;();    @Override    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) &#123;        beanDefinitionMap.put(beanName,beanDefinition);    &#125;    @Override    public void removeBeanDefinition(String beanName) throws Exception &#123;        beanDefinitionMap.remove(beanName);    &#125;    @Override    public BeanDefinition getBeanDefinition(String beanName) throws Exception &#123;        return beanDefinitionMap.get(beanName);    &#125;    @Override    public boolean containsBeanDefinition(String beanName) &#123;        return beanDefinitionMap.containsKey(beanName);    &#125;    @Override    public int getBeanDefinitionCount() &#123;        return beanDefinitionMap.size();    &#125;    @Override    public String[] getBeanDefinitionNames() &#123;        return beanDefinitionMap.keySet().toArray(new String[1]);    &#125;&#125;</code></pre><h3 id="7-4-3-定义解析器相关类"><a href="#7-4-3-定义解析器相关类" class="headerlink" title="7.4.3 定义解析器相关类"></a>7.4.3 定义解析器相关类</h3><h4 id="7-4-3-1-BeanDefinitionReader接口"><a href="#7-4-3-1-BeanDefinitionReader接口" class="headerlink" title="7.4.3.1 BeanDefinitionReader接口"></a>7.4.3.1 BeanDefinitionReader接口</h4><p>BeanDefinitionReader是用来解析配置文件并在注册表中注册bean的信息。定义了两个规范：</p><ul><li>获取注册表的功能，让外界可以通过该对象获取注册表对象。</li><li>加载配置文件，并注册bean数据。</li></ul><pre><code class="java">public interface BeanDefinitionReader &#123;    //获取注册表对象    BeanDefinitionRegistry getRegistry();    //加载配置文件并在注册表中进行注册    void loadBeanDefinitions(String configLocation) throws Exception;&#125;</code></pre><h4 id="7-4-3-2-XmlBeanDefinitionReader类"><a href="#7-4-3-2-XmlBeanDefinitionReader类" class="headerlink" title="7.4.3.2 XmlBeanDefinitionReader类"></a>7.4.3.2 XmlBeanDefinitionReader类</h4><p>XmlBeanDefinitionReader类是专门用来解析xml配置文件的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。</p><pre><code class="java">public class XmlBeanDefinitionReader implements BeanDefinitionReader &#123;    private BeanDefinitionRegistry registry;    public XmlBeanDefinitionReader() &#123;        this.registry = new SimpleBeanDefinitionRegistry();    &#125;    @Override    public BeanDefinitionRegistry getRegistry() &#123;        return registry;    &#125;    @Override    public void loadBeanDefinitions(String configLocation) throws Exception &#123;        InputStream is = this.getClass().getClassLoader().getResourceAsStream(configLocation);        SAXReader reader = new SAXReader();        Document document = reader.read(is);        Element rootElement = document.getRootElement();        //解析bean标签        parseBean(rootElement);    &#125;    private void parseBean(Element rootElement) &#123;        List&lt;Element&gt; elements = rootElement.elements();        for (Element element : elements) &#123;            String id = element.attributeValue(&quot;id&quot;);            String className = element.attributeValue(&quot;class&quot;);            BeanDefinition beanDefinition = new BeanDefinition();            beanDefinition.setId(id);            beanDefinition.setClassName(className);            List&lt;Element&gt; list = element.elements(&quot;property&quot;);            MutablePropertyValues mutablePropertyValues = new MutablePropertyValues();            for (Element element1 : list) &#123;                String name = element1.attributeValue(&quot;name&quot;);                String ref = element1.attributeValue(&quot;ref&quot;);                String value = element1.attributeValue(&quot;value&quot;);                PropertyValue propertyValue = new PropertyValue(name,ref,value);                mutablePropertyValues.addPropertyValue(propertyValue);            &#125;            beanDefinition.setPropertyValues(mutablePropertyValues);            registry.registerBeanDefinition(id,beanDefinition);        &#125;    &#125;&#125;</code></pre><h3 id="7-4-4-IOC容器相关类"><a href="#7-4-4-IOC容器相关类" class="headerlink" title="7.4.4 IOC容器相关类"></a>7.4.4 IOC容器相关类</h3><h4 id="7-4-4-1-BeanFactory接口"><a href="#7-4-4-1-BeanFactory接口" class="headerlink" title="7.4.4.1 BeanFactory接口"></a>7.4.4.1 BeanFactory接口</h4><p>在该接口中定义IOC容器的统一规范即获取bean对象。</p><pre><code class="java">public interface BeanFactory &#123;    //根据bean对象的名称获取bean对象    Object getBean(String name) throws Exception;    //根据bean对象的名称获取bean对象，并进行类型转换    &lt;T&gt; T getBean(String name, Class&lt;? extends T&gt; clazz) throws Exception;&#125;</code></pre><h4 id="7-4-4-2-ApplicationContext接口"><a href="#7-4-4-2-ApplicationContext接口" class="headerlink" title="7.4.4.2 ApplicationContext接口"></a>7.4.4.2 ApplicationContext接口</h4><p>该接口的所以的子实现类对bean对象的创建都是非延时的，所以在该接口中定义 <code>refresh()</code> 方法，该方法主要完成以下两个功能：</p><ul><li>加载配置文件。</li><li>根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。</li></ul><pre><code class="java">public interface ApplicationContext extends BeanFactory &#123;    //进行配置文件加载并进行对象创建    void refresh() throws IllegalStateException, Exception;&#125;</code></pre><h4 id="7-4-4-3-AbstractApplicationContext类"><a href="#7-4-4-3-AbstractApplicationContext类" class="headerlink" title="7.4.4.3 AbstractApplicationContext类"></a>7.4.4.3 AbstractApplicationContext类</h4><ul><li><p>作为ApplicationContext接口的子类，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。</p></li><li><p>声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。</p><p>BeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。</p></li></ul><pre><code class="java">public abstract class AbstractApplicationContext implements ApplicationContext &#123;    protected BeanDefinitionReader beanDefinitionReader;    //用来存储bean对象的容器   key存储的是bean的id值，value存储的是bean对象    protected Map&lt;String, Object&gt; singletonObjects = new HashMap&lt;String, Object&gt;();    //存储配置文件的路径    protected String configLocation;    public void refresh() throws IllegalStateException, Exception &#123;        //加载BeanDefinition        beanDefinitionReader.loadBeanDefinitions(configLocation);        //初始化bean        finishBeanInitialization();    &#125;    //bean的初始化    private void finishBeanInitialization() throws Exception &#123;        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();        String[] beanNames = registry.getBeanDefinitionNames();        for (String beanName : beanNames) &#123;            BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);            getBean(beanName);        &#125;    &#125;&#125;</code></pre><blockquote><p>注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。</p></blockquote><h4 id="7-4-4-4-ClassPathXmlApplicationContext类"><a href="#7-4-4-4-ClassPathXmlApplicationContext类" class="headerlink" title="7.4.4.4 ClassPathXmlApplicationContext类"></a>7.4.4.4 ClassPathXmlApplicationContext类</h4><p>该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能：</p><ul><li>在构造方法中，创建BeanDefinitionReader对象。</li><li>在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。</li><li>重写父接口中的getBean()方法，并实现依赖注入操作。</li></ul><pre><code class="java">public class ClassPathXmlApplicationContext extends AbstractApplicationContext&#123;    public ClassPathXmlApplicationContext(String configLocation) &#123;        this.configLocation = configLocation;        //构建XmlBeanDefinitionReader对象        beanDefinitionReader = new XmlBeanDefinitionReader();        try &#123;            this.refresh();        &#125; catch (Exception e) &#123;        &#125;    &#125;    //根据bean的id属性值获取bean对象    @Override    public Object getBean(String name) throws Exception &#123;        //return singletonObjects.get(name);        Object obj = singletonObjects.get(name);        if(obj != null) &#123;            return obj;        &#125;        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();        BeanDefinition beanDefinition = registry.getBeanDefinition(name);        if(beanDefinition == null) &#123;            return null;        &#125;        String className = beanDefinition.getClassName();        Class&lt;?&gt; clazz = Class.forName(className);        Object beanObj = clazz.newInstance();        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();        for (PropertyValue propertyValue : propertyValues) &#123;            String propertyName = propertyValue.getName();            String value = propertyValue.getValue();            String ref = propertyValue.getRef();            if(ref != null &amp;&amp; !&quot;&quot;.equals(ref)) &#123;                Object bean = getBean(ref);                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);                Method[] methods = clazz.getMethods();                for (Method method : methods) &#123;                    if(method.getName().equals(methodName)) &#123;                        method.invoke(beanObj,bean);                    &#125;                &#125;            &#125;            if(value != null &amp;&amp; !&quot;&quot;.equals(value)) &#123;                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);                Method method = clazz.getMethod(methodName, String.class);                method.invoke(beanObj,value);            &#125;        &#125;        singletonObjects.put(name,beanObj);        return beanObj;    &#125;    @Override    public &lt;T&gt; T getBean(String name, Class&lt;? extends T&gt; clazz) throws Exception &#123;        Object bean = getBean(name);        if(bean != null) &#123;            return clazz.cast(bean);        &#125;        return null;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-行为型模式</title>
      <link href="/2023/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E4%B8%89%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">三、行为型模式</a><ul><li><a href="#31-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">3.1 模板方法模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9">4、优缺点</a></li><li><a href="#5%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">5、适用场景</a></li><li><a href="#6jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">6、JDK源码解析</a></li></ul></li><li><a href="#32-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">3.2 策略模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-1">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-1">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-1">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-1">4、优缺点</a></li><li><a href="#5%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">5、使用场景</a></li><li><a href="#6jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1">6、JDK源码解析</a></li></ul></li><li><a href="#33-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">3.3 命令模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-2">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-2">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-2">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-2">4、优缺点</a></li><li><a href="#5%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1">5、使用场景</a></li><li><a href="#6jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2">6、JDK源码解析</a></li></ul></li><li><a href="#34-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">3.4 责任链模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-3">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-3">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-3">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-3">4、优缺点</a></li><li><a href="#5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">5、源码解析</a></li></ul></li><li><a href="#35-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F">3.5 状态模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-4">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-4">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-4">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-4">4、优缺点</a></li><li><a href="#5%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2">5、使用场景</a></li></ul></li><li><a href="#36-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">3.6 观察者模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-5">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-5">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-5">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-5">4、优缺点</a></li><li><a href="#5%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3">5、使用场景</a></li><li><a href="#6jdk%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AE%9E%E7%8E%B0">6、JDK中提供的实现</a></li></ul></li><li><a href="#37-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">3.7 中介者模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-6">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-6">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-6">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-6">4、优缺点</a></li><li><a href="#5%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-4">5、使用场景</a></li></ul></li><li><a href="#38-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">3.8 迭代器模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-7">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-7">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-7">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-7">4、优缺点</a></li><li><a href="#5%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-5">5、使用场景</a></li><li><a href="#6-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">6 JDK源码解析</a></li></ul></li><li><a href="#39-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">3.9 访问者模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-8">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-8">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-8">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-8">4、优缺点</a></li><li><a href="#5--%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">5  使用场景</a></li><li><a href="#6%E6%89%A9%E5%B1%95">6、扩展</a><ul><li><a href="#%E5%88%86%E6%B4%BE">分派</a></li><li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE">动态分派</a></li><li><a href="#%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE">静态分派</a></li><li><a href="#%E5%8F%8C%E5%88%86%E6%B4%BE">双分派</a></li></ul></li></ul></li><li><a href="#310-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F">3.10 备忘录模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-9">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-9">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-9">3、案例</a><ul><li><a href="#1%E7%99%BD%E7%AE%B1%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F">1）“白箱”备忘录模式</a></li><li><a href="#2%E9%BB%91%E7%AE%B1%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F">2）“黑箱”备忘录模式</a></li></ul></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-9">4、优缺点</a></li><li><a href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">5 使用场景</a></li></ul></li><li><a href="#311-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F">3.11 解释器模式</a><ul><li><a href="#1%E6%A6%82%E8%BF%B0-10">1、概述</a></li><li><a href="#2%E7%BB%93%E6%9E%84-10">2、结构</a></li><li><a href="#3%E6%A1%88%E4%BE%8B-10">3、案例</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9-10">4、优缺点</a></li><li><a href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1">5 使用场景</a></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><blockquote><p>完整代码地址：<a href="https://gitee.com/ding-xinliang/design-pattern">DesignPattern: Java设计模式 (gitee.com)</a></p></blockquote><h1 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h1><p>1）行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或者对象之间怎样相互协作共同完成单个对象无法单独完成的任务，它涉及算法与对象之间职责的分配。</p><p>2）行为型模式分类：</p><p><strong>类行为模式</strong>：采用继承机制来在类间分配行为</p><ul><li>模板方法模式</li><li>解释器模式</li></ul><p><strong>对象行为模式</strong>：采用组合或者聚合在对象间分配行为</p><ul><li>策略模式</li><li>命令模式</li><li>职责链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li></ul><p><em>由于组合关系和聚合关系比继承关系耦合度要低，满足“合成复用原则”，所以对象行为模式比类行为模式有更大的灵活性</em></p><h2 id="3-1-模板方法模式"><a href="#3-1-模板方法模式" class="headerlink" title="3.1 模板方法模式"></a>3.1 模板方法模式</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><p><strong>定义：</strong></p><p>定义一个操作中的<strong>算法骨架</strong>，而将算法的一些<strong>步骤延迟到子类</strong>中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><h3 id="2、结构"><a href="#2、结构" class="headerlink" title="2、结构"></a>2、结构</h3><p>模板方法（<code>Template Method</code>）模式包含以下主要角色：</p><ul><li><p>抽象类（<code>Abstract Class</code>）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p><ul><li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p></li><li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p><ul><li><p><strong>抽象方法</strong>(<code>Abstract Method</code>) ：一个抽象方法由抽象类声明、由其具体子类实现。</p></li><li><p>具体方法(<code>Concrete Method</code>) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p></li><li><p><strong>钩子方法</strong>(<code>Hook Method</code>) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为<code>isXxx</code>，返回值类型为<code>boolean</code>类型。</p></li></ul></li></ul></li><li><p>具体子类（<code>Concrete Class</code>）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p></li></ul><h3 id="3、案例"><a href="#3、案例" class="headerlink" title="3、案例"></a>3、案例</h3><p>【例】炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="模板方法模式"></p><p>代码实现</p><p><strong>AbstractClass抽象类</strong></p><pre><code class="java">/** * 抽象类 * * @author codejuzi */public abstract class AbstractClass &#123;    public final void cookProcess() &#123;        pourOil();        heatOil();        pourVegetable();        pourSauce();        fry();    &#125;    public void pourOil() &#123;        System.out.println(&quot;--倒油&quot;);    &#125;    public void heatOil() &#123;        System.out.println(&quot;--热油&quot;);    &#125;    public abstract void pourVegetable();    public abstract void pourSauce();    public void fry() &#123;        System.out.println(&quot;--炒菜&quot;);    &#125;&#125;</code></pre><p><strong>CabbageConcreteClass</strong></p><pre><code class="java">/** * 具体对象类 -- 包菜 * * @author codejuzi */public class CabbageConcreteClass extends AbstractClass&#123;    @Override    public void pourVegetable() &#123;        System.out.println(&quot;--加入包菜&quot;);    &#125;    @Override    public void pourSauce() &#123;        System.out.println(&quot;--加辣椒&quot;);    &#125;&#125;</code></pre><p><strong>SpinachConcreteClass</strong></p><pre><code class="java">/** * 具体对象类 -- 菠菜 * * @author codejuzi */public class SpinachConcreteClass extends AbstractClass&#123;    @Override    public void pourVegetable() &#123;        System.out.println(&quot;--加入菠菜&quot;);    &#125;    @Override    public void pourSauce() &#123;        System.out.println(&quot;--加老干妈&quot;);    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">public class AbstractClassTest &#123;    @Test    public void cookProcess() &#123;        AbstractClass cook = new CabbageConcreteClass();        cook.cookProcess();        System.out.println(&quot;------------------------------&quot;);        cook = new SpinachConcreteClass();        cook.cookProcess();    &#125;&#125;</code></pre><p><strong>注意</strong>：为了防止恶意操作，一般模板方法上面都加上<code>final</code>关键字</p><h3 id="4、优缺点"><a href="#4、优缺点" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h3 id="5、适用场景"><a href="#5、适用场景" class="headerlink" title="5、适用场景"></a>5、适用场景</h3><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul><h3 id="6、JDK源码解析"><a href="#6、JDK源码解析" class="headerlink" title="6、JDK源码解析"></a>6、JDK源码解析</h3><p><code>InputStream</code>类就使用了模板方法模式。在<code>InputStream</code>类中定义了多个 <code>read()</code> 方法，如下：</p><pre><code class="java">public abstract class InputStream implements Closeable &#123;    //抽象方法，要求子类必须重写    public abstract int read() throws IOException;    public int read(byte b[]) throws IOException &#123;        return read(b, 0, b.length);    &#125;    public int read(byte b[], int off, int len) throws IOException &#123;        if (b == null) &#123;            throw new NullPointerException();        &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123;            throw new IndexOutOfBoundsException();        &#125; else if (len == 0) &#123;            return 0;        &#125;        int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据        if (c == -1) &#123;            return -1;        &#125;        b[off] = (byte)c;        int i = 1;        try &#123;            for (; i &lt; len ; i++) &#123;                c = read();                if (c == -1) &#123;                    break;                &#125;                b[off + i] = (byte)c;            &#125;        &#125; catch (IOException ee) &#123;        &#125;        return i;    &#125;&#125;</code></pre><p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。 </p><p>在该方法中第18行、27行，可以看到调用了无参的抽象的 <code>read()</code> 方法。</p><p>总结如下： 在<code>InputStream</code>父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p><h2 id="3-2-策略模式"><a href="#3-2-策略模式" class="headerlink" title="3.2 策略模式"></a>3.2 策略模式</h2><h3 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h3><p>我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200210143039168.png" alt="image-20200210143039168"></p><p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200210144457478.png" alt="image-20200210144457478"></p><p><strong>定义：</strong></p><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以<strong>相互替换</strong>，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><h3 id="2、结构-1"><a href="#2、结构-1" class="headerlink" title="2、结构"></a>2、结构</h3><p>策略模式的主要角色如下：</p><ul><li>抽象策略（<code>Strategy</code>）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（<code>Concrete Strategy</code>）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（<code>Context</code>）类：持有一个策略类的引用，最终给客户端调用。</li></ul><h3 id="3、案例-1"><a href="#3、案例-1" class="headerlink" title="3、案例"></a>3、案例</h3><p>【例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt="策略模式"></p><p>代码实现</p><p><strong>Strategy接口</strong>：定义了百货公司所有促销活动的共同接口</p><pre><code class="java">/** * 抽象策略 * * @author codejuzi */public interface Strategy &#123;    void show();&#125;</code></pre><p>定义具体策略角色（Concrete Strategy)：每个节日具体的促销活动</p><p><strong>StrategyA类</strong></p><pre><code class="java">/** * 具体策略类 * * @author codejuzi */public class StrategyA implements Strategy&#123;    @Override    public void show() &#123;        System.out.println(&quot;买一送一&quot;);    &#125;&#125;</code></pre><p><strong>StrategyB类</strong></p><pre><code class="java">/** * 具体策略类 * * @author codejuzi */public class StrategyB implements Strategy&#123;    @Override    public void show() &#123;        System.out.println(&quot;满200元减50元&quot;);    &#125;&#125;</code></pre><p><strong>StrategyC类</strong></p><pre><code class="java">/** * 具体策略类 * * @author codejuzi */public class StrategyC implements Strategy &#123;    @Override    public void show() &#123;        System.out.println(&quot;满1000元加一元换购任意200元以下商品&quot;);    &#125;&#125;</code></pre><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解成销售员</p><p><strong>SaleMan类</strong></p><pre><code class="java">/** * 环境角色 * * @author codejuzi */public class SaleMan &#123;    private Strategy strategy;    public SaleMan(Strategy strategy) &#123;        this.strategy = strategy;    &#125;    public void salemanShow() &#123;        strategy.show();    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">public class SaleManTest &#123;    @Test    public void salemanShow() &#123;        SaleMan saleMan = new SaleMan(new StrategyA());        saleMan.salemanShow();        System.out.println(&quot;----------------------&quot;);        saleMan = new SaleMan(new StrategyB());        saleMan.salemanShow();        System.out.println(&quot;----------------------&quot;);        saleMan = new SaleMan(new StrategyC());        saleMan.salemanShow();        System.out.println(&quot;----------------------&quot;);    &#125;&#125;</code></pre><h3 id="4、优缺点-1"><a href="#4、优缺点-1" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点：</strong></p><ul><li><p>策略类之间可以自由切换：由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p></li><li><p>易于扩展：增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p></li></ul><p><strong>缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="5、使用场景"><a href="#5、使用场景" class="headerlink" title="5、使用场景"></a>5、使用场景</h3><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h3 id="6、JDK源码解析-1"><a href="#6、JDK源码解析-1" class="headerlink" title="6、JDK源码解析"></a>6、JDK源码解析</h3><p><code>Comparator</code> 中的策略模式。在Arrays类中有一个 <code>sort()</code> 方法</p><pre><code class="java">public class Arrays&#123;    public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;        if (c == null) &#123;            sort(a);        &#125; else &#123;            if (LegacyMergeSort.userRequested)                legacyMergeSort(a, c);            else                TimSort.sort(a, 0, a.length, c, null, 0, 0);        &#125;    &#125;&#125;</code></pre><p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p><pre><code class="java">public class demo &#123;    public static void main(String[] args) &#123;        Integer[] data = &#123;12, 2, 3, 2, 4, 5, 1&#125;;        // 实现降序排序        Arrays.sort(data, (a, b) -&gt; b - a);        System.out.println(Arrays.toString(data)); //[12, 5, 4, 3, 2, 2, 1]    &#125;&#125;</code></pre><p>在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。</p><p>那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 <code>compare()</code> 方法呢？</p><pre><code class="java">class TimSort&lt;T&gt; &#123;    static &lt;T&gt; void sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c,                         T[] work, int workBase, int workLen) &#123;        assert c != null &amp;&amp; a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;        int nRemaining  = hi - lo;        if (nRemaining &lt; 2)            return;  // Arrays of size 0 and 1 are always sorted        // If array is small, do a &quot;mini-TimSort&quot; with no merges        if (nRemaining &lt; MIN_MERGE) &#123;            int initRunLen = countRunAndMakeAscending(a, lo, hi, c);            binarySort(a, lo, hi, lo + initRunLen, c);            return;        &#125;        ...    &#125;               private static &lt;T&gt; int countRunAndMakeAscending(T[] a, int lo, int hi,Comparator&lt;? super T&gt; c) &#123;        assert lo &lt; hi;        int runHi = lo + 1;        if (runHi == hi)            return 1;        // Find end of run, and reverse range if descending        if (c.compare(a[runHi++], a[lo]) &lt; 0) &#123; // Descending            while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &lt; 0)                runHi++;            reverseRange(a, lo, runHi);        &#125; else &#123;                              // Ascending            while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &gt;= 0)                runHi++;        &#125;        return runHi - lo;    &#125;&#125;</code></pre><p>上面的代码中最终会执行 <code>countRunAndMakeAscending()</code> 这个方法，<code>countRunAndMakeAscending()</code>调用了<code>compare()</code>方法。所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。</p><h2 id="3-3-命令模式"><a href="#3-3-命令模式" class="headerlink" title="3.3 命令模式"></a>3.3 命令模式</h2><h3 id="1、概述-2"><a href="#1、概述-2" class="headerlink" title="1、概述"></a>1、概述</h3><p>日常生活中，我们出去吃饭都会遇到下面的场景。</p><img src="E:/MyFile/TyporaImgs/image-20200211130313251.png" alt="image-20200211130313251" style="zoom:67%;" /><p><strong>定义：</strong></p><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p><h3 id="2、结构-2"><a href="#2、结构-2" class="headerlink" title="2、结构"></a>2、结构</h3><p>命令模式包含以下主要角色：</p><ul><li>抽象命令类（<code>Command</code>）角色： 定义命令的接口，声明执行的方法。</li><li>具体命令（<code>Concrete  Command</code>）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li><li>实现者&#x2F;接收者（<code>Receiver</code>）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li><li>调用者&#x2F;请求者（<code>Invoker</code>）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li></ul><h3 id="3、案例-2"><a href="#3、案例-2" class="headerlink" title="3、案例"></a>3、案例</h3><p>【例】点菜吃饭</p><p>服务员： 就是调用者角色，由她来发起命令。</p><p>资深大厨： 就是接收者角色，真正命令执行的对象。</p><p>订单： 命令中包含订单。</p><p>类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="命令模式"></p><p>代码实现</p><p><strong>Command接口</strong></p><pre><code class="java">/** * 抽象命令接口 * * @author codejuzi */public interface Command &#123;    void execute();&#125;</code></pre><p><strong>OrderCommand类</strong></p><pre><code class="java">/** * 具体命令类 * * @author codejuzi */public class OrderCommand implements Command&#123;    /**     * Receiver     */    private final SeniorChef seniorChef;    private final Order order;    public OrderCommand(SeniorChef seniorChef, Order order) &#123;        this.seniorChef = seniorChef;        this.order = order;    &#125;    @Override    public void execute() &#123;        System.out.println(order.getDiningTableId() + &quot;桌的订单：&quot;);        Set&lt;String&gt; keys = order.getFoodDic().keySet();        for (String key : keys) &#123;            seniorChef.makeFood(key,order.getFoodDic().get(key));        &#125;        try &#123;            Thread.sleep(100);//停顿一下 模拟做饭的过程        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(order.getDiningTableId() + &quot;桌的饭弄好了&quot;);    &#125;&#125;</code></pre><p><strong>Order类</strong></p><pre><code class="java">/** * 单桌菜单对象 * * @author codjuzi */public class Order &#123;    private int diningTableId;    private final Map&lt;String, Integer&gt; foodDic;    public Order() &#123;        foodDic = new HashMap&lt;&gt;();    &#125;    public int getDiningTableId() &#123;        return diningTableId;    &#125;    public void setDiningTableId(int diningTableId) &#123;        this.diningTableId = diningTableId;    &#125;    public Map&lt;String, Integer&gt; getFoodDic() &#123;        return foodDic;    &#125;    public void setFoodDic(String dishName, int dishNum) &#123;        foodDic.put(dishName, dishNum);    &#125;&#125;</code></pre><p><strong>SeniorChef类</strong></p><pre><code class="java">/** * Receiver * * @author codejuzi */public class SeniorChef &#123;    public void makeFood(String dishName, int dishNum) &#123;        System.out.println(dishNum + &quot;份&quot; + dishName);    &#125;&#125;</code></pre><p><strong>Waiter类</strong></p><pre><code class="java">/** * Invoker * * @author codejuzi */public class Waitor &#123;    private final List&lt;Command&gt; commandList;    public Waitor() &#123;        commandList = new ArrayList&lt;&gt;();    &#125;    public void addCommand(Command command) &#123;        commandList.add(command);    &#125;    /**     * 发出命令     */    public void orderUp() &#123;        System.out.println(&quot;美女服务员：叮咚，大厨，新订单来了.......&quot;);        for (Command command : commandList) &#123;            if(command != null) &#123;                command.execute();            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">public class WaitorTest &#123;    @Test    public void test() &#123;        //创建2个order        Order order1 = new Order();        order1.setDiningTableId(1);        order1.getFoodDic().put(&quot;西红柿鸡蛋面&quot;, 1);        order1.getFoodDic().put(&quot;小杯可乐&quot;, 2);        Order order2 = new Order();        order2.setDiningTableId(3);        order2.getFoodDic().put(&quot;尖椒肉丝盖饭&quot;, 1);        order2.getFoodDic().put(&quot;小杯雪碧&quot;, 1);        //创建接收者        SeniorChef receiver = new SeniorChef();        //将订单和接收者封装成命令对象        OrderCommand cmd1 = new OrderCommand(receiver, order1);        OrderCommand cmd2 = new OrderCommand(receiver, order2);        Waitor waitor = new Waitor();        waitor.addCommand(cmd1);        waitor.addCommand(cmd2);        waitor.orderUp();    &#125;&#125;</code></pre><h3 id="4、优缺点-2"><a href="#4、优缺点-2" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点：</strong></p><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。</li><li>系统结构更加复杂。</li></ul><h3 id="5、使用场景-1"><a href="#5、使用场景-1" class="headerlink" title="5、使用场景"></a>5、使用场景</h3><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li></ul><h3 id="6、JDK源码解析-2"><a href="#6、JDK源码解析-2" class="headerlink" title="6、JDK源码解析"></a>6、JDK源码解析</h3><p><code>Runable</code>是一个典型命令模式，<code>Runnable</code>担当命令的角色，<code>Thread</code>充当的是调用者，<code>start</code>方法就是其执行方法</p><pre><code class="java">//命令接口(抽象命令角色)public interface Runnable &#123;    public abstract void run();&#125;</code></pre><pre><code class="java">//调用者public class Thread implements Runnable &#123;    private Runnable target;        public synchronized void start() &#123;        if (threadStatus != 0)            throw new IllegalThreadStateException();        group.add(this);        boolean started = false;        try &#123;            start0();            started = true;        &#125; finally &#123;            try &#123;                if (!started) &#123;                    group.threadStartFailed(this);                &#125;            &#125; catch (Throwable ignore) &#123;            &#125;        &#125;    &#125;        private native void start0();&#125;</code></pre><p><code>start()</code>方法会调用一个<code>native</code>方法<code>start0()</code>,调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者</p><pre><code class="java">/** * jdk Runnable 命令模式 *TurnOffThread ： 属于具体 */public class TurnOffThread implements Runnable&#123;     private Receiver receiver;         public TurnOffThread(Receiver receiver) &#123;         this.receiver = receiver;     &#125;     public void run() &#123;         receiver.turnOFF();     &#125;&#125;</code></pre><pre><code class="java">/** * 测试类 */public class Demo &#123;     public static void main(String[] args) &#123;         Receiver receiver = new Receiver();         TurnOffThread turnOffThread = new TurnOffThread(receiver);         Thread thread = new Thread(turnOffThread);         thread.start();     &#125;&#125;</code></pre><h2 id="3-4-责任链模式"><a href="#3-4-责任链模式" class="headerlink" title="3.4 责任链模式"></a>3.4 责任链模式</h2><h3 id="1、概述-3"><a href="#1、概述-3" class="headerlink" title="1、概述"></a>1、概述</h3><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p><p><strong>定义：</strong></p><p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><h3 id="2、结构-3"><a href="#2、结构-3" class="headerlink" title="2、结构"></a>2、结构</h3><p>职责链模式主要包含以下角色:</p><ul><li>抽象处理者（<code>Handler</code>）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（<code>Concrete Handler</code>）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（<code>Client</code>）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><h3 id="3、案例-3"><a href="#3、案例-3" class="headerlink" title="3、案例"></a>3、案例</h3><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><p>类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="责任链模式"></p><p>代码如下：</p><p><strong>LeaveRequest类</strong></p><pre><code class="java">/** * 请假条类 * * @author codejuzi */public class LeaveRequest &#123;    /**     * 请假人姓名     */    private final String name;    /**     * 请假天数     */    private final int num;    /**     * 请假内容     */    private final String content;    public LeaveRequest(String name, int num, String content) &#123;        this.name = name;        this.num = num;        this.content = content;    &#125;    public String getName() &#123;        return name;    &#125;    public int getNum() &#123;        return num;    &#125;    public String getContent() &#123;        return content;    &#125;&#125;</code></pre><p><strong>Handler抽象类</strong></p><pre><code class="java">/** * 抽象处理类 * * @author codejuzi */public abstract class Handler &#123;    protected static final int NUM_ONE = 1;    protected static final int NUM_THREE = 3;    protected static final int NUM_SEVEN = 7;    // 该领导处理的请假区间    private int numStart;    private int numEnd;    // 领导的上级    private Handler nextHandler;    // 设置请假天数范围，上不封顶    public Handler(int numStart) &#123;        this.numStart = numStart;    &#125;    // 设置请假天数范围    public Handler(int numStart, int numEnd) &#123;        this.numStart = numStart;        this.numEnd = numEnd;    &#125;    public void setNextHandler(Handler nextHandler) &#123;        this.nextHandler = nextHandler;    &#125;    /**     * 提交请假条     *     * @param leaveRequest     */    public final void submit(LeaveRequest leaveRequest) &#123;        if (0 == this.numStart) &#123;            return;        &#125;        // 如果请假天数达到了该领导者的处理要求        if (leaveRequest.getNum() &gt;= this.numStart) &#123;            // 如果还有上级，并且请假天数超过了当前领导的处理范围            if (null != this.nextHandler &amp;&amp; leaveRequest.getNum() &gt; this.numEnd) &#123;                this.nextHandler.submit(leaveRequest);            &#125; else &#123;                this.handleLeave(leaveRequest);                System.out.println(&quot;流程结束&quot;);            &#125;        &#125;    &#125;    /**     * 各级领导处理请假条的方式     *     * @param leaveRequest     */    protected abstract void handleLeave(LeaveRequest leaveRequest);&#125;</code></pre><p><strong>GroupLeader类</strong></p><pre><code class="java">/** * 具体处理者角色--小组长 * * @author codejuzi */public class GroupLeader extends Handler&#123;    public GroupLeader() &#123;        // 小组长处理1-3天的请求        super(Handler.NUM_ONE, Handler.NUM_THREE);    &#125;    @Override    protected void handleLeave(LeaveRequest leaveRequest) &#123;        System.out.println(leaveRequest.getName() + &quot;请假&quot; + leaveRequest.getNum() + &quot;天,&quot;                + leaveRequest.getContent() + &quot;。&quot;);        System.out.println(&quot;小组长审批：同意。&quot;);    &#125;&#125;</code></pre><p><strong>Manager类</strong></p><pre><code class="java">/** * 具体处理者角色--经理 * * @author codejuzi */public class Manager extends Handler&#123;    public Manager() &#123;        // 经理处理3-7天的请求        super(Handler.NUM_THREE, Handler.NUM_SEVEN);    &#125;    @Override    protected void handleLeave(LeaveRequest leaveRequest) &#123;        System.out.println(leaveRequest.getName() + &quot;请假&quot; + leaveRequest.getNum() + &quot;天,&quot;                + leaveRequest.getContent() + &quot;。&quot;);        System.out.println(&quot;经理审批：同意。&quot;);    &#125;&#125;</code></pre><p><strong>GeneralManager类</strong></p><pre><code class="java">/** * 具体处理者角色--总经理 * * @author codejuzi */public class GeneralManager extends Handler&#123;    public GeneralManager() &#123;        // 经理处理7天以上的请求        super(Handler.NUM_SEVEN);    &#125;    @Override    protected void handleLeave(LeaveRequest leaveRequest) &#123;        System.out.println(leaveRequest.getName() + &quot;请假&quot; + leaveRequest.getNum() + &quot;天,&quot;                 + leaveRequest.getContent() + &quot;。&quot;);        System.out.println(&quot;总经理审批：同意。&quot;);    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">public class HandlerTest &#123;    @Test    public void handleLeave() &#123;        LeaveRequest leaveRequest = new LeaveRequest(&quot;Tom&quot;, 8, &quot;身体不适&quot;);        GroupLeader groupLeader = new GroupLeader();        Manager manager = new Manager();        GeneralManager generalManager = new GeneralManager();        // 设置上级        groupLeader.setNextHandler(manager);        manager.setNextHandler(generalManager);        // 提交申请        groupLeader.submit(leaveRequest);    &#125;&#125;</code></pre><h3 id="4、优缺点-3"><a href="#4、优缺点-3" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度：该模式降低了请求发送者和接收者的耦合度。</p></li><li><p>增强了系统的可扩展性：可以根据需要增加新的请求处理类，满足开闭原则。</p></li><li><p>增强了给对象指派职责的灵活性：当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p></li><li><p>责任链简化了对象之间的连接：一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p></li><li><p>责任分担：每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理：由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><h3 id="5、源码解析"><a href="#5、源码解析" class="headerlink" title="5、源码解析"></a>5、源码解析</h3><p>在<code>javaWeb</code>应用开发中，<code>FilterChain</code>是职责链（过滤器）模式的典型应用，以下是<code>Filter</code>的模拟实现分析:</p><ul><li><p>模拟web请求<code>Request</code>以及web响应<code>Response</code></p><pre><code class="java">public interface Request&#123; &#125;public interface Response&#123; &#125;</code></pre></li><li><p>模拟web过滤器Filter</p><pre><code class="java"> public interface Filter &#123;     public void doFilter(Request req,Response res,FilterChain c); &#125;</code></pre></li><li><p>模拟实现具体过滤器  </p><pre><code class="java">public class FirstFilter implements Filter &#123;    @Override    public void doFilter(Request request, Response response, FilterChain chain) &#123;        System.out.println(&quot;过滤器1 前置处理&quot;);        // 先执行所有request再倒序执行所有response        chain.doFilter(request, response);        System.out.println(&quot;过滤器1 后置处理&quot;);    &#125;&#125;public class SecondFilter implements Filter &#123;    @Override    public void doFilter(Request request, Response response, FilterChain chain) &#123;        System.out.println(&quot;过滤器2 前置处理&quot;);        // 先执行所有request再倒序执行所有response        chain.doFilter(request, response);        System.out.println(&quot;过滤器2 后置处理&quot;);    &#125;&#125;</code></pre></li><li><p>模拟实现过滤器链FilterChain  </p><pre><code class="java">public class FilterChain &#123;    private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();    private int index = 0;    // 链式调用    public FilterChain addFilter(Filter filter) &#123;        this.filters.add(filter);        return this;    &#125;    public void doFilter(Request request, Response response) &#123;        if (index == filters.size()) &#123;            return;        &#125;        Filter filter = filters.get(index);        index++;        filter.doFilter(request, response, this);    &#125;&#125;</code></pre></li><li><p>测试类</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        Request  req = null;        Response res = null ;        FilterChain filterChain = new FilterChain();        filterChain.addFilter(new FirstFilter()).addFilter(new SecondFilter());        filterChain.doFilter(req,res);    &#125;&#125;</code></pre></li></ul><h2 id="3-5-状态模式"><a href="#3-5-状态模式" class="headerlink" title="3.5 状态模式"></a>3.5 状态模式</h2><h3 id="1、概述-4"><a href="#1、概述-4" class="headerlink" title="1、概述"></a>1、概述</h3><p>【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。</p><p>类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E5%89%8D.png" alt="状态模式前"></p><p>代码实现：</p><p><strong>ILift类</strong></p><pre><code class="java">public interface ILift &#123;    //电梯的4个状态    //开门状态    public final static int OPENING_STATE = 1;    //关门状态    public final static int CLOSING_STATE = 2;    //运行状态    public final static int RUNNING_STATE = 3;    //停止状态    public final static int STOPPING_STATE = 4;    //设置电梯的状态    public void setState(int state);    //电梯的动作    public void open();    public void close();    public void run();    public void stop();&#125;</code></pre><p><strong>Left类</strong></p><pre><code class="java">public class Lift implements ILift &#123;    private int state;    @Override    public void setState(int state) &#123;        this.state = state;    &#125;    //执行关门动作    @Override    public void close() &#123;        switch (this.state) &#123;            case OPENING_STATE:                System.out.println(&quot;电梯关门了。。。&quot;);//只有开门状态可以关闭电梯门，可以对应电梯状态表来看                this.setState(CLOSING_STATE);//关门之后电梯就是关闭状态了                break;            case CLOSING_STATE:                //do nothing //已经是关门状态，不能关门                break;            case RUNNING_STATE:                //do nothing //运行时电梯门是关着的，不能关门                break;            case STOPPING_STATE:                //do nothing //停止时电梯也是关着的，不能关门                break;        &#125;    &#125;    //执行开门动作    @Override    public void open() &#123;        switch (this.state) &#123;            case OPENING_STATE://门已经开了，不能再开门了                //do nothing                break;            case CLOSING_STATE://关门状态，门打开:                System.out.println(&quot;电梯门打开了。。。&quot;);                this.setState(OPENING_STATE);                break;            case RUNNING_STATE:                //do nothing 运行时电梯不能开门                break;            case STOPPING_STATE:                System.out.println(&quot;电梯门开了。。。&quot;);//电梯停了，可以开门了                this.setState(OPENING_STATE);                break;        &#125;    &#125;    //执行运行动作    @Override    public void run() &#123;        switch (this.state) &#123;            case OPENING_STATE://电梯不能开着门就走                //do nothing                break;            case CLOSING_STATE://门关了，可以运行了                System.out.println(&quot;电梯开始运行了。。。&quot;);                this.setState(RUNNING_STATE);//现在是运行状态                break;            case RUNNING_STATE:                //do nothing 已经是运行状态了                break;            case STOPPING_STATE:                System.out.println(&quot;电梯开始运行了。。。&quot;);                this.setState(RUNNING_STATE);                break;        &#125;    &#125;    //执行停止动作    @Override    public void stop() &#123;        switch (this.state) &#123;            case OPENING_STATE: //开门的电梯已经是是停止的了(正常情况下)                //do nothing                break;            case CLOSING_STATE://关门时才可以停止                System.out.println(&quot;电梯停止了。。。&quot;);                this.setState(STOPPING_STATE);                break;            case RUNNING_STATE://运行时当然可以停止了                System.out.println(&quot;电梯停止了。。。&quot;);                this.setState(STOPPING_STATE);                break;            case STOPPING_STATE:                //do nothing                break;        &#125;    &#125;&#125;</code></pre><p><strong>Client类</strong></p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        Lift lift = new Lift();        lift.setState(ILift.STOPPING_STATE);//电梯是停止的        lift.open();//开门        lift.close();//关门        lift.run();//运行        lift.stop();//停止    &#125;&#125;</code></pre><p>问题分析：</p><ul><li>使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。</li><li>扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑</li></ul><p><strong>定义：</strong></p><p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><h3 id="2、结构-4"><a href="#2、结构-4" class="headerlink" title="2、结构"></a>2、结构</h3><p>状态模式包含以下主要角色。</p><ul><li>环境（<code>Context</code>）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象状态（<code>State</code>）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（<code>Concrete  State</code>）角色：实现抽象状态所对应的行为。</li></ul><h3 id="3、案例-4"><a href="#3、案例-4" class="headerlink" title="3、案例"></a>3、案例</h3><p>对上述电梯的案例使用状态模式进行改进，类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt="状态模式"></p><p>代码实现：</p><p><strong>LIftState类</strong></p><pre><code class="java">/** * 抽象状态类 * * @author codejuzi */public abstract class LiftState &#123;    protected Context context;    public void setContext(Context context) &#123;        this.context = context;    &#125;    /**     * 电梯开门动作     */    public abstract void open();    /**     * 电梯关门动作     */    public abstract void close();    /**     * 电梯运行动作     */    public abstract void run();    /**     * 电梯停止动作     */    public abstract void stop();&#125;</code></pre><p><strong>OpenningState类</strong></p><pre><code class="java">/** * 开启状态 * * @author codejuzi */public class OpenningState extends LiftState&#123;    @Override    public void open() &#123;        System.out.println(&quot;电梯门开启……&quot;);    &#125;    @Override    public void close() &#123;        // 状态修改        super.context.setLiftState(Context.CLOSING_STATE);        // 动作委派给ClosingState来执行,也就是委托给了ClosingState子类执行这个动作        super.context.close();    &#125;    @Override    public void run() &#123;        // do nothing    &#125;    @Override    public void stop() &#123;        // do nothing    &#125;&#125;</code></pre><p><strong>ClosingState类</strong></p><pre><code class="java">/** * 关闭状态 * * @author codejuzi */public class ClosingState extends LiftState&#123;    @Override    public void open() &#123;        super.context.setLiftState(Context.OPENNING_STATE);        super.context.open();    &#125;    @Override    public void close() &#123;        System.out.println(&quot;电梯关闭中……&quot;);    &#125;    @Override    public void run() &#123;        super.context.setLiftState(Context.RUNNING_STATE);        super.context.run();    &#125;    @Override    public void stop() &#123;        super.context.setLiftState(Context.STOPPING_STATE);        super.context.stop();    &#125;&#125;</code></pre><p><strong>StoppingState类</strong></p><pre><code class="java">/** * 停止状态 * * @author codejuzi */public class StoppingState extends LiftState&#123;    @Override    public void open() &#123;        super.context.setLiftState(Context.OPENNING_STATE);        super.context.open();    &#125;    @Override    public void close() &#123;        super.context.setLiftState(Context.CLOSING_STATE);        super.context.close();    &#125;    @Override    public void run() &#123;        super.context.setLiftState(Context.RUNNING_STATE);        super.context.run();    &#125;    @Override    public void stop() &#123;        System.out.println(&quot;电梯停止中……&quot;);    &#125;&#125;</code></pre><p><strong>RunningState类</strong></p><pre><code class="java">/** * 运行状态 * * @author codejuzi */public class RunningState extends LiftState&#123;    @Override    public void open() &#123;    &#125;    @Override    public void close() &#123;    &#125;    @Override    public void run() &#123;        System.out.println(&quot;电梯运行中……&quot;);    &#125;    @Override    public void stop() &#123;        super.context.setLiftState(Context.STOPPING_STATE);        super.context.stop();    &#125;&#125;</code></pre><p><strong>Context类</strong></p><pre><code class="java">/** * 环境角色 * * @author codejuzi */public class Context &#123;    public static final OpenningState OPENNING_STATE = new OpenningState();    public static final ClosingState CLOSING_STATE = new ClosingState();    public static final RunningState RUNNING_STATE = new RunningState();    public static final StoppingState STOPPING_STATE = new StoppingState();    private LiftState liftState;    public LiftState getLiftState() &#123;        return this.liftState;    &#125;    public void setLiftState(LiftState liftState) &#123;        // 当前环境状态改变        this.liftState = liftState;        // 把当前环境状态通知到各个实现类中        this.liftState.setContext(this);    &#125;    public void open() &#123;        this.liftState.open();    &#125;    public void close() &#123;        this.liftState.close();    &#125;    public void run() &#123;        this.liftState.run();    &#125;    public void stop() &#123;        this.liftState.stop();    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">public class ContextTest &#123;    @Test    public void test() &#123;        Context context = new Context();        context.setLiftState(Context.CLOSING_STATE);        context.open();        context.close();        context.run();        context.stop();    &#125;&#125;</code></pre><h3 id="4、优缺点-4"><a href="#4、优缺点-4" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点：</strong></p><ul><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li></ul><p><strong>缺点：</strong></p><ul><li>状态模式的使用必然会增加系统类和对象的个数。 </li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对”开闭原则”的支持并不太好。</li></ul><h3 id="5、使用场景-2"><a href="#5、使用场景-2" class="headerlink" title="5、使用场景"></a>5、使用场景</h3><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><h2 id="3-6-观察者模式"><a href="#3-6-观察者模式" class="headerlink" title="3.6 观察者模式"></a>3.6 观察者模式</h2><h3 id="1、概述-5"><a href="#1、概述-5" class="headerlink" title="1、概述"></a>1、概述</h3><p><strong>定义：</strong></p><p>又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><h3 id="2、结构-5"><a href="#2、结构-5" class="headerlink" title="2、结构"></a>2、结构</h3><p>在观察者模式中有如下角色：</p><ul><li><code>Subject</code>：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li><code>ConcreteSubject</code>：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li><code>Observer</code>：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li><code>ConcrereObserver</code>：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><h3 id="3、案例-5"><a href="#3、案例-5" class="headerlink" title="3、案例"></a>3、案例</h3><p>【例】微信公众号</p><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p><p>类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"></p><p>代码实现：</p><p><strong>Observer接口</strong></p><pre><code class="java">/** * 抽象观察者类 * * @author codejuzi */public interface Observer &#123;    /**     * 更新     *     * @param message     */    void update(String message);&#125;</code></pre><p><strong>WeCahtUser类</strong></p><pre><code class="java">/** * 具体观察者类 * * @author codejuzi */public class WeChatUser implements Observer&#123;    private final String name;    public WeChatUser(String name) &#123;        this.name = name;    &#125;    @Override    public void update(String message) &#123;        System.out.println(name + &quot;-&quot; + message);    &#125;&#125;</code></pre><p><strong>Subject接口</strong></p><pre><code class="java">/** * 抽象被观察者 * * @author codejuzi */public interface Subject &#123;    /**     * 添加订阅者     *     * @param observer     */    void attachObserver(Observer observer);    /**     * 删除订阅者     *     * @param observer     */    void detachObserver(Observer observer);    /**     * 通知订阅者更新     *     * @param message     */    void notifyObserver(String message);&#125;</code></pre><p><strong>SubscriptionSubject类</strong></p><pre><code class="java">/** * 具体被观察者 * * @author codejuzi */public class SubscriptionSubject implements Subject&#123;    /**     * 保存订阅公众号的微信用户     */    private final List&lt;Observer&gt; weChatUserList = new ArrayList&lt;&gt;();    @Override    public void attachObserver(Observer observer) &#123;        weChatUserList.add(observer);    &#125;    @Override    public void detachObserver(Observer observer) &#123;        weChatUserList.remove(observer);    &#125;    @Override    public void notifyObserver(String message) &#123;        for (Observer observer : weChatUserList) &#123;            observer.update(message);        &#125;    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">public class SubscriptionSubjectTest &#123;    @Test    public void notifyObserver() &#123;        SubscriptionSubject mSubscriptionSubject = new SubscriptionSubject();        //创建微信用户        WeChatUser user1 = new WeChatUser(&quot;孙悟空&quot;);        WeChatUser user2 = new WeChatUser(&quot;猪悟能&quot;);        WeChatUser user3 = new WeChatUser(&quot;沙悟净&quot;);        //订阅公众号        mSubscriptionSubject.attachObserver(user1);        mSubscriptionSubject.attachObserver(user2);        mSubscriptionSubject.attachObserver(user3);        //公众号更新发出消息给订阅的微信用户        mSubscriptionSubject.notifyObserver(&quot;CodeJuzi的博客https://dingxinliang88.github.io更新文章啦&quot;);    &#125;&#125;</code></pre><h3 id="4、优缺点-5"><a href="#4、优缺点-5" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点：</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p><strong>缺点：</strong></p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><h3 id="5、使用场景-3"><a href="#5、使用场景-3" class="headerlink" title="5、使用场景"></a>5、使用场景</h3><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li></ul><h3 id="6、JDK中提供的实现"><a href="#6、JDK中提供的实现" class="headerlink" title="6、JDK中提供的实现"></a>6、JDK中提供的实现</h3><p>在 Java 中，通过 <code>java.util.Observable</code> 类和 <code>java.util.Observer</code> 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p><p><strong>Observable类</strong></p><p><code>Observable </code>类是抽象目标类（被观察者），它有一个 <code>Vector </code>集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p><ul><li><code>void addObserver(Observer o)</code> 方法：用于将新的观察者对象添加到集合中。</li><li><code>void notifyObservers(Object arg)</code> 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</li><li><code>void setChange() </code>方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</li></ul><p><strong>Observer接口</strong></p><p><code>Observer </code>接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用<code>update()</code>方法，进行相应的工作</p><p>【例】警察抓小偷</p><p>警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：</p><p>小偷是一个被观察者，所以需要继承Observable类</p><pre><code class="java">public class Thief extends Observable &#123;    private String name;    public Thief(String name) &#123;        this.name = name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void steal() &#123;        System.out.println(&quot;小偷：我偷东西了，有没有人来抓我！！！&quot;);        super.setChanged(); //changed  = true        super.notifyObservers();    &#125;&#125;</code></pre><p>警察是一个观察者，所以需要让其实现Observer接口</p><pre><code class="java">public class Policemen implements Observer &#123;    private String name;    public Policemen(String name) &#123;        this.name = name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    @Override    public void update(Observable o, Object arg) &#123;        System.out.println(&quot;警察：&quot; + ((Thief) o).getName() + &quot;，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！&quot;);    &#125;&#125;</code></pre><p>客户端代码</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        //创建小偷对象        Thief t = new Thief(&quot;隔壁老王&quot;);        //创建警察对象        Policemen p = new Policemen(&quot;小李&quot;);        //让警察盯着小偷        t.addObserver(p);        //小偷偷东西        t.steal();    &#125;&#125;</code></pre><h2 id="3-7-中介者模式"><a href="#3-7-中介者模式" class="headerlink" title="3.7 中介者模式"></a>3.7 中介者模式</h2><h3 id="1、概述-6"><a href="#1、概述-6" class="headerlink" title="1、概述"></a>1、概述</h3><p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p><p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。<strong>一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为</strong>。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200214110924010.png" alt="image-20200214110924010"></p><p><strong>定义：</strong></p><p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p><h3 id="2、结构-6"><a href="#2、结构-6" class="headerlink" title="2、结构"></a>2、结构</h3><p>中介者模式包含以下主要角色：</p><ul><li><p>抽象中介者（<code>Mediator</code>）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p></li><li><p>具体中介者（<code>Concrete Mediator</code>）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p></li><li><p>抽象同事类（<code>Colleague</code>）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p></li><li><p>具体同事类（<code>Concrete Colleague</code>）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p></li></ul><h3 id="3、案例-6"><a href="#3、案例-6" class="headerlink" title="3、案例"></a>3、案例</h3><p>【例】租房</p><p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p><p>类图如下</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="中介者模式"></p><p>代码实现</p><p><strong>Mediator抽象类</strong></p><pre><code class="java">/** * 抽象中介者角色 * * @author codejuzi */public abstract class Mediator &#123;    /**     * 联系方法     *     * @param person     * @param message     */    public abstract void contact(Person person, String message);&#125;</code></pre><p><strong>MediatorStructure类</strong></p><pre><code class="java">/** * 具体中介类 -- 中介组织 * * @author codejuzi */@Datapublic class MediatorStructure extends Mediator&#123;    private HouseOnwer houseOnwer;    private Tenant tenant;    @Override    public void contact(Person person, String message) &#123;        if(Objects.equals(person, houseOnwer)) &#123;            tenant.getMessage(message);        &#125; else if(Objects.equals(person, tenant)) &#123;            houseOnwer.getMessage(message);        &#125;    &#125;&#125;</code></pre><p><strong>Person抽象类</strong></p><pre><code class="java">/** * 抽象同事类 * * @author codejuzi */public abstract class Person &#123;    protected String name;    protected Mediator mediator;    public Person(String name, Mediator mediator) &#123;        this.name = name;        this.mediator = mediator;    &#125;&#125;</code></pre><p><strong>HouseOwner类</strong></p><pre><code class="java">/** * 具体同事类 -- 房东 * * @author codejuzi */public class HouseOnwer extends Person&#123;    public HouseOnwer(String name, Mediator mediator) &#123;        super(name, mediator);    &#125;    public void contact(String message) &#123;        mediator.contact(this, message);    &#125;    public void getMessage(String message)&#123;        System.out.println(&quot;房主&quot; + name +&quot;获取到的信息：&quot; + message);    &#125;&#125;</code></pre><p><strong>Tenant类</strong></p><pre><code class="java">/** * 具体同事类 -- 租客 * * @author codejuzi */public class Tenant extends Person&#123;    public Tenant(String name, Mediator mediator) &#123;        super(name, mediator);    &#125;    public void contact(String message) &#123;        mediator.contact(this, message);    &#125;    public void getMessage(String message)&#123;        System.out.println(&quot;租客&quot; + name +&quot;获取到的信息：&quot; + message);    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">/** * @author codejuzi */public class MediatorTest &#123;    @Test    public void contact() &#123;        MediatorStructure mediatorStructure = new MediatorStructure();        HouseOnwer houseOnwer = new HouseOnwer(&quot;Tom&quot;, mediatorStructure);        Tenant tenant = new Tenant(&quot;Jerry&quot;, mediatorStructure);        mediatorStructure.setHouseOnwer(houseOnwer);        mediatorStructure.setTenant(tenant);        tenant.contact(&quot;我要租房&quot;);        houseOnwer.contact(&quot;啊~不租！！&quot;);    &#125;&#125;</code></pre><h3 id="4、优缺点-6"><a href="#4、优缺点-6" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点：</strong></p><ul><li><p>松散耦合：中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p></li><li><p>集中控制交互：多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p></li><li><p>一对多关联转变为一对一的关联：没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</p></li></ul><p><strong>缺点：</strong></p><p>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p><h3 id="5、使用场景-4"><a href="#5、使用场景-4" class="headerlink" title="5、使用场景"></a>5、使用场景</h3><ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li></ul><h2 id="3-8-迭代器模式"><a href="#3-8-迭代器模式" class="headerlink" title="3.8 迭代器模式"></a>3.8 迭代器模式</h2><h3 id="1、概述-7"><a href="#1、概述-7" class="headerlink" title="1、概述"></a>1、概述</h3><p><strong>定义：</strong></p><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 </p><h3 id="2、结构-7"><a href="#2、结构-7" class="headerlink" title="2、结构"></a>2、结构</h3><p>迭代器模式主要包含以下角色：</p><ul><li><p>抽象聚合（<code>Aggregate</code>）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</p></li><li><p>具体聚合（<code>Concrete Aggregate</code>）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p></li><li><p>抽象迭代器（<code>Iterator</code>）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</p></li><li><p>具体迭代器（<code>Concrete lterator</code>）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p></li></ul><h3 id="3、案例-7"><a href="#3、案例-7" class="headerlink" title="3、案例"></a>3、案例</h3><p>【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="迭代器模式"></p><p>代码实现</p><p><strong>StudentAggregate接口</strong></p><pre><code class="java">/** * 抽象容器类 * * @author codejuzi */public interface StudentAggregate &#123;    void addStudent(Student student);    void removeStudent(Student student);    StudentIterator getStudentIterator();&#125;</code></pre><p><strong>StudentAggregateImpl类</strong></p><pre><code class="java">/** * 具体容器类 * * @author codejuzi */public class StudentAggregateImpl implements StudentAggregate &#123;    private final List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();    @Override    public void addStudent(Student student) &#123;        studentList.add(student);    &#125;    @Override    public void removeStudent(Student student) &#123;        studentList.remove(student);    &#125;    @Override    public StudentIterator getStudentIterator() &#123;        return new StudentIteratorImpl(studentList);    &#125;&#125;</code></pre><p><strong>StudentIterator接口</strong></p><pre><code class="java">/** * 抽象迭代器 * * @author codejuzi */public interface StudentIterator &#123;    boolean hasNext();    Student next();&#125;</code></pre><p><strong>StudentIteratorImpl类</strong></p><pre><code class="java">/** * 具体迭代器 * * @author codejuzi */public class StudentIteratorImpl implements StudentIterator &#123;    private final List&lt;Student&gt; studentList;    private int position;    public StudentIteratorImpl(List&lt;Student&gt; studentList) &#123;        this.studentList = studentList;        this.position = 0;    &#125;    @Override    public boolean hasNext() &#123;        return position &lt; studentList.size();    &#125;    @Override    public Student next() &#123;        return studentList.get(position++);    &#125;&#125;</code></pre><p><strong>Student类</strong></p><pre><code class="java">/** * 学生类 * @author codejuzi */@Data@AllArgsConstructorpublic class Student &#123;    private String name;    private String number;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">/** * @author codejuzi */public class StudentAggregateTest &#123;    @Test    public void test() &#123;        //创建聚合对象        StudentAggregateImpl aggregate = new StudentAggregateImpl();        //添加元素        aggregate.addStudent(new Student(&quot;张三&quot;,&quot;001&quot;));        aggregate.addStudent(new Student(&quot;李四&quot;,&quot;002&quot;));        aggregate.addStudent(new Student(&quot;王五&quot;,&quot;003&quot;));        aggregate.addStudent(new Student(&quot;赵六&quot;,&quot;004&quot;));        //遍历聚合对象        //1,获取迭代器对象        StudentIterator iterator = aggregate.getStudentIterator();        //2,遍历        while(iterator.hasNext()) &#123;            //3,获取元素            Student student = iterator.next();            System.out.println(student.toString());        &#125;    &#125;&#125;</code></pre><h3 id="4、优缺点-7"><a href="#4、优缺点-7" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点：</strong></p><ul><li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。</li></ul><p><strong>缺点：</strong></p><p>增加了类的个数，这在一定程度上增加了系统的复杂性。</p><h3 id="5、使用场景-5"><a href="#5、使用场景-5" class="headerlink" title="5、使用场景"></a>5、使用场景</h3><ul><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li></ul><h3 id="6-JDK源码解析"><a href="#6-JDK源码解析" class="headerlink" title="6 JDK源码解析"></a>6 JDK源码解析</h3><p>迭代器模式在Java的很多集合类中被广泛应用</p><pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; iterator = list.iterator(); //list.iterator()方法返回的肯定是Iterator接口的子实现类对象while (iterator.hasNext()) &#123;    System.out.println(iterator.next());&#125;</code></pre><p>单列集合都使用到了迭代器</p><ul><li><code>List</code>：抽象聚合类</li><li><code>ArrayList</code>：具体的聚合类</li><li><code>Iterator</code>：抽象迭代器</li><li><code>list.iterator()</code>：返回的是实现了 <code>Iterator</code> 接口的具体迭代器对象</li></ul><p><code>ArrayList</code>的代码实现</p><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;        public Iterator&lt;E&gt; iterator() &#123;        return new Itr();    &#125;        private class Itr implements Iterator&lt;E&gt; &#123;        int cursor;       // 下一个要返回元素的索引        int lastRet = -1; // 上一个返回元素的索引        int expectedModCount = modCount;        Itr() &#123;&#125;                //判断是否还有元素        public boolean hasNext() &#123;            return cursor != size;        &#125;        //获取下一个元素        public E next() &#123;            checkForComodification();            int i = cursor;            if (i &gt;= size)                throw new NoSuchElementException();            Object[] elementData = ArrayList.this.elementData;            if (i &gt;= elementData.length)                throw new ConcurrentModificationException();            cursor = i + 1;            return (E) elementData[lastRet = i];        &#125;        ...&#125;</code></pre><p>在 <code>iterator</code> 方法中返回了一个实例化的 <code>Iterator</code> 对象。<code>Itr</code>是一个内部类，它实现了 <code>Iterator</code> 接口并重写了其中的抽象方法。</p><blockquote><p>注意： </p><p>​当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现<code>java.util.Iterable</code>并实现其中的<code>iterator()</code>方法使其返回一个 <code>java.util.Iterator</code> 的实现类就可以了。</p></blockquote><h2 id="3-9-访问者模式"><a href="#3-9-访问者模式" class="headerlink" title="3.9 访问者模式"></a>3.9 访问者模式</h2><h3 id="1、概述-8"><a href="#1、概述-8" class="headerlink" title="1、概述"></a>1、概述</h3><p><strong>定义：</strong></p><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p><h3 id="2、结构-8"><a href="#2、结构-8" class="headerlink" title="2、结构"></a>2、结构</h3><p>访问者模式包含以下主要角色:</p><ul><li>抽象访问者（<code>Visitor</code>）角色：定义了对每一个元素<code>（Element）</code>访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。</li><li>具体访问者（<code>Concrete Visitor</code>）角色：给出对每一个元素类访问时所产生的具体行为。</li><li>抽象元素（<code>Element</code>）角色：定义了一个接受访问者的方法（<code>accept</code>），其意义是指，每一个元素都要可以被访问者访问。</li><li>具体元素（<code>Concrete Element</code>）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li><li>对象结构（<code>Object Structure</code>）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（<code>Element</code>），并且可以迭代这些元素，供访问者访问。</li></ul><h3 id="3、案例-8"><a href="#3、案例-8" class="headerlink" title="3、案例"></a>3、案例</h3><p>【例】给宠物喂食</p><p>现在养宠物的人特别多，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p><ul><li>访问者角色：给宠物喂食的人</li><li>具体访问者角色：主人、其他人</li><li>抽象元素角色：动物抽象类</li><li>具体元素角色：宠物狗、宠物猫</li><li>结构对象角色：主人家</li></ul><p>类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="访问者模式"></p><p>代码实现</p><p><strong>Person接口</strong></p><pre><code class="java">/** * 抽象访问者 * * @author codejuzi */public interface Person &#123;    void feed(Cat cat);    void feed(Dog dog);&#125;</code></pre><p><strong>Owner类</strong></p><pre><code class="java">/** * 具体访问者类 * * @author codejuzi */public class Owner implements Person &#123;    @Override    public void feed(Cat cat) &#123;        System.out.println(&quot;主人喂食猫&quot;);    &#125;    @Override    public void feed(Dog dog) &#123;        System.out.println(&quot;主人喂食狗&quot;);    &#125;&#125;</code></pre><p><strong>Someone类</strong></p><pre><code class="java">/** * 具体访问者类 * * @author codejuzi */public class Someone implements Person &#123;    @Override    public void feed(Cat cat) &#123;        System.out.println(&quot;其他人喂食猫&quot;);    &#125;    @Override    public void feed(Dog dog) &#123;        System.out.println(&quot;其他人喂食狗&quot;);    &#125;&#125;</code></pre><p><strong>Animal接口</strong></p><pre><code class="java">/** * 抽象元素角色 * * @author codejuzi */public interface Animal &#123;    void accept(Person person);&#125;</code></pre><p><strong>Dog类</strong></p><pre><code class="java">/** * 具体元素类 * * @author codejuzi */public class Dog implements Animal &#123;    @Override    public void accept(Person person) &#123;        person.feed(this);        System.out.println(&quot;好好吃，汪汪汪！！！&quot;);    &#125;&#125;</code></pre><p><strong>Cat类</strong></p><pre><code class="java">/** * 具体元素类 * * @author codejuzi */public class Cat implements Animal &#123;    @Override    public void accept(Person person) &#123;        person.feed(this);        System.out.println(&quot;好好吃，喵喵喵！！！&quot;);    &#125;&#125;</code></pre><p><strong>Home类</strong></p><pre><code class="java">/** * 对象结构类 * * @author codejuzi */public class Home &#123;    private final List&lt;Animal&gt; animalList;    public Home() &#123;        this.animalList = new ArrayList&lt;&gt;();    &#125;    public void action(Person person) &#123;        for (Animal animal : animalList) &#123;            animal.accept(person);        &#125;    &#125;    /**     * 添加宠物     *     * @param animal     */    public void add(Animal animal) &#123;        animalList.add(animal);    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">/** * @author codejuzi */public class HomeTest &#123;    @Test    public void test() &#123;        Home home = new Home();        home.add(new Dog());        home.add(new Cat());        Owner owner = new Owner();        home.action(owner);        Someone someone = new Someone();        home.action(someone);    &#125;&#125;</code></pre><h3 id="4、优缺点-8"><a href="#4、优缺点-8" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点</strong></p><ul><li><p>扩展性好：在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p></li><li><p>复用性好：通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</p></li><li><p>分离无关行为：通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>对象结构变化很困难：在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</p></li><li><p>违反了依赖倒置原则：访问者模式依赖了具体类，而没有依赖抽象类。</p></li></ul><h3 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5  使用场景"></a>5  使用场景</h3><ul><li><p>对象结构相对稳定，但其操作算法经常变化的程序。</p></li><li><p>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</p></li></ul><h3 id="6、扩展"><a href="#6、扩展" class="headerlink" title="6、扩展"></a>6、扩展</h3><p>访问者模式用到了<strong>双分派</strong>的技术</p><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 <code>Map map = new HashMap()</code> ，map变量的静态类型是 <code>Map</code> ，实际类型是 <code>HashMap</code> 。根据对象的类型而对方法进行的选择，就是分派(<code>Dispatch</code>)，分派(Dispatch)又分为两种，即静态分派和动态分派。</p><p><strong>静态分派(Static Dispatch)</strong> 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p><p><strong>动态分派(Dynamic Dispatch)</strong> 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。</p><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>通过方法的重写支持动态分派。</p><pre><code class="java">public class Animal &#123;    public void execute() &#123;        System.out.println(&quot;Animal&quot;);    &#125;&#125;public class Dog extends Animal &#123;    @Override    public void execute() &#123;        System.out.println(&quot;dog&quot;);    &#125;&#125;public class Cat extends Animal &#123;     @Override    public void execute() &#123;        System.out.println(&quot;cat&quot;);    &#125;&#125;public class Client &#123;       public static void main(String[] args) &#123;        Animal a = new Dog();        a.execute();                Animal a1 = new Cat();        a1.execute();    &#125;&#125;</code></pre><p>上述代码其实就是多态！运行执行的是子类中的方法。</p><p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>通过方法重载支持静态分派。</p><pre><code class="java">public class Animal &#123;&#125;public class Dog extends Animal &#123;&#125;public class Cat extends Animal &#123;&#125;public class Execute &#123;    public void execute(Animal a) &#123;        System.out.println(&quot;Animal&quot;);    &#125;    public void execute(Dog d) &#123;        System.out.println(&quot;dog&quot;);    &#125;    public void execute(Cat c) &#123;        System.out.println(&quot;cat&quot;);    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        Animal a = new Animal();        Animal a1 = new Dog();        Animal a2 = new Cat();        Execute exe = new Execute();        exe.execute(a);        exe.execute(a1);        exe.execute(a2);    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200214215446638.png" alt="image-20200214215446638"></p><p><strong>重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</strong></p><h4 id="双分派"><a href="#双分派" class="headerlink" title="双分派"></a>双分派</h4><p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。</p><pre><code class="java">public class Animal &#123;    public void accept(Execute exe) &#123;        exe.execute(this);    &#125;&#125;public class Dog extends Animal &#123;    public void accept(Execute exe) &#123;        exe.execute(this);    &#125;&#125;public class Cat extends Animal &#123;    public void accept(Execute exe) &#123;        exe.execute(this);    &#125;&#125;public class Execute &#123;    public void execute(Animal a) &#123;        System.out.println(&quot;animal&quot;);    &#125;    public void execute(Dog d) &#123;        System.out.println(&quot;dog&quot;);    &#125;    public void execute(Cat c) &#123;        System.out.println(&quot;cat&quot;);    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        Animal a = new Animal();        Animal d = new Dog();        Animal c = new Cat();        Execute exe = new Execute();        a.accept(exe);        d.accept(exe);        c.accept(exe);    &#125;&#125;</code></pre><p>在上面代码中，客户端将<code>Execute</code>对象做为参数传递给<code>Animal</code>类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是<strong>动态分派</strong>，也就是执行实际类型中的方法，同时也<code>将自己this作为参数传递进去，这里就完成了第二次分派</code>，这里的<code>Execute</code>类中有多个重载的方法，而传递进行的是<code>this</code>，就是具体的实际类型的对象。</p><p>双分派实现了方法的<strong>动态绑定</strong></p><p>运行结果如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200426233931693.png" alt="image-20200426233931693"></p><p><strong>双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。</strong></p><h2 id="3-10-备忘录模式"><a href="#3-10-备忘录模式" class="headerlink" title="3.10 备忘录模式"></a>3.10 备忘录模式</h2><h3 id="1、概述-9"><a href="#1、概述-9" class="headerlink" title="1、概述"></a>1、概述</h3><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p><p><strong>定义：</strong></p><p>又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p><h3 id="2、结构-9"><a href="#2、结构-9" class="headerlink" title="2、结构"></a>2、结构</h3><p>备忘录模式的主要角色如下：</p><ul><li>发起人（<code>Originator</code>）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li><li>备忘录（<code>Memento</code>）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li><li>管理者（<code>Caretaker</code>）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><blockquote><p>备忘录有两个等效的接口：</p><ul><li><strong>窄接口</strong>：管理者(<code>Caretaker</code>)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(<code>narror Interface</code>)，这个窄接口只允许他把备忘录对象传给其他的对象。</li><li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口<code>(wide Interface</code>)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li></ul></blockquote><h3 id="3、案例-9"><a href="#3、案例-9" class="headerlink" title="3、案例"></a>3、案例</h3><p>【例】游戏挑战BOSS</p><p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p><p>要实现上述案例，有两种方式：</p><ul><li>“白箱”备忘录模式</li><li>“黑箱”备忘录模式</li></ul><h4 id="1）“白箱”备忘录模式"><a href="#1）“白箱”备忘录模式" class="headerlink" title="1）“白箱”备忘录模式"></a>1）“白箱”备忘录模式</h4><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E7%99%BD%E7%AE%B1%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png" alt="白箱备忘录模式"></p><p>代码实现</p><p><strong>RoleStateMemento类</strong></p><pre><code class="java">/** * 角色状态备忘录 * * @author codejuzi */@Data@AllArgsConstructorpublic class RoleStateMemento &#123;    private int vit;    private int atk;    private int def;&#125;</code></pre><p><strong>GameRole类</strong></p><pre><code class="java">/** * 游戏角色类 * * @author codejuzi */@Datapublic class GameRole &#123;    /**     * 生命力     */    private int vit;    /**     * 攻击力     */    private int atk;    /**     * 防御力     */    private int def;    // 初始化状态    public void initState() &#123;        this.vit = 100;        this.atk = 100;        this.def = 100;    &#125;    //战斗    public void fight() &#123;        this.vit = 0;        this.atk = 0;        this.def = 0;    &#125;    //保存角色状态    public RoleStateMemento saveState() &#123;        return new RoleStateMemento(vit, atk, def);    &#125;    //回复角色状态    public void recoverState(RoleStateMemento roleStateMemento) &#123;        this.vit = roleStateMemento.getVit();        this.atk = roleStateMemento.getAtk();        this.def = roleStateMemento.getDef();    &#125;    public void stateDisplay() &#123;        System.out.println(&quot;角色生命力：&quot; + vit);        System.out.println(&quot;角色攻击力：&quot; + atk);        System.out.println(&quot;角色防御力：&quot; + def);    &#125;&#125;</code></pre><p><strong>RoleStateCaretaker类</strong></p><pre><code class="java">/** * 角色状态管理者角色 * * @author codejuzi */@Datapublic class RoleStateCaretaker &#123;    private RoleStateMemento roleStateMemento;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">/** * @author codejuzi */public class RoleStateCaretakerTest &#123;    @Test    public void setRoleStateMemento() &#123;        System.out.println(&quot;------------大战Boss前------------&quot;);        //大战Boss前        GameRole gameRole = new GameRole();        gameRole.initState();        gameRole.stateDisplay();        //保存进度        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());        System.out.println(&quot;------------大战Boss后------------&quot;);        //大战Boss时，损耗严重        gameRole.fight();        gameRole.stateDisplay();        System.out.println(&quot;------------恢复之前状态------------&quot;);        //恢复之前状态        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());        gameRole.stateDisplay();    &#125;&#125;</code></pre><blockquote><p>分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。</p></blockquote><h4 id="2）“黑箱”备忘录模式"><a href="#2）“黑箱”备忘录模式" class="headerlink" title="2）“黑箱”备忘录模式"></a>2）“黑箱”备忘录模式</h4><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将<strong>备忘录类</strong>设计成<strong>发起人</strong>类的内部成员类。</p><p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code> 的内部类，从而将 <code>RoleStateMemento</code> 对象封装在 <code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code> 给 <code>RoleStateCaretaker</code> 及其他对象使用。这样 <code>GameRole</code> 类看到的是 <code>RoleStateMemento</code> 所有的接口，而<code>RoleStateCaretaker</code>  及其他对象看到的仅仅是标识接口 <code>Memento</code> 所暴露出来的接口，从而维护了封装型。类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E9%BB%91%E7%AE%B1%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png" alt="黑箱备忘录模式"></p><p>代码实现</p><p><strong>GameRole类</strong></p><pre><code class="java">/** * 游戏角色类 * * @author codejuzi */@Datapublic class GameRole &#123;    /**     * 生命力     */    private int vit;    /**     * 攻击力     */    private int atk;    /**     * 防御力     */    private int def;    // 初始化状态    public void initState() &#123;        this.vit = 100;        this.atk = 100;        this.def = 100;    &#125;    //战斗    public void fight() &#123;        this.vit = 0;        this.atk = 0;        this.def = 0;    &#125;    //保存角色状态    public Memento saveState() &#123;        return new RoleStateMemento(vit, atk, def);    &#125;    //回复角色状态    public void recoverState(Memento memento) &#123;        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;        this.vit = roleStateMemento.getVit();        this.atk = roleStateMemento.getAtk();        this.def = roleStateMemento.getDef();    &#125;    public void stateDisplay() &#123;        System.out.println(&quot;角色生命力：&quot; + vit);        System.out.println(&quot;角色攻击力：&quot; + atk);        System.out.println(&quot;角色防御力：&quot; + def);    &#125;    @Data    @AllArgsConstructor    private static class RoleStateMemento implements Memento&#123;        private int vit;        private int atk;        private int def;    &#125;&#125;</code></pre><p><strong>Memento窄接口</strong></p><pre><code class="java">/** * 备忘录窄接口 * * @author codejuzi */public interface Memento &#123;&#125;</code></pre><p><strong>RoleStateCaretaker类</strong></p><pre><code class="java">/** * 角色状态管理者 * * @author codejuzi */@Datapublic class RoleStateCaretaker &#123;    private Memento memento;&#125;</code></pre><p>GameRole内部类<strong>RoleStateMemento类</strong></p><pre><code class="java">@Data    @AllArgsConstructor    private class RoleStateMemento implements Memento&#123;        private int vit;        private int atk;        private int def;    &#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">/** * @author codejuzi */public class RoleStateCaretakerTest &#123;    @Test    public void test() &#123;        System.out.println(&quot;------------大战Boss前------------&quot;);        //大战Boss前        GameRole gameRole = new GameRole();        gameRole.initState();        gameRole.stateDisplay();        // 保存进度        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();        roleStateCaretaker.setMemento(gameRole.saveState());        System.out.println(&quot;------------大战Boss后------------&quot;);        //大战Boss时，损耗严重        gameRole.fight();        gameRole.stateDisplay();        System.out.println(&quot;------------恢复之前状态------------&quot;);        // 回复之前的状态        gameRole.recoverState(roleStateCaretaker.getMemento());        gameRole.stateDisplay();    &#125;&#125;</code></pre><h3 id="4、优缺点-9"><a href="#4、优缺点-9" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点</strong></p><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><p><strong>缺点</strong></p><ul><li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><h3 id="5-使用场景-1"><a href="#5-使用场景-1" class="headerlink" title="5 使用场景"></a>5 使用场景</h3><ul><li><p>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p></li><li><p>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</p></li></ul><h2 id="3-11-解释器模式"><a href="#3-11-解释器模式" class="headerlink" title="3.11 解释器模式"></a>3.11 解释器模式</h2><h3 id="1、概述-10"><a href="#1、概述-10" class="headerlink" title="1、概述"></a>1、概述</h3><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200215220322641.png" alt="image-20200215220322641" style="zoom:67%;" /><p>如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。</p><pre><code class="java">//用于两个整数相加public static int add(int a,int b)&#123;    return a + b;&#125;//用于两个整数相加public static int add(int a,int b,int c)&#123;    return a + b + c;&#125;//用于n个整数相加public static int add(Integer ... arr) &#123;    int sum = 0;    for (Integer i : arr) &#123;        sum += i;    &#125;    return sum;&#125;</code></pre><p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2-3+4+5、1+2+3-4等等。   </p><p>显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p><p><strong>定义：</strong></p><blockquote><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p></blockquote><p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p><p>解释器就是要解析出来语句的含义。但是如何描述规则呢？</p><p><strong>文法（语法）规则：</strong></p><p>文法是用于描述语言的语法结构的形式规则。</p><pre><code class="java">expression ::= value | plus | minusplus ::= expression ‘+’ expression   minus ::= expression ‘-’ expression  value ::= integer</code></pre><blockquote><p>注意： 这里的符号“::&#x3D;”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。</p></blockquote><p>上面规则描述为 ：</p><p>表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。</p><p><strong>抽象语法树：</strong></p><p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p><p>用树形来表示符合文法规则的句子。</p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200215225227616.png" alt="image-20200215225227616" style="zoom:67%;" /><h3 id="2、结构-10"><a href="#2、结构-10" class="headerlink" title="2、结构"></a>2、结构</h3><p>解释器模式包含以下主要角色。</p><ul><li><p>抽象表达式（<code>Abstract Expression</code>）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</p></li><li><p>终结符表达式（<code>Terminal  Expression</code>）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</p></li><li><p>非终结符表达式（<code>Nonterminal Expression</code>）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</p></li><li><p>环境（<code>Context</code>）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p></li><li><p>客户端（<code>Client</code>）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p></li></ul><h3 id="3、案例-10"><a href="#3、案例-10" class="headerlink" title="3、案例"></a>3、案例</h3><p>【例】设计实现加减法的软件</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="解释器模式"></p><p>代码实现</p><p><strong>AbstractExpression抽象类</strong></p><pre><code class="java">/** * 抽象表达式角色 * * @author codejuzi */public abstract class AbstractExpression &#123;    public abstract int interpret(Context context);&#125;</code></pre><p><strong>Value类</strong></p><pre><code class="java">/** * 终结符表达式角色 * * @author codejuzi */public class Value extends AbstractExpression&#123;    private int value;    public Value(int value) &#123;        this.value = value;    &#125;    @Override    public int interpret(Context context) &#123;        return value;    &#125;    @Override    public String toString() &#123;        return Integer.toString(value);    &#125;&#125;</code></pre><p><strong>Plus类</strong></p><pre><code class="java">/** * 非终结符表达式角色  加法表达式 * * @author codejuzi */public class Plus extends AbstractExpression&#123;    private final AbstractExpression left;    private final AbstractExpression right;    public Plus(AbstractExpression left, AbstractExpression right) &#123;        this.left = left;        this.right = right;    &#125;    @Override    public int interpret(Context context) &#123;        return left.interpret(context) + right.interpret(context);    &#125;    @Override    public String toString() &#123;        return &quot;(&quot; + left.toString() + &quot; + &quot; + right.toString() + &quot;)&quot;;    &#125;&#125;</code></pre><p><strong>Minus类</strong></p><pre><code class="java">/** * 非终结符表达式角色  减法表达式 * * @author codejuzi */public class Minus extends AbstractExpression&#123;    private final AbstractExpression left;    private final AbstractExpression right;    public Minus(AbstractExpression left, AbstractExpression right) &#123;        this.left = left;        this.right = right;    &#125;    @Override    public int interpret(Context context) &#123;        return left.interpret(context) - right.interpret(context);    &#125;    @Override    public String toString() &#123;        return &quot;(&quot; + left.toString() + &quot; - &quot; + right.toString() + &quot;)&quot;;    &#125;&#125;</code></pre><p><strong>Variable类</strong></p><pre><code class="java">/** * 终结符表达式角色 -- 变量表达式 * * @author codejuzi */public class Variable extends AbstractExpression &#123;    private final String name;    public Variable(String name) &#123;        this.name = name;    &#125;    @Override    public int interpret(Context context) &#123;        return context.getValue(this);    &#125;    @Override    public String toString() &#123;        return name;    &#125;&#125;</code></pre><p><strong>Context类</strong></p><pre><code class="java">/** * 环境角色 * * @author codejuzi */public class Context &#123;    private final Map&lt;Variable, Integer&gt; variableIntegerMap = new HashMap&lt;&gt;();    public void assign(Variable variable, Integer value) &#123;        variableIntegerMap.put(variable, value);    &#125;    public Integer getValue(Variable variable) &#123;        return Optional.ofNullable(variableIntegerMap.get(variable)).orElse(0);    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">/** * @author codejuzi */public class ContextTest &#123;    @Test    public void test() &#123;        Context context = new Context();        Variable a = new Variable(&quot;a&quot;);        Variable b = new Variable(&quot;b&quot;);        Variable c = new Variable(&quot;c&quot;);        Variable d = new Variable(&quot;d&quot;);        Variable e = new Variable(&quot;e&quot;);        //Value v = new Value(1);        context.assign(a, 1);        context.assign(b, 2);        context.assign(c, 3);        context.assign(d, 4);        context.assign(e, 5);        AbstractExpression expression = new Minus(new Plus(new Plus(new Plus(a, b), c), d), e);        System.out.println(expression);    &#125;&#125;</code></pre><h3 id="4、优缺点-10"><a href="#4、优缺点-10" class="headerlink" title="4、优缺点"></a>4、优缺点</h3><p><strong>优点</strong></p><ul><li><p>易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p></li><li><p>实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。</p></li><li><p>增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 “开闭原则”。</p></li></ul><p><strong>缺点</strong></p><ul><li>对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。</li></ul><ul><li>执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</li></ul><h3 id="5-使用场景-2"><a href="#5-使用场景-2" class="headerlink" title="5 使用场景"></a>5 使用场景</h3><ul><li><p>当语言的文法较为简单，且执行效率不是关键问题时。</p></li><li><p>当问题重复出现，且可以用一种简单的语言来进行表达时。</p></li><li><p>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot工作流程</title>
      <link href="/2022/12/31/SpringBoot%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/12/31/SpringBoot%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#springboot%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">SpringBoot工作流程</a><ul><li><a href="#%E4%B8%80%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">一、自动配置工作流程</a><ul><li><a href="#11-bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F">1.1 bean的加载方式</a><ul><li><a href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6--bean%E6%A0%87%E7%AD%BE">方式一：配置文件 + <code>&lt;bean/&gt;</code>标签</a></li><li><a href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%89%AB%E6%8F%8F--%E6%B3%A8%E8%A7%A3%E5%AE%9A%E4%B9%89bean">方式二：配置文件扫描 + 注解定义bean</a></li><li><a href="#%E6%96%B9%E5%BC%8F%E4%B8%89%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%A3%B0%E6%98%8E%E9%85%8D%E7%BD%AE%E7%B1%BB">方式三：注解方式声明配置类</a><ul><li><a href="#%E4%BD%BF%E7%94%A8factorybean%E6%8E%A5%E5%8F%A3">使用FactoryBean接口</a></li><li><a href="#%E6%B3%A8%E8%A7%A3%E6%A0%BC%E5%BC%8F%E5%AF%BC%E5%85%A5xml%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%9A%84bean">注解格式导入XML格式配置的bean</a></li><li><a href="#proxybeanmethods%E5%B1%9E%E6%80%A7">proxyBeanMethods属性</a></li></ul></li><li><a href="#%E6%96%B9%E5%BC%8F%E5%9B%9B%E4%BD%BF%E7%94%A8import%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5bean">方式四：使用<code>@Import</code>注解注入bean</a><ul><li><a href="#%E4%BD%BF%E7%94%A8import%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5%E9%85%8D%E7%BD%AE%E7%B1%BB">使用<code>@Import</code>注解注入配置类</a></li></ul></li><li><a href="#%E6%96%B9%E5%BC%8F%E4%BA%94%E7%BC%96%E7%A8%8B%E5%BD%A2%E5%BC%8F%E6%B3%A8%E5%86%8Cbean">方式五：编程形式注册bean</a></li><li><a href="#%E6%96%B9%E5%BC%8F%E5%85%AD%E5%AF%BC%E5%85%A5%E5%AE%9E%E7%8E%B0importselector%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB">方式六：导入实现<code>ImportSelector</code>接口的类</a></li><li><a href="#%E6%96%B9%E5%BC%8F%E4%B8%83%E5%AF%BC%E5%85%A5%E5%AE%9E%E7%8E%B0importbeandefinitionregister%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB">方式七：导入实现<code>ImportBeanDefinitionRegister</code>接口的类</a></li><li><a href="#%E6%96%B9%E5%BC%8F%E5%85%AB%E5%AF%BC%E5%85%A5%E5%AE%9E%E7%8E%B0beandefinitionregisteypostprocessor%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB">方式八：导入实现<code>BeanDefinitionRegisteyPostProcessor</code>接口的类</a></li></ul></li><li><a href="#12-bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%8E%A7%E5%88%B6">1.2 bean的加载控制</a></li><li><a href="#13-bean%E7%9A%84%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86">1.3 bean的依赖属性配置管理</a></li><li><a href="#14-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">1.4 自动配置原理（工作流程）</a></li><li><a href="#15-%E5%8F%98%E6%9B%B4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">1.5 变更自动配置</a></li></ul></li><li><a href="#%E4%BA%8Cspringboot%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">二、SpringBoot程序启动程序流程解析</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h1 id="SpringBoot工作流程"><a href="#SpringBoot工作流程" class="headerlink" title="SpringBoot工作流程"></a>SpringBoot工作流程</h1><h2 id="一、自动配置工作流程"><a href="#一、自动配置工作流程" class="headerlink" title="一、自动配置工作流程"></a>一、自动配置工作流程</h2><h3 id="1-1-bean的加载方式"><a href="#1-1-bean的加载方式" class="headerlink" title="1.1 bean的加载方式"></a>1.1 bean的加载方式</h3><ol><li><p>Spring管理bean整体上来说就是由Spring维护对象的生命周期。</p></li><li><p>bean加载大体上可以分为两种形式</p><ol><li>已知类并交由Spring管理 &#x3D;&gt; <code>.class</code></li><li>已知类名并交由Spring管理 &#x3D;&gt; <code>类名字符串</code></li></ol><p>内部原理都一样，通过Spring的<code>BeanDefination</code>对象初始化Spring的bean</p></li></ol><h4 id="方式一：配置文件-lt-bean-gt-标签"><a href="#方式一：配置文件-lt-bean-gt-标签" class="headerlink" title="方式一：配置文件 + &lt;bean/&gt;标签"></a>方式一：配置文件 + <code>&lt;bean/&gt;</code>标签</h4><p>最初级的bean加载方式：提供类名，然后Spring就可以管理了</p><blockquote><p>这种方式是直击Spring管理bean的核心思想，提供bean的类名，内部通过反射机制加载成类的字节码对象<code>class</code>，拿到<code>class</code>就可以进行各种操作了。</p></blockquote><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--xml方式声明自己开发的bean--&gt;    &lt;bean id=&quot;cat&quot; class=&quot;Cat&quot;/&gt;    &lt;bean class=&quot;Dog&quot;/&gt;    &lt;!--xml方式声明第三方开发的bean--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;/&gt;    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;/&gt;    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;/&gt;&lt;/beans&gt;</code></pre><h4 id="方式二：配置文件扫描-注解定义bean"><a href="#方式二：配置文件扫描-注解定义bean" class="headerlink" title="方式二：配置文件扫描 + 注解定义bean"></a>方式二：配置文件扫描 + 注解定义bean</h4><blockquote><p>由于方式一需要将Spring管理的bean全部写在<code>xml</code>文件里，对于开发者来说还是非常不友好的，所以就有了方式二</p></blockquote><p>在要受到Spring管控而加载成bean的类上加注解，可以传递参数，例如bean的别名（id)</p><p>可以使用的注解：<code>@Component</code>以及三个衍生注解<code>@Service</code>,<code>@Controller</code>,<code>@Repository</code></p><pre><code class="java">@Component(&quot;tom&quot;)public class Cat &#123;&#125;</code></pre><pre><code class="java">@Servicepublic class Mouse &#123;&#125;</code></pre><blockquote><p>问题：无法在第三方提供的技术源代码中去添加上述的注解？</p></blockquote><p>解决：<code>@Bean</code>注解定义在一个方法上，当前方法的返回值就可以交由Spring管控了，同时这个方法所在的类一定要定义在<code>@Component</code>修饰的类中</p><pre><code class="java">@Componentpublic class DbConfig &#123;    @Bean    public DruidDataSource dataSource()&#123;        DruidDataSource ds = new DruidDataSource();        return ds;    &#125;&#125;</code></pre><p>上述只是bean的<strong>声明</strong>，还需要设置Spring去检查这些类。此时可以通过<code>xml</code>配置设置Spring要扫描的包，Spring发现了对应注解，就将对应的类纳入Spring管控范围，声明成bean</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd    &quot;&gt;    &lt;!--指定扫描加载bean的位置--&gt;    &lt;context:component-scan base-package=&quot;com.juzi.bean,com.juzi.config&quot;/&gt;&lt;/beans&gt;</code></pre><blockquote><p>方式二的缺点：没有一个地方可以查阅整体信息，只有当程序运行起来才能感知到架在了多少个bean</p></blockquote><h4 id="方式三：注解方式声明配置类"><a href="#方式三：注解方式声明配置类" class="headerlink" title="方式三：注解方式声明配置类"></a>方式三：注解方式声明配置类</h4><p><em>方式三主要是使用Java类替换方式二中的<code>xml</code>配置文件</em></p><p>定义一个类并使用<code>@ComponentScan</code>代替原始<code>xml</code>配置中的包扫描这个动作，功能基本相同。</p><pre><code class="java">@ComponentScan(&#123;&quot;com.juzi.bean&quot;,&quot;com.juzi.config&quot;&#125;)public class SpringConfig3 &#123;    @Bean    public DogFactoryBean dog()&#123;        return new DogFactoryBean();    &#125;&#125;</code></pre><h5 id="使用FactoryBean接口"><a href="#使用FactoryBean接口" class="headerlink" title="使用FactoryBean接口"></a>使用FactoryBean接口</h5><p>Spring提供了一个接口<code>FactoryBean</code>，也可以用于声明bean，只不过实现了<code>FactoryBean</code>接口的类造出来的对象不是当前类的对象，而是<code>FactoryBean</code>接口指定类型的对象</p><pre><code class="java">public class DogFactoryBean implements FactoryBean&lt;Dog&gt; &#123;    @Override    public Dog getObject() throws Exception &#123;        Dog dog = new Dog();        //.........        return dog;    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return Dog.class;    &#125;    @Override    public boolean isSingleton() &#123;        return true;    &#125;&#125;</code></pre><p>上述代码创造出来的bean并不是<code>DogFactoryBean</code>，而是<code>Dog</code>，<strong>好处</strong>就是可以在对象初始化前做一些处理，删除代码注释处就是可以写对象初始化前的处理逻辑</p><p><strong>优势：</strong>上述代码中的可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果将这些逻辑写入Dog的构造器，就不能够灵活的根据场景来初始化对象</p><p>通常实现了FactoryBean接口的类使用@Bean的形式进行加载</p><pre><code class="java">@ComponentScan(&#123;&quot;com.juzi.bean&quot;,&quot;com.juzi.config&quot;&#125;)public class SpringConfig3 &#123;    @Bean    public DogFactoryBean dog()&#123;        return new DogFactoryBean();    &#125;&#125;</code></pre><h5 id="注解格式导入XML格式配置的bean"><a href="#注解格式导入XML格式配置的bean" class="headerlink" title="注解格式导入XML格式配置的bean"></a>注解格式导入XML格式配置的bean</h5><p>Spring支持同时使用<code>xml</code>格式和注解格式配置bean。</p><p>Spring提供了一个注解<code>@ImportResource</code>，传递的参数就是<code>xml</code>配置文件名</p><pre><code class="java">@Configuration@ImportResource(&quot;applicationContext1.xml&quot;)public class SpringConfig32 &#123;&#125;</code></pre><h5 id="proxyBeanMethods属性"><a href="#proxyBeanMethods属性" class="headerlink" title="proxyBeanMethods属性"></a>proxyBeanMethods属性</h5><p>上述例子用到了<code>@Configuration</code>这个注解，当我们使用<code>AnnotationConfigApplicationContext</code>加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的<strong>bean的唯一性</strong>  &#x3D;&gt;  为<code>@Configuration</code>注解设置<code>proxyBeanMethods</code>属性值为<code>true</code>即可，由于此属性默认值为true</p><pre><code class="java">@Configuration(proxyBeanMethods = true)public class SpringConfig33 &#123;    @Bean    public Cat cat()&#123;        return new Cat();    &#125;&#125;</code></pre><p>下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。</p><p><strong>注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。</strong>（这一特性在很多底层源码中都有应用）</p><pre><code class="java">public class App33 &#123;    public static void main(String[] args) &#123;        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig33.class);        String[] names = ctx.getBeanDefinitionNames();        for (String name : names) &#123;            System.out.println(name);        &#125;        System.out.println(&quot;-------------------------&quot;);        SpringConfig33 springConfig33 = ctx.getBean(&quot;springConfig33&quot;, SpringConfig33.class);        System.out.println(springConfig33.cat());        System.out.println(springConfig33.cat());        System.out.println(springConfig33.cat());    &#125;&#125;</code></pre><h4 id="方式四：使用-Import注解注入bean"><a href="#方式四：使用-Import注解注入bean" class="headerlink" title="方式四：使用@Import注解注入bean"></a>方式四：使用<code>@Import</code>注解注入bean</h4><p><code>@Import</code>可以<strong>指定加载</strong>，只需要在注解的参数中写上加载的类对应的<code>.class</code>即可。</p><pre><code class="java">@Import(&#123;Dog.class,DbConfig.class&#125;)public class SpringConfig4 &#123;&#125;</code></pre><h5 id="使用-Import注解注入配置类"><a href="#使用-Import注解注入配置类" class="headerlink" title="使用@Import注解注入配置类"></a>使用<code>@Import</code>注解注入配置类</h5><p>除了加载bean，还可以使用<code>@Import</code>注解加载配置类，二者本质是一样的</p><pre><code class="java">@Import(DogFactoryBean.class)public class SpringConfig4 &#123;&#125;</code></pre><h4 id="方式五：编程形式注册bean"><a href="#方式五：编程形式注册bean" class="headerlink" title="方式五：编程形式注册bean"></a>方式五：编程形式注册bean</h4><p>方式五可以在容器初始化之后手动加载bean。通过这种方式可以实现编程式控制bean的加载</p><pre><code class="java">public class App5 &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        //上下文容器对象已经初始化完毕后，手工加载bean        ctx.register(Mouse.class);    &#125;&#125;</code></pre><blockquote><p>方式五的坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖？</p><pre><code class="java">public class App5 &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        //上下文容器对象已经初始化完毕后，手工加载bean        ctx.registerBean(&quot;tom&quot;, Cat.class,0);        ctx.registerBean(&quot;tom&quot;, Cat.class,1);        ctx.registerBean(&quot;tom&quot;, Cat.class,2);        System.out.println(ctx.getBean(Cat.class));    &#125;&#125;</code></pre><p><em>后配置的覆盖先配置的</em></p></blockquote><h4 id="方式六：导入实现ImportSelector接口的类"><a href="#方式六：导入实现ImportSelector接口的类" class="headerlink" title="方式六：导入实现ImportSelector接口的类"></a>方式六：导入实现<code>ImportSelector</code>接口的类</h4><p>方式五是在容器初始化后实现添加<code>if</code>语句实现对bean的加载控制，而方式六是在容器初始化过程中进行加载控制。</p><p>实现<code>ImportSelector</code>接口的类可以设置加载的bean的全路径类名。</p><blockquote><p>记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。</p></blockquote><pre><code class="java">public class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata metadata) &#123;        //各种条件的判定，判定完毕后，决定是否装载指定的bean        boolean flag = metadata.hasAnnotation(&quot;org.springframework.context.annotation.Configuration&quot;);        if(flag)&#123;            return new String[]&#123;&quot;com.juzi.bean.Dog&quot;&#125;;        &#125;        return new String[]&#123;&quot;com.juzi.bean.Cat&quot;&#125;;    &#125;&#125;</code></pre><h4 id="方式七：导入实现ImportBeanDefinitionRegister接口的类"><a href="#方式七：导入实现ImportBeanDefinitionRegister接口的类" class="headerlink" title="方式七：导入实现ImportBeanDefinitionRegister接口的类"></a>方式七：导入实现<code>ImportBeanDefinitionRegister</code>接口的类</h4><blockquote><p>Spring控制bean初始化加载的核心是<code>BeanDefinition</code></p></blockquote><p>可以通过定义一个类，然后实现<code>ImportBeanDefinitionRegistrar</code>接口的方式定义bean，并且还可以让开发者对bean的初始化进行更加细粒度的控制</p><pre><code class="java">public class MyRegistrar implements ImportBeanDefinitionRegistrar &#123;    @Override    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;        BeanDefinition beanDefinition =             BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();        registry.registerBeanDefinition(&quot;bookService&quot;,beanDefinition);    &#125;&#125;</code></pre><h4 id="方式八：导入实现BeanDefinitionRegisteyPostProcessor接口的类"><a href="#方式八：导入实现BeanDefinitionRegisteyPostProcessor接口的类" class="headerlink" title="方式八：导入实现BeanDefinitionRegisteyPostProcessor接口的类"></a>方式八：导入实现<code>BeanDefinitionRegisteyPostProcessor</code>接口的类</h4><blockquote><p>上述七种加载bean的方式都是在容器初始化过程中进行bean的加载或者声明，但是有一个问题，这么多种方式，如果它们之间有冲突怎么办？谁有最终裁定权？</p></blockquote><p><code>BeanDefinitionRegisteyPostProcessor</code>：bean定义后处理器，意思就是在所有bean注册都执行完后，再执行它，它是最后一个执行的。</p><pre><code class="java">public class MyPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;    @Override    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;        BeanDefinition beanDefinition =             BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();        registry.registerBeanDefinition(&quot;bookService&quot;,beanDefinition);    &#125;&#125;</code></pre><p><strong>总结：</strong></p><ul><li>bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过<strong>反射</strong>机制加载类名后创建对象，对象就是spring管控的bean</li><li><code>@Import</code>注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有<code>@Bean</code>相关的定义，会被一同加载</li><li>spring开放出了若干种可编程<strong>控制</strong>的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean</li></ul><h3 id="1-2-bean的加载控制"><a href="#1-2-bean的加载控制" class="headerlink" title="1.2 bean的加载控制"></a>1.2 bean的加载控制</h3><p>实际开发过程中是采用<strong>必要性加载</strong>，而不是<strong>饱和式加载</strong>，意思就是用什么加载什么。</p><p>加载bean的类型取决开发过程使用的技术，也就是加载技术对应的类。</p><p>&#x3D;&gt; 在Spring容器中，通过判定是否加载了某个类来控制某些bean加载是一种常见的操作。</p><pre><code class="java">public class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(&quot;com.juzi.bean.Mouse&quot;);            if(clazz != null) &#123;                return new String[]&#123;&quot;com.juzi.bean.Cat&quot;&#125;;            &#125;        &#125; catch (ClassNotFoundException e) &#123;//            e.printStackTrace();            return new String[0];        &#125;        return null;    &#125;&#125;</code></pre><p>上述代码的思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就执行对应的操作，否则执行别的操作。</p><p>但是上述代码存在问题，判断逻辑过于臃肿，SpringBoot为此提供了注解。</p><p>下例使用<code>@ConditionalOnClass</code>注解实现了当虚拟机中加载了<code>com.juzi.bean.Wolf</code>类时加载对应的bean。</p><blockquote><p>此类注解还有很多很多，不用记，忘了就查！！！</p></blockquote><pre><code class="java">@Bean@ConditionalOnClass(name = &quot;com.juzi.bean.Wolf&quot;)public Cat tom()&#123;    return new Cat();&#125;</code></pre><p><code>@ConditionalOnMissingClass</code>注解控制虚拟机中没有加载指定的类才加载对应的bean。</p><pre><code class="java">@Bean@ConditionalOnMissingClass(&quot;com.juzi.bean.Dog&quot;)public Cat tom()&#123;    return new Cat();&#125;</code></pre><p>此类条件还可以做<strong>逻辑与</strong>运算</p><pre><code class="java">@Bean@ConditionalOnClass(name = &quot;com.juzi.bean.Wolf&quot;)@ConditionalOnMissingClass(&quot;com.juzi.bean.Mouse&quot;)public Cat tom()&#123;    return new Cat();&#125;</code></pre><p>除了判定是否加载类，还可以对当前容器类型做判定。下例是判定当前容器环境是否是web环境</p><pre><code class="java">@Bean@ConditionalOnWebApplicationpublic Cat tom()&#123;    return new Cat();&#125;</code></pre><p>下例是判定容器环境是否是非web环境</p><pre><code class="java">@Bean@ConditionalOnNotWebApplicationpublic Cat tom()&#123;    return new Cat();&#125;</code></pre><p>除了上述功能，还可以判定是否架在了指定名称的bean &#x3D;&gt;  实现<strong>自适应</strong>，如果没有再提供</p><pre><code class="java">@Bean@ConditionalOnBean(name=&quot;jerry&quot;)public Cat tom()&#123;    return new Cat();&#125;</code></pre><p>下例是判定当前是否加载了mysql的驱动类，如果加载了，就创建一个Druid的数据源对象</p><pre><code class="java">public class SpringConfig &#123;    @Bean    @ConditionalOnClass(name=&quot;com.mysql.jdbc.Driver&quot;)    public DruidDataSource dataSource()&#123;        return new DruidDataSource();    &#125;&#125;</code></pre><p>……</p><p><strong>总结</strong></p><ol><li>springboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean</li></ol><h3 id="1-3-bean的依赖属性配置管理"><a href="#1-3-bean的依赖属性配置管理" class="headerlink" title="1.3 bean的依赖属性配置管理"></a>1.3 bean的依赖属性配置管理</h3><p>bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，此时可以使用bean的属性配置进行灵活的配置。</p><ol><li><p>通过<code>yml</code>配置文件，设置bean运行需要使用的配置信息</p><pre><code class="yaml">cartoon:  cat:    name: &quot;tom&quot;    age: 4  mouse:    name: &quot;jerry&quot;    age: 3</code></pre></li><li><p>定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值</p><pre><code class="java">@ConfigurationProperties(prefix = &quot;cartoon&quot;)@Datapublic class CartoonProperties &#123;    private Cat cat;    private Mouse mouse;&#125;</code></pre></li><li><p>在使用的位置注入对象的属性</p><pre><code class="java">@EnableConfigurationProperties(CartoonProperties.class)public class CartoonCatAndMouse&#123;    @Autowired    private CartoonProperties cartoonProperties;&#125;</code></pre><blockquote><p>建议在业务类上使用<code>@EnableConfigurationProperties</code>声明<code>bean</code>，这样在不使用这个类的时候，也不会无故加载专用的属性配置类<code>CartoonProperties</code>，<strong>减少spring管控的资源数量</strong>。</p></blockquote></li></ol><p><strong>总结</strong></p><ol><li>bean的运行如果需要外部设置值，建议将设置值封装成专用的属性类<code>Properties</code></li><li>设置属性类加载指定前缀的配置信息</li><li>在需要使用属性类的位置通过注解<code>@EnableConfigurationProperties</code>加载bean，而不要直接在属性配置类上定义bean，减少资源加载的数量，因需加载而不要饱和式加载。</li></ol><h3 id="1-4-自动配置原理（工作流程）"><a href="#1-4-自动配置原理（工作流程）" class="headerlink" title="1.4 自动配置原理（工作流程）"></a>1.4 自动配置原理（工作流程）</h3><p>1）自动配置：SpringBoot事先准备大量的bean，再根据开发者的配置、导入类的情况按需加载bean</p><p>2）自动配置的意义：加速开发效率，将开发者使用某些技术时所需要使用的bean根据情况提前加载好，实现自动配置的效果。</p><p>3）自动装配的整体过程（思想）分为两个阶段：</p><p><strong>阶段一：准备阶段</strong></p><ul><li>springboot的开发人员先大量收集Spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个<strong>技术集A</strong></li><li>收集常用技术(<strong>技术集A</strong>)的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的<strong>设置集B</strong></li></ul><p><strong>阶段二：加载阶段</strong></p><ul><li>springboot初始化Spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的其他坐标，形成<strong>初始化环境</strong></li><li>springboot将<strong>技术集A</strong>包含的所有技术在SpringBoot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的</li><li>springboot会对<strong>技术集A</strong>中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和其他坐标，也就是与<strong>初始化环境</strong>，这个时候就可以根据这个<strong>初始化环境</strong>与springboot的<strong>技术集A</strong>进行比对了，哪个匹配上加载哪个，按需加载</li><li>因为有些技术不做配置就无法工作，所以springboot开始对<strong>设置集B</strong>下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量</li><li>但是默认配置不一定能解决问题，于是springboot开放修改<strong>设置集B</strong>的接口，可以由开发者根据需要决定是否覆盖默认配置</li></ul><p>4）实现自动配置</p><ul><li><p>首先指定一个技术X，我们打算让技术X具备自动配置的功能，这个技术X可以是任意功能，这个技术隶属于上面描述的<strong>技术集A</strong></p><pre><code class="java">public class CartoonCatAndMouse&#123;&#125;</code></pre></li><li><p>然后找出技术X使用过程中的常用配置Y，这个配置隶属于上面表述的<strong>设置集B</strong></p><pre><code class="java">cartoon:  cat:    name: &quot;tom&quot;    age: 4  mouse:    name: &quot;jerry&quot;    age: 3</code></pre></li><li><p>将常用配置Y设计出对应的yml配置书写格式，然后定义一个属性类封装对应的配置属性（过程同bean依赖属性管理）</p><pre><code class="java">@ConfigurationProperties(prefix = &quot;cartoon&quot;)@Datapublic class CartoonProperties &#123;    private Cat cat;    private Mouse mouse;&#125;</code></pre></li><li><p>最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配</p><pre><code class="java">@EnableConfigurationProperties(CartoonProperties.class)public class CartoonCatAndMouse implements ApplicationContextAware &#123;    private CartoonProperties cartoonProperties;&#125;</code></pre></li><li><p>另外的，也可以为当前自动配置类设置上激活条件，例如使用<code>@CondtionOn* * * * </code>为其设置加载条件</p><pre><code class="java">@ConditionalOnClass(name=&quot;org.springframework.data.redis.core.RedisOperations&quot;)@EnableConfigurationProperties(CartoonProperties.class)public class CartoonCatAndMouse implements ApplicationContextAware &#123;    private CartoonProperties cartoonProperties;&#125;</code></pre></li></ul><p>下一步要做的就是<strong>让SpringBoot启动的时候去加载这个类</strong>，SpringBoot开放了一个配置入口</p><ul><li>在配置目录中创建<code>META-INF</code>目录</li><li>在<code>META-INF</code>目录下创建文件<code>spring.factories</code></li><li>在<code>spring.factories</code>中添加设置，说明哪些类要启动自动配置即可</li></ul><pre><code class="properties"># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.itheima.bean.CartoonCatAndMouse</code></pre><blockquote><p>本质上<code>spring.factories</code>只做了一件事，通过这种配置的方式加载指定的类。</p><p>其实就是个普通的bean的加载，和最初使用xml格式加载bean几乎没有区别，格式变了而已。</p></blockquote><p>5）自动配置的核心是什么呢？自动配置就是一个小的<strong>生态</strong>，可以按照如下思想理解：</p><ul><li>自动配置从根本上来说就是一个bean的加载</li><li>通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用</li><li>使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，但实际上还是使用最普通的分支语句的应用</li><li>springboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，本质上就是提前写好了<code>spring.factories</code>文件</li></ul><p><strong>总结</strong></p><ol><li>springboot启动时先加载<code>spring.factories</code>文件中的<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>配置项，将其中配置的所有的类都加载成bean</li><li>在加载bean的时候，bean对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载bean</li><li>对于可以正常加载成bean的类，通常会通过<code>@EnableConfigurationProperties</code>注解初始化对应的配置属性类并加载对应的配置</li><li>配置属性类上通常会通过<code>@ConfigurationProperties</code>加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了</li></ol><h3 id="1-5-变更自动配置"><a href="#1-5-变更自动配置" class="headerlink" title="1.5 变更自动配置"></a>1.5 变更自动配置</h3><p><strong>方式一：通过yml配置设置排除指定的自动配置类</strong></p><pre><code class="yaml">spring:  autoconfigure:    exclude:      - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration</code></pre><p><strong>方式二：通过注解参数排除自动配置类</strong></p><pre><code class="java">@EnableAutoConfiguration(excludeName = &quot;&quot;,exclude = &#123;&#125;)</code></pre><p><strong>方式三：排除坐标（应用面较窄）</strong></p><p>如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。</p><p>例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，把tomcat排除掉，记得再加一种可以运行的服务器。</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件--&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;!--添加Jetty起步依赖，匹配自动配置条件--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>总结</strong></p><ol><li>springboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能</li></ol><h2 id="二、SpringBoot程序启动程序流程解析"><a href="#二、SpringBoot程序启动程序流程解析" class="headerlink" title="二、SpringBoot程序启动程序流程解析"></a>二、SpringBoot程序启动程序流程解析</h2><p>对于SpringBoot技术来说，它用于加速Spring程序的开发，核心本质还是Spring程序的运行，所以与其说是SpringBoot程序的启动流程，不如说是SpringBoot对Spring程序的启动流程做了哪些更改。</p><p>其实不管是SpringBoot程序还是Spring程序，启动过程本质上都是在做<strong>容器的初识化，并将对应的bean初始化出来放入容器</strong>。</p><blockquote><p>在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。</p><p>作为开发者只需要知道SpringBoot提供了哪些参数设置的环节，同时初始化容器的过程都做了那些事即可。</p></blockquote><p>SpringBoot初始化的参数根据参数的提供方，划分称为如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：</p><ul><li>环境属性(<code>Environment</code>)</li><li>系统配置(<code>spring.factories</code>)</li><li>参数(<code>Arguments、application.properties</code>)</li></ul><pre><code class="yaml">Springboot30StartupApplication【10】-&gt;SpringApplication.run(Springboot30StartupApplication.class, args);    SpringApplication【1332】-&gt;return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);        SpringApplication【1343】-&gt;return new SpringApplication(primarySources).run(args);            SpringApplication【1343】-&gt;SpringApplication(primarySources)            # 加载各种配置信息，初始化各种配置对象                SpringApplication【266】-&gt;this(null, primarySources);                    SpringApplication【280】-&gt;public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)                        SpringApplication【281】-&gt;this.resourceLoader = resourceLoader;                        # 初始化资源加载器                        SpringApplication【283】-&gt;this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));                        # 初始化配置类的类名信息（格式转换）                        SpringApplication【284】-&gt;this.webApplicationType = WebApplicationType.deduceFromClasspath();                        # 确认当前容器加载的类型                        SpringApplication【285】-&gt;this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();                        # 获取系统配置引导信息                        SpringApplication【286】-&gt;setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));                        # 获取ApplicationContextInitializer.class对应的实例                        SpringApplication【287】-&gt;setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));                        # 初始化监听器，对初始化过程及运行过程进行干预                        SpringApplication【288】-&gt;this.mainApplicationClass = deduceMainApplicationClass();                        # 初始化了引导类类名信息，备用            SpringApplication【1343】-&gt;new SpringApplication(primarySources).run(args)            # 初始化容器，得到ApplicationContext对象                SpringApplication【323】-&gt;StopWatch stopWatch = new StopWatch();                # 设置计时器                SpringApplication【324】-&gt;stopWatch.start();                # 计时开始                SpringApplication【325】-&gt;DefaultBootstrapContext bootstrapContext = createBootstrapContext();                # 系统引导信息对应的上下文对象                SpringApplication【327】-&gt;configureHeadlessProperty();                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）                    java.awt.headless=true                SpringApplication【328】-&gt;SpringApplicationRunListeners listeners = getRunListeners(args);                # 获取当前注册的所有监听器                SpringApplication【329】-&gt;listeners.starting(bootstrapContext, this.mainApplicationClass);                # 监听器执行了对应的操作步骤                SpringApplication【331】-&gt;ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);                # 获取参数                SpringApplication【333】-&gt;ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);                # 将前期读取的数据加载成了一个环境对象，用来描述信息                SpringApplication【333】-&gt;configureIgnoreBeanInfo(environment);                # 做了一个配置，备用                SpringApplication【334】-&gt;Banner printedBanner = printBanner(environment);                # 初始化logo                SpringApplication【335】-&gt;context = createApplicationContext();                # 创建容器对象，根据前期配置的容器类型进行判定并创建                SpringApplication【363】-&gt;context.setApplicationStartup(this.applicationStartup);                # 设置启动模式                SpringApplication【337】-&gt;prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);                # 对容器进行设置，参数来源于前期的设定                SpringApplication【338】-&gt;refreshContext(context);                # 刷新容器环境                SpringApplication【339】-&gt;afterRefresh(context, applicationArguments);                # 刷新完毕后做后处理                SpringApplication【340】-&gt;stopWatch.stop();                # 计时结束                SpringApplication【341】-&gt;if (this.logStartupInfo) &#123;                # 判定是否记录启动时间的日志                SpringApplication【342】-&gt;    new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);                # 创建日志对应的对象，输出日志信息，包含启动时间                SpringApplication【344】-&gt;listeners.started(context);                # 监听器执行了对应的操作步骤                SpringApplication【345】-&gt;callRunners(context, applicationArguments);                # 调用运行器                SpringApplication【353】-&gt;listeners.running(context);                # 监听器执行了对应的操作步骤</code></pre><p><em>如果想要干预SpringBoot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入SPringBoot的启动流程呢？</em></p><p>1）遇到这样的问题，大部分技术是这样设计的：设计若干个标准接口，对应程序中的所有标准过程。当开发者想要干预某个过程时，实现接口就可以了。</p><p>例如Spring技术中Bean的生命周期管理就是采用标准接口进行的。</p><pre><code class="java">public class Abc implements InitializingBean, DisposableBean &#123;    public void destroy() throws Exception &#123;        //销毁操作    &#125;    public void afterPropertiesSet() throws Exception &#123;        //初始化操作    &#125;&#125;</code></pre><p>SpringBoot 启动过程由于存在大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者并不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。</p><p>SpringBoot采用了一种最原始的设计模式来解决这个问题，<strong>监听器模式</strong>，使用监听器来解决这个问题。</p><p>SpringBoot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：</p><ul><li><code>org.springframework.boot.context.event.ApplicationStartingEvent</code><ul><li>应用启动事件，在应用运行但未进行任何处理时，将发送 <code>ApplicationStartingEvent</code></li></ul></li><li><code>org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent</code><ul><li>环境准备事件，当<code>Environment</code>被使用，且上下文创建之前，将发送 <code>ApplicationEnvironmentPreparedEvent</code></li></ul></li><li><code>org.springframework.boot.context.event.ApplicationContextInitializedEvent</code><ul><li>上下文初始化事件</li></ul></li><li><code>org.springframework.boot.context.event.ApplicationPreparedEvent</code><ul><li>应用准备事件，在开始刷新之前，bean定义被加载之后发送 <code>ApplicationPreparedEvent</code></li></ul></li><li><code>org.springframework.context.event.ContextRefreshedEvent</code><ul><li>上下文刷新事件</li></ul></li><li><code>org.springframework.boot.context.event.ApplicationStartedEvent</code><ul><li>应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 <code>ApplicationStartedEvent</code></li></ul></li><li><code>org.springframework.boot.context.event.ApplicationReadyEvent</code><ul><li>应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 <code>ApplicationReadyEvent</code>，用于通知应用已经准备处理请求</li></ul></li><li><code>org.springframework.context.event.ContextClosedEvent</code><ul><li>上下文关闭事件，对应容器关闭</li></ul></li></ul><p>上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。</p><pre><code class="java">//设定监听器，在应用启动开始事件时进行功能追加public class MyListener implements ApplicationListener&lt;ApplicationStartingEvent&gt; &#123;    public void onApplicationEvent(ApplicationStartingEvent event) &#123;        //自定义事件处理逻辑    &#125;&#125;</code></pre><p>按照上述方案处理，用户就可以干预SpringBoot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。</p><p><strong>总结：</strong></p><ol><li>SpringBoot启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器</li><li>整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发的位置执行开发者的业务代码</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之路-二叉树篇</title>
      <link href="/2022/12/30/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/"/>
      <url>/2022/12/30/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p><span id="more"></span><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87">算法学习之路–二叉树篇</a><ul><li><a href="#%E4%B8%80%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">一、二叉树理论基础</a><ul><li><a href="#1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB">1、二叉树的种类</a><ul><li><a href="#1%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91">1）满二叉树</a></li><li><a href="#2%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">2）完全二叉树</a></li><li><a href="#4%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">4）平衡二叉搜索树</a></li></ul></li><li><a href="#2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9D%91%E5%A1%BE%E6%96%B9%E5%BC%8F">2、二叉树的村塾方式</a></li><li><a href="#3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F">3、二叉树的遍历方式</a></li><li><a href="#4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">4、二叉树的定义</a></li></ul></li><li><a href="#%E4%BA%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">二、二叉树的递归遍历</a></li><li><a href="#%E4%B8%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86">三、二叉树的迭代遍历</a><ul><li><a href="#1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95">1、前序遍历（迭代法）</a></li><li><a href="#2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95">2、中序遍历（迭代法）</a></li><li><a href="#3%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95">3、后序遍历（迭代法）</a></li></ul></li><li><a href="#%E5%9B%9B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95">四、二叉树的统一迭代法</a><ul><li><a href="#1%E8%BF%AD%E4%BB%A3%E6%B3%95%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">1、迭代法中序遍历</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">2、迭代法的前序遍历</a></li><li><a href="#3%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">3、迭代法的后序遍历</a></li></ul></li><li><a href="#%E4%BA%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">五、二叉树的层序遍历</a><ul><li><a href="#102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">102、二叉树的层序遍历</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li></ul></li><li><a href="#107%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86ii">107、二叉树的层序遍历II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-1">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-1">实现</a></li></ul></li><li><a href="#199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE">199、二叉树的右视图</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-2">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-2">实现</a></li></ul></li><li><a href="#637%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC">637、二叉树的层平均值</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-3">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-3">实现</a></li></ul></li><li><a href="#429n%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">429、N叉树的层序遍历</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-4">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-4">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-4">实现</a></li></ul></li><li><a href="#515%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC">515、在每个树行中找最大值</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目：</a></li><li><a href="#%E6%80%9D%E8%B7%AF-5">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-5">实现</a></li></ul></li><li><a href="#116%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88">116、填充每个节点的下一个右侧节点指针</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-5">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-6">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-6">实现</a></li></ul></li><li><a href="#117%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88ii">117、填充每个节点的下一个右侧节点指针II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-6">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-7">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-7">实现</a></li></ul></li></ul></li><li><a href="#%E5%85%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BF%BB%E8%BD%AC">六、二叉树的翻转</a><ul><li><a href="#226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">226、翻转二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-7">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-8">思路</a><ul><li><a href="#%E9%80%92%E5%BD%92%E6%B3%95">递归法</a></li><li><a href="#%E8%BF%AD%E4%BB%A3%E6%B3%95">迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-8">实现</a><ul><li><a href="#%E9%80%92%E5%BD%92%E6%B3%95-1">递归法</a></li><li><a href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-1">迭代法</a></li></ul></li></ul></li></ul></li><li><a href="#%E4%B8%83%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">七、对称二叉树</a><ul><li><a href="#101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">101、对称二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-8">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-9">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95">（1）递归法</a></li><li><a href="#2-%E8%BF%AD%E4%BB%A3%E6%B3%95">(2) 迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-9">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-1">（1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95">（2）迭代法</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%85%AB%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">八、二叉树的深度</a><ul><li><a href="#104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">104、二叉树的最大深度</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-9">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-10">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-2">（1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-1">（2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-10">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-3">（1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-2">（2）迭代法</a></li><li><a href="#3%E6%A0%88%E6%A8%A1%E6%8B%9F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">（3）栈模拟后序遍历</a></li></ul></li></ul></li><li><a href="#559n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">559、N叉树的最大深度</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-10">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-11">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-4">（1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-3">（2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-11">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-5">（1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-4">（2）迭代法</a></li></ul></li></ul></li><li><a href="#111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6">111、二叉树的最小深度</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-11">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-12">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-6">（1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-5">（2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-12">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-7">（1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-6">（2）迭代法</a></li></ul></li></ul></li></ul></li><li><a href="#%E4%B9%9D%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0">九、完全二叉树的节点个数</a><ul><li><a href="#222%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0">222、完全二叉树的节点个数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-12">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-13">思路</a><ul><li><a href="#1%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91">1）普通二叉树</a></li><li><a href="#2%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-1">2）完全二叉树</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-13">实现</a><ul><li><a href="#1--%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91">1)  普通二叉树</a></li><li><a href="#2%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-2">2）完全二叉树</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%8D%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">十、平衡二叉树</a><ul><li><a href="#110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">110、平衡二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-13">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-14">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92">1）递归</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-14">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-1">2）迭代法</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%8D%81%E4%B8%80%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84">十一、二叉树的所有路径</a><ul><li><a href="#257%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84">257、二叉树的所有路径</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-14">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-15">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92-1">1）递归</a></li><li><a href="#2-%E8%BF%AD%E4%BB%A3%E6%B3%95">2） 迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-15">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92-2">1）递归</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-2">2）迭代法</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%8D%81%E4%BA%8C%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C">十二、左叶子之和</a><ul><li><a href="#404%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C">404、左叶子之和</a><ul><li><a href="#%E6%80%9D%E8%B7%AF-16">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-1">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-3">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-16">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-2">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-4">2）迭代法</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%8D%81%E4%B8%89%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC">十三、树左下角的值</a><ul><li><a href="#513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC">513、找树左下角的值</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-15">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-17">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-3">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-5">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-17">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-4">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-6">2）迭代法</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%8D%81%E4%B8%89%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">十三、路径总和</a><ul><li><a href="#112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">112、路径总和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-16">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-18">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92-3">1）递归</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3">2）迭代</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-18">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-5">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-7">2）迭代法</a></li></ul></li></ul></li><li><a href="#113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8Cii">113、路径总和II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-17">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-19">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-19">实现</a></li></ul></li></ul></li><li><a href="#%E5%8D%81%E5%9B%9B%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">十四、构造二叉树</a><ul><li><a href="#106%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">106、从中序和后序遍历序列构造二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-18">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-20">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-20">实现</a></li></ul></li><li><a href="#105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">105、从前序与后序遍历序列构造二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-19">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-21">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-21">实现</a></li></ul></li><li><a href="#654%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91">654、最大二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-20">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-22">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-22">实现</a></li></ul></li></ul></li><li><a href="#%E5%8D%81%E4%BA%94%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91">十五、合并二叉树</a><ul><li><a href="#617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91">617、合并二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-21">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-23">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-6">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-8">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-23">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-7">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-9">2）迭代法</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%8D%81%E5%85%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98">十六、二叉树中的搜索专题</a><ul><li><a href="#700%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2">700、二叉搜索树中的搜索</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-22">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-24">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-8">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-10">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-24">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-9">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-11">2）迭代法</a></li></ul></li></ul></li><li><a href="#98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">98、验证二叉搜索树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-23">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-25">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-10">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-12">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-25">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-11">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-13">2）迭代法</a></li></ul></li></ul></li><li><a href="#530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE">530、二叉搜索树的最小绝对差</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-24">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-26">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92-4">1）递归</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-14">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-26">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92-5">1）递归</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-15">2）迭代法</a></li></ul></li></ul></li><li><a href="#501%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0">501、二叉搜索树中的众数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-25">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-27">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-12">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-16">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-27">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-13">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-17">2）迭代法</a></li></ul></li></ul></li><li><a href="#236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">236、二叉树的最近公共祖先</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-26">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-28">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-28">实现</a></li></ul></li><li><a href="#235%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">235、二叉搜索树的最近公共祖先</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-27">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-29">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-14">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-18">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-29">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-15">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-19">2）迭代法</a></li></ul></li></ul></li><li><a href="#701%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">701、二叉搜索树中的插入操作</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-28">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-30">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-16">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-20">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-30">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-17">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-21">2）迭代法</a></li></ul></li></ul></li><li><a href="#450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9">450、删除二叉搜索树中的节点</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-29">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-31">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-18">1）递归法</a></li><li><a href="#2%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%96%B9%E5%BC%8F">2）普通二叉树的删除方式</a></li><li><a href="#3%E8%BF%AD%E4%BB%A3%E6%B3%95">3）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-31">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-19">1）递归法</a></li><li><a href="#2%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4">2）普通二叉树的删除</a></li><li><a href="#3%E8%BF%AD%E4%BB%A3%E6%B3%95-1">3）迭代法</a></li></ul></li></ul></li><li><a href="#669%E4%BF%AE%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">669、修建二叉搜索树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-30">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-32">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-20">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-22">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-32">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-21">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-23">2）迭代法</a></li></ul></li></ul></li><li><a href="#108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">108、将有序数组转换成为二叉搜索树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-31">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-33">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92-6">1）递归</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-24">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-33">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92%E6%B3%95-22">1）递归法</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-25">2）迭代法</a></li></ul></li></ul></li><li><a href="#538%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91">538、把二叉搜索树转换为累加树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-32">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-34">思路</a><ul><li><a href="#1%E9%80%92%E5%BD%92-7">1）递归</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-26">2）迭代法</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-34">实现</a><ul><li><a href="#1%E9%80%92%E5%BD%92-8">1）递归</a></li><li><a href="#2%E8%BF%AD%E4%BB%A3%E6%B3%95-27">2）迭代法</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87--%E6%80%BB%E7%BB%93">二叉树篇–总结</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><blockquote><p><a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p></blockquote><h1 id="算法学习之路–二叉树篇"><a href="#算法学习之路–二叉树篇" class="headerlink" title="算法学习之路–二叉树篇"></a>算法学习之路–二叉树篇</h1><h2 id="一、二叉树理论基础"><a href="#一、二叉树理论基础" class="headerlink" title="一、二叉树理论基础"></a>一、二叉树理论基础</h2><h3 id="1、二叉树的种类"><a href="#1、二叉树的种类" class="headerlink" title="1、二叉树的种类"></a>1、二叉树的种类</h3><p><em>在解题过程中二叉树形式主要有两种：</em></p><ul><li>满二叉树</li><li>完全二叉树</li></ul><h4 id="1）满二叉树"><a href="#1）满二叉树" class="headerlink" title="1）满二叉树"></a>1）满二叉树</h4><p>满⼆叉树：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层 上，则这棵⼆叉树为满⼆叉树</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222090231.png"></p><p>这棵二叉树为满二叉树，也可以说是深度为 <code>k</code>，有 <code>2 ^ k - 1</code>个节点的二叉树</p><h4 id="2）完全二叉树"><a href="#2）完全二叉树" class="headerlink" title="2）完全二叉树"></a>2）完全二叉树</h4><p>完全⼆叉树：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 <code>h </code>层，则该层包含<code> 1~ 2 ^ h -1</code> 个节点</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222090451.png"></p><p>####3）二叉搜索树</p><p>上述介绍的树都是没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong></p><ul><li>若它的左子树不空，则左子树上所有节点的值均小于它的根结点的值</li><li>若它的右子树不空，则右子树上所有节点的值均大于它的根结点的值</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222090819.png"></p><h4 id="4）平衡二叉搜索树"><a href="#4）平衡二叉搜索树" class="headerlink" title="4）平衡二叉搜索树"></a>4）平衡二叉搜索树</h4><p>平衡二叉搜索树：又称为AVL(Adelson - Velsky and Landis)树，它具有以下性质</p><ul><li>它是一颗空树 或者 它的左右两颗子树的高度差的绝对值不超过1</li><li>左右两颗子树都是一颗平衡二叉树</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222091200.png"></p><p>最后一颗不是平衡二叉树，因为它的左右两颗子树的高度差的绝对值超过1了</p><h3 id="2、二叉树的村塾方式"><a href="#2、二叉树的村塾方式" class="headerlink" title="2、二叉树的村塾方式"></a>2、二叉树的村塾方式</h3><p><strong>二叉树可以链式存储，也可以顺序存储</strong></p><p>链式存储（指针实现）：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222091825.png"></p><p>顺序存储（数组实现）：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222091910.png"></p><blockquote><p>用数组来存储二叉树如何遍历呢？</p><p>如果父结点的数组下标是 i ，那么它的左节点就是<code>2 * i + 1</code>，右节点就是<code>2 * i + 2</code></p></blockquote><h3 id="3、二叉树的遍历方式"><a href="#3、二叉树的遍历方式" class="headerlink" title="3、二叉树的遍历方式"></a>3、二叉树的遍历方式</h3><p>1）二叉树的遍历方式主要有两种：</p><ol><li>深度优先遍历：先往深走，遇到叶子结点再往回走</li><li>广度优先遍历：一层一层得去遍历</li></ol><p><strong>这两种遍历方式是图论中最基本的两种遍历方式</strong></p><p>在此基础上拓展：</p><ol><li><p>深度优先遍历</p><ul><li>前序遍历（递归法、迭代法）</li><li>中序遍历（递归法、迭代法）</li><li>后序遍历（递归法、迭代法）</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222092514.png"></p></li><li><p>广度优先遍历</p><ul><li>层序遍历（迭代法）</li></ul></li></ol><p>2）二叉树中深度优先遍历和广度优先遍历的实现方式</p><ol><li>经常使用递归的方式来实现深度优先遍历</li><li><em>栈就是递归的一种实现结构</em>，深度优先遍历也可以借助栈使用非递归的方式实现</li><li>广度优先遍历的实现一般使用队列来实现，这就是队列FIFO的特点决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树</li></ol><h3 id="4、二叉树的定义"><a href="#4、二叉树的定义" class="headerlink" title="4、二叉树的定义"></a>4、二叉树的定义</h3><p>1）顺序存储就是使用数组来存储</p><p>2）链式存储的二叉树节点的定义方式：</p><p>Java代码</p><pre><code class="java"> public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode() &#123;&#125;    TreeNode(int val) &#123; this.val = val; &#125;    TreeNode(int val, TreeNode left, TreeNode right) &#123;        this.val = val;        this.left = left;        this.right = right;    &#125;&#125;</code></pre><h2 id="二、二叉树的递归遍历"><a href="#二、二叉树的递归遍历" class="headerlink" title="二、二叉树的递归遍历"></a>二、二叉树的递归遍历</h2><blockquote><p>看看这是不是你？</p><p>看递归算法“一看就会，一写就废”</p><p>主要是对递归不成体系，没有方法论，<strong>每次写递归代码都是靠玄学，代码能否AC纯靠运气</strong></p></blockquote><p><strong>递归方法</strong></p><ol><li><p><strong>确定递归函数的参数和返回值</strong><br>确定哪些参数是递归的过程中需要处理的，那么就在递归里加上这个参数，并且还要明确每次递归的返回值进而确定递归函数的返回类型</p></li><li><p><strong>确定终止条件</strong></p><p>写完了递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈来保存每一层递归的信息，如果递归没有终止，操作系统的内存必然就会溢出</p></li><li><p><strong>确定单层递归的逻辑</strong><br>确定每一层递归需要处理的信息，在这里也就会重复调用来实现递归的过程</p></li></ol><p>【例子】二叉树的前、中、后序遍历</p><blockquote><ul><li><strong><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></strong></li><li><strong><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></strong></li><li><strong><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></strong></li></ul></blockquote><ol><li><p>确定递归函数的参数和返回值<br>因为要打印出前序遍历结点的数值，所以参数里面需要传入<code>List</code>存放结点的值，除了这一点就不需要再处理数据了，也不需要有返回值，所以递归函数的返回值类型就是<code>void</code></p><pre><code class="java">void traversal(TreeNode cur, List&lt;Integer&gt; res);</code></pre></li><li><p>确定终止条件<br>在递归的过程中，当前遍历的节点为空，本层的递归就结束了。所以如果当前遍历的这个结点为空，就直接<code>return</code></p><pre><code class="java">if(cur == null) return;</code></pre></li><li><p>确定单层遍历的逻辑<br>前序遍历是<strong>中左右</strong>的顺序，所以在单层递归的逻辑中，是要先取中间节点的数值</p><pre><code class="java">res.add(cur.val); // 中traversal(cur.left, res); // 左traversal(cur.right, res); // 右</code></pre></li></ol><p>前序遍历：</p><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();        traversal(root, res);        return res;    &#125;    private void traversal(TreeNode cur, List&lt;Integer&gt; res) &#123;        if(cur == null) return;        res.add(cur.val); // 中        traversal(cur.left, res); // 左        traversal(cur.right, res); // 右    &#125;&#125;</code></pre><p>对应的，中序遍历和后序遍历</p><p>中序遍历：</p><pre><code class="java"> private void traversal(TreeNode cur, List&lt;Integer&gt; res) &#123;     if(cur == null) return;     traversal(cur.left, res); // 左     res.add(cur.val); // 中     traversal(cur.right, res); // 右 &#125;</code></pre><p>后序遍历：</p><pre><code class="java"> private void traversal(TreeNode cur, List&lt;Integer&gt; res) &#123;     if(cur == null) return;     traversal(cur.left, res); // 左     traversal(cur.right, res); // 右     res.add(cur.val); // 中 &#125;</code></pre><h2 id="三、二叉树的迭代遍历"><a href="#三、二叉树的迭代遍历" class="headerlink" title="三、二叉树的迭代遍历"></a>三、二叉树的迭代遍历</h2><blockquote><p>为什么可以用迭代法（非递归的方式）来实现二叉树的前中后序遍历呢？</p><p><strong>递归的实现就是：每⼀次递归调⽤都会 把函数的局部变量、参数值和返回地址等压⼊调⽤栈中</strong>，然后递归返回的时候，从栈顶弹出上⼀次递归的各项参数，所以这就是递归为什么可以返回上⼀层位置的原因</p></blockquote><h3 id="1、前序遍历（迭代法）"><a href="#1、前序遍历（迭代法）" class="headerlink" title="1、前序遍历（迭代法）"></a>1、前序遍历（迭代法）</h3><p>前序遍历是中左右，每次先处理的是中间结点，那么先将根结点放入栈中，然后将右节点加入栈，再加入左节点</p><blockquote><p>为什么要先加入右节点，再加入左节点呢？</p><p>因为这样在加入结果列表的时候才是中左右的顺序</p></blockquote><p>【代码实现】（<strong>注意中间结点为空不入栈</strong>）</p><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        // 根结点入栈        stack.push(root);        while(!stack.isEmpty()) &#123;            TreeNode cur = stack.pop();            // 加入结果集合            ans.add(cur.val);            // 空节点不入栈            // 右节点入栈（后出栈）            if(cur.right != null) &#123;                stack.push(cur.right);            &#125;             // 左节点入栈（先于右节点出栈）            if(cur.left != null) &#123;                stack.push(cur.left);            &#125;         &#125;        return ans;    &#125;&#125;</code></pre><h3 id="2、中序遍历（迭代法）"><a href="#2、中序遍历（迭代法）" class="headerlink" title="2、中序遍历（迭代法）"></a>2、中序遍历（迭代法）</h3><blockquote><p>上述迭代过程有两个操作</p><ul><li>处理：将元素放入 ans 集合</li><li>访问： 遍历结点</li></ul></blockquote><p>分析下为什么迭代法的前序遍历代码不能和中序遍历通用呢？</p><p>因为前序遍历的顺序是中左右，先访问的节点是中间结点，先处理的节点也是中间结点，所以才能写出相对简洁的代码，因为<strong>要访问的节点和要处理的节点是一致的，都是中间结点</strong></p><p>再看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左边的最底部，再开始处理节点（也就是再把节点的数值存入ans集合中），这就<strong>造成了访问节点的顺序和处理节点的顺序不一致</strong></p><p>所以在使用迭代法写中序遍历的时候，就需要借助指针的遍历来帮助访问节点，栈则用来处理节点上的元素</p><p>动画展示（看官方题解）：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode）</a></p><p>【代码实现】</p><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        TreeNode cur = root;        while(cur != null || !stack.isEmpty()) &#123;            if(cur != null) &#123;                // 指针遍历                stack.push(cur); // 访问的节点入栈                cur = cur.left; // 左            &#125; else &#123;                cur = stack.pop(); // 处理节点                ans.add(cur.val); // 中                cur = cur.right; // 右            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="3、后序遍历（迭代法）"><a href="#3、后序遍历（迭代法）" class="headerlink" title="3、后序遍历（迭代法）"></a>3、后序遍历（迭代法）</h3><p>前序遍历是中左右，后序遍历是左右中，那么只需要调整下前序遍历的代码顺序，就变成了中右左的遍历顺序，然后再反转ans集合，输出的结果顺序就是左右中了</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221222103148.png"></p><p>【代码实现】</p><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        // 根结点入栈        stack.push(root);        while(!stack.isEmpty()) &#123;            TreeNode cur = stack.pop();            // 加入结果集合            ans.add(cur.val);            // 空节点不入栈            // 左节点入栈（后出栈）            if(cur.left != null) &#123;                stack.push(cur.left);            &#125;             // 右节点入栈（先于左节点出栈）            if(cur.right != null) &#123;                stack.push(cur.right);            &#125;         &#125;        // 反转ans集合        Collections.reverse(ans);        return ans;    &#125;&#125;</code></pre><h2 id="四、二叉树的统一迭代法"><a href="#四、二叉树的统一迭代法" class="headerlink" title="四、二叉树的统一迭代法"></a>四、二叉树的统一迭代法</h2><blockquote><p>迭代法实现的先中后序，其实风格也不是那么统⼀，除了先序和后序，有关 联，中序完全就是另⼀个风格了，⼀会⽤栈遍历，⼀会又⽤指针来遍历</p><p>⽆法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不⼀致的情况</p></blockquote><p><strong>解决方案</strong>：将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记（要处理的节点放入栈后，紧接着放入一个空指针作为标记）</p><h3 id="1、迭代法中序遍历"><a href="#1、迭代法中序遍历" class="headerlink" title="1、迭代法中序遍历"></a>1、迭代法中序遍历</h3><p>中序遍历Java代码：</p><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while(!stack.isEmpty()) &#123;            TreeNode cur = stack.pop();            if(cur != null) &#123;                // 添加右节点                if(cur.right != null) &#123;                    stack.push(cur.right);                &#125;                // 添加中间结点                stack.push(cur);                // 添加标记，表明中间结点访问过但是尚未处理                stack.push(null);                // 添加左节点                if(cur.left != null) &#123;                    stack.push(cur.left);                &#125;            &#125; else &#123;                // 当前弹出栈的节点为空节点，将此时栈顶元素弹出 加入结果集                cur = stack.pop();                ans.add(cur.val);            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="2、迭代法的前序遍历"><a href="#2、迭代法的前序遍历" class="headerlink" title="2、迭代法的前序遍历"></a>2、迭代法的前序遍历</h3><p>前序遍历Java代码：（和中序遍历相比，只改变两行代码的顺序）</p><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while(!stack.isEmpty()) &#123;            TreeNode cur = stack.pop();            if(cur != null) &#123;                // 添加右节点                if(cur.right != null) &#123;                    stack.push(cur.right);                &#125;                // 添加左节点                if(cur.left != null) &#123;                    stack.push(cur.left);                &#125;                // 添加中间结点                stack.push(cur);                // 添加标记，表明中间结点访问过但是尚未处理                stack.push(null);                            &#125; else &#123;                // 当前弹出栈的节点为空节点，将此时栈顶元素弹出 加入结果集                cur = stack.pop();                ans.add(cur.val);            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="3、迭代法的后序遍历"><a href="#3、迭代法的后序遍历" class="headerlink" title="3、迭代法的后序遍历"></a>3、迭代法的后序遍历</h3><p>后序遍历Java代码：（和中序遍历相比，只改变两行代码的顺序）</p><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;         List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while(!stack.isEmpty()) &#123;            TreeNode cur = stack.pop();            if(cur != null) &#123;                // 添加中间结点                stack.push(cur);                // 添加标记，表明中间结点访问过但是尚未处理                stack.push(null);                // 添加右节点                if(cur.right != null) &#123;                    stack.push(cur.right);                &#125;                // 添加左节点                if(cur.left != null) &#123;                    stack.push(cur.left);                &#125;            &#125; else &#123;                // 当前弹出栈的节点为空节点，将此时栈顶元素弹出 加入结果集                cur = stack.pop();                ans.add(cur.val);            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><blockquote><p>统一迭代法的关键就是<strong>加标记的时机</strong>，代码不好理解，但是风格统一</p></blockquote><h2 id="五、二叉树的层序遍历"><a href="#五、二叉树的层序遍历" class="headerlink" title="五、二叉树的层序遍历"></a>五、二叉树的层序遍历</h2><h3 id="102、二叉树的层序遍历"><a href="#102、二叉树的层序遍历" class="headerlink" title="102、二叉树的层序遍历"></a>102、二叉树的层序遍历</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a>**</p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1.jpg" alt="img"></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>层序遍历一颗二叉树，就是从左到右一层一层的去遍历二叉树</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e.jpg" alt="二叉树的层序遍历"></p><p>需要借助一个辅助数据结构<strong>队列</strong>来实现，<strong>队列FIFO，符合一层一层遍历的逻辑</strong>，而使用栈LIFO的特点，适合模拟深度优先遍历也就是递归的逻辑</p><p>而这种<strong>层序遍历方式就是图论中的广度优先遍历</strong>，只不过应用在二叉树上</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/2elr5.gif"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            List&lt;Integer&gt; levelList = new ArrayList&lt;&gt;();            // 这⾥⼀定要使⽤固定⼤⼩size，不要使⽤seen.size()，因为队列大小是不断变化的            int currentLevelSize = seen.size();            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                levelList.add(cur.val);                // 先加入左节点，因为先进先出，层序遍历是从左到右                if(cur.left != null) &#123;                    seen.offer(cur.left);                &#125;                if(cur.right != null) &#123;                    seen.offer(cur.right);                &#125;            &#125;            ans.add(levelList);        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="107、二叉树的层序遍历II"><a href="#107、二叉树的层序遍历II" class="headerlink" title="107、二叉树的层序遍历II"></a>107、二叉树的层序遍历II</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II - 力扣（LeetCode）</a>**</p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16717597254843.jpg" alt="img"></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>相较于**<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a>**，其实就是把最后的结果反转就可以了</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            List&lt;Integer&gt; levelList = new ArrayList&lt;&gt;();            int currentLevelSize = seen.size();            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                levelList.add(cur.val);                if(cur.left != null) seen.offer(cur.left);                if(cur.right != null) seen.offer(cur.right);            &#125;            ans.add(levelList);        &#125;        // 反转结果集        Collections.reverse(ans);        return ans;    &#125;&#125;</code></pre><h3 id="199、二叉树的右视图"><a href="#199、二叉树的右视图" class="headerlink" title="199、二叉树的右视图"></a>199、二叉树的右视图</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>题目链接：给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree.jpg" alt="img"></p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1,3,4]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [1,null,3]输出: [1,3]</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: []输出: []</code></pre><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>层序遍历的时候，判断是否遍历到单层最后的元素，如果是，就加入结果</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                if(cur.left != null) seen.offer(cur.left);                if(cur.right != null) seen.offer(cur.right);                // 判断是否是当前层的最后一个元素                if(i == (currentLevelSize - 1)) ans.add(cur.val);            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="637、二叉树的层平均值"><a href="#637、二叉树的层平均值" class="headerlink" title="637、二叉树的层平均值"></a>637、二叉树的层平均值</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值 - 力扣（LeetCode）</a>**</p><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10-5</code> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/avg1-tree.jpg" alt="img"></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[3.00000,14.50000,11.00000]解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。</code></pre><p><strong>示例 2:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/avg2-tree.jpg" alt="img"></p><pre><code>输入：root = [3,9,20,15,7]输出：[3.00000,14.50000,11.00000]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数量在 [1, 10^4^] 范围内</li><li>-2^31^ &lt;&#x3D; Node.val &lt;&#x3D; 2^31^ - 1</li></ul><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>本题就是在层序遍历的时候把一层的节点数值求总和之后在取平均值</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;        List&lt;Double&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            // 统计每一层的数值和            double sum = 0;            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                sum += cur.val;                if(cur.left != null) seen.offer(cur.left);                if(cur.right != null) seen.offer(cur.right);            &#125;               // 将每一层的均值放入结果集            ans.add(sum / currentLevelSize);        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="429、N叉树的层序遍历"><a href="#429、N叉树的层序遍历" class="headerlink" title="429、N叉树的层序遍历"></a>429、N叉树的层序遍历</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历 - 力扣（LeetCode）</a>**</p><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/narytreeexample.png" alt="img"></p><pre><code>输入：root = [1,null,3,2,4,null,5,6]输出：[[1],[3,2,4],[5,6]]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/sample_4_964.png" alt="img"></p><pre><code>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</code></pre><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>思路和上述几题类似，只不过一个节点存在多个子节点</p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Queue&lt;Node&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            List&lt;Integer&gt; levelList = new ArrayList&lt;&gt;();            int currentLevelSize = seen.size();            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                Node cur = seen.poll();                levelList.add(cur.val);                List&lt;Node&gt; childrenList = cur.children;                for(Node children : childrenList) &#123;                    seen.offer(children);                &#125;            &#125;            ans.add(levelList);        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="515、在每个树行中找最大值"><a href="#515、在每个树行中找最大值" class="headerlink" title="515、在每个树行中找最大值"></a>515、在每个树行中找最大值</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>题目链接：**<a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值 - 力扣（LeetCode）</a>**</p><p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p><p><strong>示例1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/largest_e1.jpg" alt="img"></p><pre><code>输入: root = [1,3,2,5,3,null,9]输出: [1,3,9]</code></pre><p><strong>示例2：</strong></p><pre><code>输入: root = [1,2,3]输出: [1,3]</code></pre><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 [0,10^4^]</li><li>-2^31^ &lt;&#x3D; Node.val &lt;&#x3D; 2^31^ - 1</li></ul><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>层序遍历，取每层最大值</p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if(root == null) return ans;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            int maxVal = Integer.MIN_VALUE;            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                if(maxVal &lt; cur.val) maxVal = cur.val;                if(cur.left != null) seen.offer(cur.left);                if(cur.right != null) seen.offer(cur.right);            &#125;            ans.add(maxVal);        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="116、填充每个节点的下一个右侧节点指针"><a href="#116、填充每个节点的下一个右侧节点指针" class="headerlink" title="116、填充每个节点的下一个右侧节点指针"></a>116、填充每个节点的下一个右侧节点指针</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）</a>**</p><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre><code>struct Node &#123;  int val;  Node *left;  Node *right;  Node *next;&#125;</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>null</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>null</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/116_sample.png" alt="img"></p><pre><code>输入：root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 2^12 - 1]</code> 范围内</li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>本题依然是层序遍历，只不过在单层遍历的时候记录下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了</p><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public Node connect(Node root) &#123;        if(root == null) &#123;            return root;        &#125;        Queue&lt;Node&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            Node cur = null;            Node pre = null;            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                if(i == 0) &#123;                    // 记录每层的头节点                    pre = seen.poll();                    cur = pre;                &#125; else &#123;                    cur = seen.poll();                    // 本层前一个的节点的next指向本节点                    pre.next = cur;                    pre = pre.next;                &#125;                if(cur.left != null) seen.offer(cur.left);                if(cur.right != null) seen.offer(cur.right);            &#125;            // 本层的最后一个节点指向null            pre.next = null;         &#125;        return root;    &#125;&#125;</code></pre><h3 id="117、填充每个节点的下一个右侧节点指针II"><a href="#117、填充每个节点的下一个右侧节点指针II" class="headerlink" title="117、填充每个节点的下一个右侧节点指针II"></a>117、填充每个节点的下一个右侧节点指针II</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）</a>**</p><p>给定一个二叉树</p><pre><code>struct Node &#123;  int val;  Node *left;  Node *right;  Node *next;&#125;</code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>null</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>null</code>。</p><p><strong>示例：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/117_sample.png" alt="img"></p><pre><code>输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#39;#&#39; 表示每层的末尾</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数小于 <code>6000</code></li><li><code>-100 &lt;= node.val &lt;= 100</code></li></ul><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>这道题⽬说是⼆叉树，但116题⽬说是完整⼆叉树，其实没有任何差别，⼀样的代码⼀样的逻辑⼀样的味道</p><h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public Node connect(Node root) &#123;        if(root == null) return root;        Queue&lt;Node&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            Node cur = null;            Node pre = null;            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                if(i == 0) &#123;                    pre = seen.poll();                    cur = pre;                &#125; else &#123;                    cur = seen.poll();                    pre.next = cur;                    pre = pre.next;                &#125;                if(cur.left != null) seen.offer(cur.left);                if(cur.right != null) seen.offer(cur.right);            &#125;            pre.next = null;        &#125;        return root;    &#125;&#125;</code></pre><h2 id="六、二叉树的翻转"><a href="#六、二叉树的翻转" class="headerlink" title="六、二叉树的翻转"></a>六、二叉树的翻转</h2><h3 id="226、翻转二叉树"><a href="#226、翻转二叉树" class="headerlink" title="226、翻转二叉树"></a>226、翻转二叉树</h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode）</a>**</p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/invert1-tree.jpg" alt="img"></p><pre><code>输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/invert2-tree.jpg" alt="img"></p><pre><code>输入：root = [2,1,3]输出：[2,3,1]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><blockquote><p>题外话</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4ODE1MTQwNg==&mid=2247484027&idx=1&sn=08a3989aaa9fca824781e111b7566a19&chksm=ebc3807adcb4096cda22285cd9f6e74e1dad46937e7ef3388ed48b388f37ee3e8b8babcab41c&scene=27">如何看待 Max Howell 被 Google 拒绝？ (qq.com)</a></p></blockquote><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>如果要从整棵树来看，翻转挺复杂，整个树以中间分割线进⾏翻转<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221223105113815.png" alt="image-20221223105113815"></p><p>可以发现想要翻转它，其实就是把每一个节点的左右孩子交换一下就可以了</p><p><strong>关键在于遍历顺序</strong>，遍历的过程中去反转每一个节点的左右孩⼦就可以达到整体翻转的效果。 <strong>注意只要把每⼀个节点的左右孩⼦翻转⼀次，就可以达到整体翻转的效果</strong></p><blockquote><p>这道题⽬使⽤前序遍历和后序遍历都可以，唯独中序遍历不⾏，因为中序遍历会把某些节点 的左右孩⼦翻转了两次！建议拿纸画⼀画，就理解了</p><p>那么层序遍历可以不可以呢？依然可以的！只要把每⼀个节点的左右孩⼦翻转⼀下的遍历⽅ 式都是可以的</p></blockquote><p>&#x3D;&gt; 前序遍历 || 后序遍历 || 层序遍历</p><p>动画演示：<a href="https://leetcode.cn/problems/invert-binary-tree/solution/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua/">动画演示 两种实现 226. 翻转二叉树 - 翻转二叉树 - 力扣（LeetCode）</a></p><h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><p>递归三部曲：</p><ol><li><p>确定递归函数的参数和返回值<br>参数就是要传⼊节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归 的逻辑中发现还需要其他参数的时候，随时补充。<br>返回值的话其实也不需要，但是题⽬中给出的要返回root节点的指针，可以直接使⽤题⽬定义好的函数，所以就函数的返回类型为<code>TreeNode</code></p><pre><code class="java">TreeNode invertTree(TreeNode root);</code></pre></li><li><p>确定终止条件<br>当前节点为空时，就返回</p><pre><code class="java">if(root == null) return root;</code></pre></li><li><p>确定单层遍历的逻辑</p><blockquote><p>这里采用前序遍历</p></blockquote><p>先进行交换左右孩子节点，然后翻转左子树，再翻转右子树</p><pre><code class="java">TreeNode tempNode = root.left;root.left = root.right;root.right = tempNode;invertTree(root.left);invertTree(root.right);</code></pre></li></ol><h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p><strong>深度优先遍历</strong></p><p>递归 &#x3D;&#x3D;&gt; 栈实现</p><p><strong>广度优先遍历</strong></p><p>层序遍历，翻转每一个节点的左右节点</p><h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><h5 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h5><p>Java代码：</p><pre><code class="java">class Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if(root == null) return null;        TreeNode tempNode = root.left;        root.left = root.right;        root.right = tempNode;        invertTree(root.left);        invertTree(root.right);        return root;    &#125;&#125;</code></pre><h5 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h5><p><strong>深度优先遍历</strong></p><p>前序遍历</p><pre><code class="java">class Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if(root == null) return root;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while(!stack.isEmpty()) &#123;            // 中间结点            TreeNode cur = stack.pop();             TreeNode tempNode = cur.left;            cur.left = cur.right;            cur.right = tempNode;            // 右节点            if(cur.right != null) stack.push(cur.right);            // 左节点            if(cur.left != null) stack.push(cur.left);        &#125;        return root;    &#125;&#125;</code></pre><p>统一迭代法的前序遍历</p><pre><code class="java">class Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if(root == null) return root;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while(!stack.isEmpty()) &#123;            TreeNode cur = stack.pop();             if(cur != null) &#123;                // 右节点                if(cur.right != null) stack.push(cur.right);                // 左节点                if(cur.left != null) stack.push(cur.left);                // 中间结点                stack.push(cur);                stack.push(null);            &#125; else &#123;                cur = stack.pop();                // 处理节点逻辑                TreeNode tempNode = cur.left;                cur.left = cur.right;                cur.right = tempNode;            &#125;        &#125;        return root;    &#125;&#125;</code></pre><p><strong>广度优先遍历</strong></p><pre><code class="java">class Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if(root == null) return root;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                TreeNode tempNode = cur.left;                cur.left = cur.right;                cur.right = tempNode;                if(cur.left != null) &#123;                    seen.offer(cur.left);                &#125;                if(cur.right != null) &#123;                    seen.offer(cur.right);                &#125;            &#125;        &#125;        return root;    &#125;&#125;</code></pre><h2 id="七、对称二叉树"><a href="#七、对称二叉树" class="headerlink" title="七、对称二叉树"></a>七、对称二叉树</h2><h3 id="101、对称二叉树"><a href="#101、对称二叉树" class="headerlink" title="101、对称二叉树"></a>101、对称二叉树</h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树 - 力扣（LeetCode）</a>**</p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/symtree1.jpg" alt="img"></p><pre><code>输入：root = [1,2,2,3,4,4,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/symtree2-16718438677105.jpg" alt="img"></p><pre><code>输入：root = [1,2,2,null,3,null,3]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>首先想清楚，判断对称二叉树要比较的是那两个节点，要比较的可不是左右节点！</p><p>对于二叉树是否对称，要比较的是根结点的左子树和右子树是否是相互翻转的，理解这一点就知道了其实我们要比较的是两棵树（根结点的左右子树），所以在递归遍历的时候，也是要同时遍历两棵树</p><p><strong>比较的是两颗子树的里侧和外侧是否相等</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221224091409762.png" alt="image-20221224091409762"></p><p><strong>遍历顺序</strong></p><p>本题只能是<strong>后序遍历</strong>，因为我们要递归函数的返回值来判断两颗子树的内侧节点和外侧节点是否相等</p><p>正是因为要遍历两棵树而且是要比较内侧和外侧节点，所以准确的来说是其中一棵树的遍历顺序是<strong>左右中</strong>，另一棵树的遍历顺序是<strong>右左中</strong></p><blockquote><p>上述两种遍历方式都可以理解成后序遍历，尽管已经不是严格上的在一棵树上进行遍历的后序遍历</p><p>其实后序也可以理解成一种回溯</p></blockquote><h5 id="（1）递归法"><a href="#（1）递归法" class="headerlink" title="（1）递归法"></a>（1）递归法</h5><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值<br>因为要比较的是根结点的两颗子树是否是可以相互翻转的，进而判断这两颗树是否是对称树，所以要比较的是这两棵树，参数自然也是左子树节点和右子树节点<br>返回值自然是<code>boolean</code>类型</p><pre><code class="java">boolean compare(TreeNode left, TreeNode right);</code></pre></li><li><p>确定终止条件<br>要比较两个节点数值相不相同，首先要把两个节点为空的情况搞清楚，否侧后面操作数值的时候就会NPE了</p><p>节点为空的情况有：</p><ul><li>左节点为空，右节点不为空，不对称 &#x3D;&gt; <code>return false</code></li><li>左节点不为空，右节点为空，不对称  &#x3D;&gt; <code>return false</code></li><li>左右节点都为空，对称 &#x3D;&gt; <code>return true</code></li></ul><p>节点不为空的情况，比较节点数值，不相同 &#x3D;&gt; <code>return false</code></p><pre><code class="java">// 空节点的情况// 1.左右节点都为空if(left == null &amp;&amp; right == null) return true;// 2.左右节点只有一个为空if(left == null || right == null) return false;// 数值不相等的情况if(left.val != right.val) return false;</code></pre></li><li><p>单层递归的逻辑</p><p>单层递归的逻辑就是处理左右节点都不为空，且数值相同的情况</p><ul><li>比较二叉树外侧是否对称：传入的是左子树的左节点和右子树的右节点</li><li>比较内侧是否对称：传入的是左子树的右节点和右子树的左节点</li><li>如果内侧和外侧都对称就<code>return true</code>，只要有一侧不对称就<code>return false</code></li></ul><pre><code class="java">// 左右节点都不为空，数值相等的情况// 外侧：左子树的左节点， 右子树的右节点boolean outside = compare(left.left, right.right);// 内侧：左子树的右节点， 右子树的左节点boolean inside = compare(left.right, right.left);// 返回true的情况是 外侧和内侧都要对称return outside &amp;&amp; inside;</code></pre></li></ol><h5 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="(2) 迭代法"></a>(2) 迭代法</h5><blockquote><p>本题也可以使⽤迭代法，但要注意，这⾥的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓⼆叉树遍历的前中后序的关系了</p></blockquote><p><strong>使用队列</strong></p><p>具体动画演示：**<a href="https://leetcode.cn/problems/symmetric-tree/solution/101-dui-cheng-er-cha-shu-di-gui-fa-die-dai-fa-xian/">「代码随想录」101. 对称二叉树:【递归法】【迭代法】详解！ - 对称二叉树 - 力扣（LeetCode）</a>**</p><p><strong>使用栈</strong></p><p>和使用队列同理，迭代法其实就是把左右子树要比较的元素按照顺序存入一个容器，然后成对的取出来比较</p><h4 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h4><h5 id="（1）递归法-1"><a href="#（1）递归法-1" class="headerlink" title="（1）递归法"></a>（1）递归法</h5><p>Java代码</p><pre><code class="java">class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        if(root == null) return true;        return compare(root.left, root.right);    &#125;    private boolean compare(TreeNode left, TreeNode right) &#123;        // 空节点的情况        // 1.左右节点都为空        if(left == null &amp;&amp; right == null) return true;        // 2.左右节点只有一个为空        if(left == null || right == null) return false;        // 数值不相等的情况        if(left.val != right.val) return false;        // 左右节点不空并且数值相等        return compare(left.left, right.right) &amp;&amp; compare(left.right, right.left);    &#125;&#125;</code></pre><h5 id="（2）迭代法"><a href="#（2）迭代法" class="headerlink" title="（2）迭代法"></a>（2）迭代法</h5><p><strong>使用队列</strong></p><pre><code class="java">class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        if(root == null) return true;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        // 加入根结点的左右节点        queue.offer(root.left);        queue.offer(root.right);        // 判断两颗子树是否相互翻转        while(!queue.isEmpty()) &#123;            TreeNode leftNode = queue.poll();            TreeNode rightNode = queue.poll();            // 左右节点都为空            if(leftNode == null &amp;&amp; rightNode == null) continue;            // 左右节点有一个不空 或者 数值不等            if(leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;            // 判断外侧            queue.offer(leftNode.left);            queue.offer(rightNode.right);            // 判断内侧            queue.offer(leftNode.right);            queue.offer(rightNode.left);        &#125;        return true;    &#125;&#125;</code></pre><p><strong>使用栈</strong></p><p>相较于使用栈，仅仅换了一个容器和对应API</p><pre><code class="java">class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        if(root == null) return true;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        // 加入根结点的左右节点        stack.push(root.left);        stack.push(root.right);        // 判断两颗子树是否相互翻转        while(!stack.isEmpty()) &#123;            TreeNode leftNode = stack.pop();            TreeNode rightNode = stack.pop();            // 左右节点都为空            if(leftNode == null &amp;&amp; rightNode == null) continue;            // 左右节点有一个不空 或者 数值不等            if(leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;            // 判断外侧            stack.push(leftNode.left);            stack.push(rightNode.right);            // 判断内侧            stack.push(leftNode.right);            stack.push(rightNode.left);        &#125;        return true;    &#125;&#125;</code></pre><h2 id="八、二叉树的深度"><a href="#八、二叉树的深度" class="headerlink" title="八、二叉树的深度"></a>八、二叉树的深度</h2><h3 id="104、二叉树的最大深度"><a href="#104、二叉树的最大深度" class="headerlink" title="104、二叉树的最大深度"></a>104、二叉树的最大深度</h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a>**</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回它的最大深度 3 。</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><h5 id="（1）递归法-2"><a href="#（1）递归法-2" class="headerlink" title="（1）递归法"></a>（1）递归法</h5><p>本题依然是要后序遍历，因为要通过递归函数的返回值来计算树的高度</p><p>递归三部曲：</p><ol><li><p>确定递归函数的参数和返回值</p><p>参数就是传入树的根结点，返回就是这棵树的深度，所以返回值为<code>int</code>类型</p><pre><code class="java">int getDepth(TreeNode cur);</code></pre></li><li><p>确定终止条件</p><p>如果当前为空节点的话，就返回0，表示高度为0</p><pre><code class="java">if(cur == null) return 0;</code></pre></li><li><p>确定单层递归的逻辑</p><p>先求它的左子树的深度，再求它的右子树的深度，最后取左右子树的较大深度数值再加一（加一是因为算上当前中间的节点）就是以当前节点为根结点的树的深度</p><pre><code class="java">int leftDepth = maxDepth(root.left);int rightDepth = maxDepth(root.right);int curDepth = Math.max(leftDepth, rightDepth) + 1;return curDepth;</code></pre></li></ol><h5 id="（2）迭代法-1"><a href="#（2）迭代法-1" class="headerlink" title="（2）迭代法"></a>（2）迭代法</h5><p>使用迭代法的话，使用层序遍历是最合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式及其相似</p><p>在⼆叉树中，⼀层⼀层的来遍历⼆叉树，记录⼀下遍历的层数就是⼆叉树的深度，如图所示：</p><p><img src="E:/MyFile/TyporaImgs/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e-16718480808477.jpg" alt="二叉树的层序遍历"></p><p>所以这道题的迭代法就是⼀道模板题，可以使⽤⼆叉树层序遍历的模板来解决的。</p><h4 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h4><h5 id="（1）递归法-3"><a href="#（1）递归法-3" class="headerlink" title="（1）递归法"></a>（1）递归法</h5><pre><code class="java">class Solution &#123;    public int maxDepth(TreeNode root) &#123;        if(root == null) return 0;        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;    &#125;&#125;</code></pre><h5 id="（2）迭代法-2"><a href="#（2）迭代法-2" class="headerlink" title="（2）迭代法"></a>（2）迭代法</h5><pre><code class="java">class Solution &#123;    public int maxDepth(TreeNode root) &#123;        if(root == null) return 0;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        int depth = 0;        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            depth++;            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                if(cur.left != null) seen.offer(cur.left);                if(cur.right != null) seen.offer(cur.right);            &#125;        &#125;        return depth;    &#125;&#125;</code></pre><h5 id="（3）栈模拟后序遍历"><a href="#（3）栈模拟后序遍历" class="headerlink" title="（3）栈模拟后序遍历"></a>（3）栈模拟后序遍历</h5><pre><code class="java">class Solution &#123;    public int maxDepth(TreeNode root) &#123;         if(root == null) return 0;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        int depth = 0;        int ans = 0;        while(!stack.isEmpty()) &#123;            TreeNode cur = stack.pop();            if(cur != null) &#123;                // 中                stack.push(cur);                stack.push(null);                depth++;                // 右                if(cur.right != null) stack.push(cur.right);                // 左                if(cur.left != null) stack.push(cur.left);            &#125; else &#123;                cur = stack.pop();                depth--;            &#125;            ans = ans &gt; depth ? ans : depth;        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="559、N叉树的最大深度"><a href="#559、N叉树的最大深度" class="headerlink" title="559、N叉树的最大深度"></a>559、N叉树的最大深度</h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度 - 力扣（LeetCode）</a>**</p><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/narytreeexample-16718483757259.png" alt="img"></p><pre><code>输入：root = [1,null,3,2,4,null,5,6]输出：3</code></pre><p><strong>示例 2：</strong></p><p><img src="E:/MyFile/TyporaImgs/sample_4_964-167184839720711.png" alt="img"></p><pre><code>输入：root =[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：5</code></pre><p><strong>提示：</strong></p><ul><li>树的深度不会超过 <code>1000</code> 。</li><li>树的节点数目位于 <code>[0, 10^4]</code> 之间。</li></ul><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>思路跟二叉树的思路是一样的</p><h5 id="（1）递归法-4"><a href="#（1）递归法-4" class="headerlink" title="（1）递归法"></a>（1）递归法</h5><h5 id="（2）迭代法-3"><a href="#（2）迭代法-3" class="headerlink" title="（2）迭代法"></a>（2）迭代法</h5><h4 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h4><h5 id="（1）递归法-5"><a href="#（1）递归法-5" class="headerlink" title="（1）递归法"></a>（1）递归法</h5><pre><code class="java">class Solution &#123;    public int maxDepth(Node root) &#123;        if(root == null) return 0;        int depth = 0;        for(int i = 0; i &lt; root.children.size(); i++) &#123;            depth = Math.max(depth, maxDepth(root.children.get(i)));        &#125;        return depth + 1;    &#125;&#125;</code></pre><h5 id="（2）迭代法-4"><a href="#（2）迭代法-4" class="headerlink" title="（2）迭代法"></a>（2）迭代法</h5><pre><code class="java">class Solution &#123;    public int maxDepth(Node root) &#123;         if(root == null) return 0;        Queue&lt;Node&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        int depth = 0;        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            depth++;            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                Node cur = seen.poll();                for(int j = 0; j &lt; cur.children.size(); j++) &#123;                    Node node = cur.children.get(j);                    if(node != null) seen.offer(node);                &#125;            &#125;        &#125;        return depth;    &#125;&#125;</code></pre><hr><h3 id="111、二叉树的最小深度"><a href="#111、二叉树的最小深度" class="headerlink" title="111、二叉树的最小深度"></a>111、二叉树的最小深度</h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a>**</p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/ex_depth.jpg" alt="img"></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [2,null,3,null,4,null,5,null,6]输出：5</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 10^5]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题处理直觉上和**<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a>**差不多，但其实还是差不少的</p></blockquote><p>遍历顺序上依然是后序遍历，因为要比较递归函数返回的结果，但在处理中间结点的逻辑上，最大深度很容易理解，最小深度存在一个误区，</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221224104319753.png" alt="image-20221224104319753"></p><p>这里就要重新审题了，题目中说的是：<strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</strong>，注意是叶子结点</p><h5 id="（1）递归法-6"><a href="#（1）递归法-6" class="headerlink" title="（1）递归法"></a>（1）递归法</h5><p>递归三部曲</p><ol><li><p>确定递归函数的参数和返回值</p><p>参数为要传入的二叉树根结点，返回值是<code>int</code>类型的深度</p><pre><code class="java">int minDepth(TreeNode cur);</code></pre></li><li><p>确定终止条件</p><p>确定终止条件也是遇到空节点返回0，表示当前节点的高度为0</p><pre><code class="java">if(cur == null) return 0;</code></pre></li><li><p>确定单层递归的逻辑</p><blockquote><p>这里和求最大深度就不一样了。</p><pre><code class="java">int leftDepth = getDepth(cur.left);int rightDepth = getDepth(cur.right);int result = 1 + Math.min(leftDepth, rightDepth);return result;</code></pre><p>上述代码就犯了上图中的误区</p><p>如果这么求的话，没有左孩⼦的分⽀会算为最短深度</p></blockquote><p>如果左子树为空，右子树不空，说明最小深度是 <code>1 + 右子树的深度</code></p><p>反之右子树为空，左子树不空，说明最小深度是 <code>1 + 左子树的深度</code></p><p>如果左子树和右子树都不空，说明最小深度是<code>1 + 左右子树深度的较小值</code></p><pre><code class="java"> // 中// 左子树为空，右子树不空if(root.left != null &amp;&amp; root.right == null) &#123;    return 1 + leftDepth;&#125;// 左子树为空，右子树不空if(root.left == null &amp;&amp; root.right != null) &#123;    return 1 + rightDepth;&#125;// 左右子树都不空return Math.min(leftDepth, rightDepth) + 1;</code></pre><p>遍历的顺序为后序（左右中），可以看出：<strong>求⼆叉树的最⼩深度和求⼆叉树的最⼤深度的差 别主要在于处理左右孩⼦不为空的逻辑</strong></p></li></ol><h5 id="（2）迭代法-5"><a href="#（2）迭代法-5" class="headerlink" title="（2）迭代法"></a>（2）迭代法</h5><p>层序遍历，需要注意的是，只有当左右节点都为空时，才说明遍历到最低点了，如果其中一个节点不为空，则说明不是最低点</p><h4 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h4><h5 id="（1）递归法-7"><a href="#（1）递归法-7" class="headerlink" title="（1）递归法"></a>（1）递归法</h5><pre><code class="java">class Solution &#123;    public int minDepth(TreeNode root) &#123;        if (root == null) return 0;         // 中        // 左子树为空，右子树不空        if(root.left != null &amp;&amp; root.right == null) &#123;            return 1 + minDepth(root.left);         &#125;        // 左子树为空，右子树不空        if(root.left == null &amp;&amp; root.right != null) &#123;            return 1 + minDepth(root.right);        &#125;        // 左右子树都不空        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;    &#125;&#125;</code></pre><h5 id="（2）迭代法-6"><a href="#（2）迭代法-6" class="headerlink" title="（2）迭代法"></a>（2）迭代法</h5><pre><code class="java">class Solution &#123;    public int minDepth(TreeNode root) &#123;        if (root == null) return 0;         int depth = 0;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            depth++; // 记录最小深度            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                if(cur.left != null) seen.offer(cur.left);                if(cur.right != null) seen.offer(cur.right);                // 左右节点都为空                if(cur.left == null &amp;&amp; cur.right == null) return depth;            &#125;        &#125;        return depth;    &#125;&#125;</code></pre><h2 id="九、完全二叉树的节点个数"><a href="#九、完全二叉树的节点个数" class="headerlink" title="九、完全二叉树的节点个数"></a>九、完全二叉树的节点个数</h2><h3 id="222、完全二叉树的节点个数"><a href="#222、完全二叉树的节点个数" class="headerlink" title="222、完全二叉树的节点个数"></a>222、完全二叉树的节点个数</h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a>**</p><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2^h</code> 个节点。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/complete.jpg" alt="img"></p><pre><code>输入：root = [1,2,3,4,5,6]输出：6</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []输出：0</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1]输出：1</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是<code>[0, 5 * 10^4]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 10^4</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>本题按照<strong>普通二叉树</strong>的求法和利用<strong>完全二叉树</strong>性质求解</p><h5 id="1）普通二叉树"><a href="#1）普通二叉树" class="headerlink" title="1）普通二叉树"></a>1）普通二叉树</h5><blockquote><p>本题的递归法和求二叉树的深度写法类似</p><p>迭代法和层序遍历相似，遍历模板稍稍修改，记录遍历结点的数量就可以了</p></blockquote><p><strong>（1）递归法</strong></p><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值类型：参数就是传入树的根结点，返回就是以该节点为根结点的二叉树的节点数量，所以返回值类型为<code>int</code></p><pre><code class="java">int getNodesNum(TreeNode cur);</code></pre></li><li><p>确定终止条件：如果遇到空节点，就返回0，表示节点数为0</p><pre><code class="java">if(cur == null) return 0;</code></pre></li><li><p>确定单层递归的逻辑：先求以当前节点为根结点的树的左子树的节点数量，再求右子树的节点数量，最后取总和再加一（加一是因为要算上当前节点）就是以当前节点为根结点的节点数量</p><pre><code class="java">int leftNum = getNodesNum(cur.left); // 左int rightNum = getNodesNum(cur.right); // 右return leftNum + rightNum + 1; // 中</code></pre></li></ol><p><strong>（2）迭代法</strong></p><p>在模板遍历的基础上，加一个变量统计节点数量即可</p><h5 id="2）完全二叉树-1"><a href="#2）完全二叉树-1" class="headerlink" title="2）完全二叉树"></a>2）完全二叉树</h5><p>完全二叉树只有两种情况</p><ul><li>情况一：满二叉树</li><li>情况二：最后一层叶子结点没有满</li></ul><p>针对情况一：可以直接使用<code>2 ^ 树深度 - 1</code>来计算，注意这里根结点深度为1</p><p>针对情况二：分别递归左子树和右子树，递归到某一深度一定会有左子树或者右子树为满二叉树，然后依然可以按照情况一来计算</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221225102432115.png" alt="image-20221225102432115"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221225102713034.png" alt="image-20221225102713034"></p><p>可以看出如果整个树不是满二叉树，就递归左右子树直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量</p><h4 id="实现-13"><a href="#实现-13" class="headerlink" title="实现"></a>实现</h4><h5 id="1-普通二叉树"><a href="#1-普通二叉树" class="headerlink" title="1)  普通二叉树"></a>1)  普通二叉树</h5><p> <strong>（1）递归法</strong></p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(logn)，算上了递归系统栈占⽤的空间class Solution &#123;    public int countNodes(TreeNode root) &#123;        if(root == null) return 0;        return getNodesNum(root);    &#125;    private int getNodesNum(TreeNode cur) &#123;        if(cur == null) return 0;        int leftNum = getNodesNum(cur.left); // 左        int rightNum = getNodesNum(cur.right); // 右        return leftNum + rightNum + 1; // 中    &#125;&#125;</code></pre><p>精简版：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(logn)，算上了递归系统栈占⽤的空间class Solution &#123;    public int countNodes(TreeNode root) &#123;        if(root == null) return 0;        return 1 + countNodes(root.left) + countNodes(root.right);    &#125;&#125;</code></pre><p><strong>（2）迭代法</strong></p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int countNodes(TreeNode root) &#123;        if(root == null) return 0;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        int result = 0;        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                result++; // 记录节点数量                if(cur.left != null) &#123;                    seen.offer(cur.left);                &#125;                if(cur.right != null) &#123;                    seen.offer(cur.right);                &#125;            &#125;        &#125;        return result;    &#125;&#125;</code></pre><h5 id="2）完全二叉树-2"><a href="#2）完全二叉树-2" class="headerlink" title="2）完全二叉树"></a>2）完全二叉树</h5><pre><code class="java">// 时间复杂度：O(logn * logn)// 空间复杂度：O(logn)class Solution &#123;    public int countNodes(TreeNode root) &#123;        if(root == null) return 0;        TreeNode left = root.left;        TreeNode right = root.right;        // 这里初始化为0是为了下面求指数方便        int leftHight = 0;        int rightHight = 0;        // 求左子树深度        while(left != null) &#123;            left = left.left;            leftHight++;        &#125;        // 求右子树深度        while(right != null) &#123;            right = right.right;            rightHight++;        &#125;        if(leftHight == rightHight) &#123;            return (2 &lt;&lt; leftHight) - 1;        &#125;        return countNodes(root.left) + countNodes(root.right) + 1;    &#125;&#125;</code></pre><h2 id="十、平衡二叉树"><a href="#十、平衡二叉树" class="headerlink" title="十、平衡二叉树"></a>十、平衡二叉树</h2><h3 id="110、平衡二叉树"><a href="#110、平衡二叉树" class="headerlink" title="110、平衡二叉树"></a>110、平衡二叉树</h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（LeetCode）</a>**</p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/balance_1.jpg" alt="img"></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/balance_2.jpg" alt="img"></p><pre><code>输入：root = [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：true</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li></ul><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><blockquote><p>强调一波<strong>概念</strong></p><ul><li>二叉树节点的深度：指从根结点到该节点的最长简单路径边的条数</li><li>二叉树节点的高度：指从该节点到叶子结点的最长简单路径边的条数</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221225104213834.png" alt="image-20221225104213834"></p><p>因为求深度可以从上到下去查，所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）</p><p>至于在**<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a><strong>中求的是二叉树的最大深度，也是使用后序遍历，是因为</strong>代码逻辑其实是求的根结点的高度，而根结点的高度就是这棵树的最大深度，所以才可能使用后序遍历**</p><p>在**<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a>**中，如果真正求取二叉树的最大深度，代码应该写成如下（前序遍历）</p><pre><code class="java">class Solution &#123;    private int result;    private void getDepth(TreeNode node, int depth) &#123;        result = depth &gt; result ? depth : result; // 中        if (node.left == null &amp;&amp; node.right == null) return ;        if (node.left) &#123; // 左            depth++; // 深度+1            getDepth(node.left, depth);            depth--; // 回溯，深度-1        &#125;        if (node.right) &#123; // 右            depth++; // 深度+1            getDepth(node.right, depth);            depth--; // 回溯，深度-1        &#125;        return ;    &#125;    public int maxDepth(TreeNode root) &#123;        result = 0;        if (root == null) return result;        getDepth(root, 1);        return result;    &#125;&#125;;</code></pre><p>可以看出使用了前序遍历顺序，这才是真正求深度的逻辑！</p><p>简化下上述代码</p><pre><code class="java">class Solution &#123;    private int result;    private void getDepth(TreeNode node, int depth) &#123;        result = depth &gt; result ? depth : result; // 中        if (node.left == null &amp;&amp; node.right == null) return ;        if (node.left) &#123; // 左            getDepth(node.left, depth + 1);        &#125;        if (node.right) &#123; // 右            getDepth(node.right, depth + 1);        &#125;        return ;    &#125;    int maxDepth(TreeNode root) &#123;        result = 0;        if (root == null) return result;        getDepth(root, 1);        return result;    &#125;&#125;;</code></pre></blockquote><h5 id="1）递归"><a href="#1）递归" class="headerlink" title="1）递归"></a>1）递归</h5><p>既然要比较高度，必然是后序遍历</p><p>递归三部曲：</p><ol><li><p>确定递归函数的参数和返回值</p><p>参数为传入的节点指针，返回值要返回以传入节点为根结点的树的高度</p><p>那么如何标记左右子树的高度是否差值为1呢？</p><p>如果以当前传入节点为根结点的二叉树已经不是二叉树了，还返回高度的话就没有意义了，所以如果已经不是平衡二叉树了，可以返回<code>-1</code>来标识以当前传入节点为根结点的树已经不符合平衡树的规则了</p><pre><code class="java">// -1 表示已经不是平衡⼆叉树了，否则返回值是以该节点为根节点树的⾼度int getDepth(TreeNode cur);</code></pre></li><li><p>确定终止条件</p><p>递归过程中遇到空节点为终止，返回0，表示以当前节点为根结点的树的高度为0</p><pre><code class="java">if(cur == null) return 0;</code></pre></li><li><p>确定单层递归的逻辑</p><p>分别求出以当前节点为根结点的树的左右子树的高度，如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示不是平衡二叉树了</p><pre><code class="java">int leftDepth = getDepth(node.left); // 左if (leftDepth == -1) return -1;int rightDepth = getDepth(node.right); // 右if (rightDepth == -1) return -1;int result;if (Math.abs(leftDepth - rightDepth) &gt; 1) &#123; // 中     result = -1;&#125; else &#123;     result = 1 + Math.max(leftDepth, rightDepth); // 以当前节点为根节点的最⼤⾼度&#125;return result;</code></pre><p>精简代码：</p><pre><code class="java">int leftDepth = getDepth(node.left);if (leftDepth == -1) return -1;int rightDepth = getDepth(node.right);if (rightDepth == -1) return -1;return Math.abs(leftDepth - rightDepth) &gt; 1 ? -1 : 1 + Math.max(leftDepth,rightDepth);</code></pre></li></ol><h5 id="2）迭代法"><a href="#2）迭代法" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><blockquote><p>在**<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a>**中我们可以使用层序遍历求深度，但是就不能使用层序遍历来求高度，这就体现出求高度和求深度是不同的</p></blockquote><p>本题的迭代方式可以先定义一个函数，专门用来求高度</p><p>这个函数通过栈模拟后序遍历找每一个节点的高度（其实是通过求以传入节点为根结点的树的最大深度来求的高度）</p><pre><code class="java">// cur节点的最⼤深度，就是cur的⾼度private int getDepth(TreeNode cur) &#123;    Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();    if(cur != null) stack.push(cur);    int depth = 0; // 记录深度    int result = 0;    while(!stack.isEmpty()) &#123;        TreeNode node = stack.pop();        if (node != null) &#123;            stack.push(node); // 中            stack.push(null);            depth++;            if (node.right != null) stack.push(node.right); // 右            if (node.left != null) stack.push(node.left); // 左        &#125; else &#123;            node = stack.pop();            depth--;        &#125;        result = result &gt; depth ? result : depth;    &#125;    return result;&#125;</code></pre><p>然后再用栈来模拟前序遍历，遍历每一个节点的时候，再去判断左右子树的高度是否符合</p><pre><code class="java">public boolean isBalanced(TreeNode root) &#123;    if(root == null) return true;    Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();    stack.push(root);    while (!stack.isEmpty()) &#123;        TreeNode node = stack.pop(); // 中        if (Math.abs(getDepth(node.left) - getDepth(node.right)) &gt; 1) &#123; // 判断左右子树⾼度是否符合            return false;        &#125;        if (node.right != null) stack.push(node.right); // 右（空节点不⼊栈）        if (node.left != null) stack.push(node.left); // 左（空节点不⼊栈）    &#125;    return true;&#125;</code></pre><h4 id="实现-14"><a href="#实现-14" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法"><a href="#1）递归法" class="headerlink" title="1）递归法"></a>1）递归法</h5><pre><code class="java">class Solution &#123;    public boolean isBalanced(TreeNode root) &#123;        return getDepth(root) == -1 ? false : true;    &#125;    private int getDepth(TreeNode cur) &#123;        if(cur == null) return 0;        int leftDepth = getDepth(cur.left);        if(leftDepth == -1) return leftDepth;        int rightDepth = getDepth(cur.right);        if(rightDepth == -1) return rightDepth;        return Math.abs(leftDepth - rightDepth) &gt; 1 ? -1 : 1 + Math.max(leftDepth, rightDepth);    &#125;&#125;</code></pre><h5 id="2）迭代法-1"><a href="#2）迭代法-1" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public boolean isBalanced(TreeNode root) &#123;        if(root == null) return true;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while (!stack.isEmpty()) &#123;            TreeNode node = stack.pop(); // 中            if (Math.abs(getDepth(node.left) - getDepth(node.right)) &gt; 1) &#123; // 判断左右子树⾼度是否符合                return false;            &#125;            if (node.right != null) stack.push(node.right); // 右（空节点不⼊栈）            if (node.left != null) stack.push(node.left); // 左（空节点不⼊栈）        &#125;        return true;    &#125;    private int getDepth(TreeNode cur) &#123;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        if(cur != null) stack.push(cur);        int depth = 0; // 记录深度        int result = 0;        while(!stack.isEmpty()) &#123;            TreeNode node = stack.pop();            if (node != null) &#123;                stack.push(node); // 中                stack.push(null);                depth++;                if (node.right != null) stack.push(node.right); // 右                if (node.left != null) stack.push(node.left); // 左            &#125; else &#123;                node = stack.pop();                depth--;            &#125;            result = result &gt; depth ? result : depth;        &#125;        return result;    &#125;&#125;</code></pre><blockquote><p>当然此题⽤迭代法，其实效率很低，因为没有很好的模拟回溯的过程，所以迭代法有很多重复的计算。 虽然理论上所有的递归都可以⽤迭代来实现，但是有的场景难度可能⽐较⼤。 例如：都知道<strong>回溯法其实就是递归</strong>，但是很少⼈⽤迭代的⽅式去实现回溯算法！ 因为对于回溯算法已经是⾮常复杂的递归了，如果在⽤迭代的话，就是⾃⼰给⾃⼰找⿇烦， 效率也并不⼀定⾼。</p></blockquote><h2 id="十一、二叉树的所有路径"><a href="#十一、二叉树的所有路径" class="headerlink" title="十一、二叉树的所有路径"></a>十一、二叉树的所有路径</h2><h3 id="257、二叉树的所有路径"><a href="#257、二叉树的所有路径" class="headerlink" title="257、二叉树的所有路径"></a>257、二叉树的所有路径</h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径 - 力扣（LeetCode）</a>**</p><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/paths-tree.jpg" alt="img"></p><pre><code>输入：root = [1,2,3,null,5]输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]输出：[&quot;1&quot;]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>本题要求从根结点到叶子的路径，所以需要前序遍历，这样才方便让父结点指向子节点，找到对应的路径</p><p>在这道题中第一次涉及到<strong>回溯</strong>，因为我们需要把路径记录下来，需要回溯来回退一个路径再进入另一个路径</p><p>前序遍历以及回溯的过程如图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221225135255818.png" alt="image-20221225135255818"></p><p>先使用递归的方式，先做前序遍历，<strong>递归和回溯是一家</strong></p><h5 id="1）递归-1"><a href="#1）递归-1" class="headerlink" title="1）递归"></a>1）递归</h5><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值</p><p>参数就是传入的根结点，记录每一条的路径的<code>path</code>，和存放结果集的<code>result</code>，这里递归不需要返回值</p><pre><code class="java">void traversal(TreeNode cur, List&lt;Integer&gt; path, List&lt;String&gt; result);</code></pre></li><li><p>确定递归终止条件</p><p>遇到空节点，进行终止处理逻辑</p><pre><code class="java">if(cur == null) &#123;    // 终止处理逻辑&#125;</code></pre><p>但是本题终止条件这样写会很麻烦，因为本题需要找到叶子节点，就开始进行终止的处理逻辑了（把结果存入结果集<code>result</code>）</p><p><strong>找到叶子结点的时机</strong>：当<code>cur</code>不空，其左右节点都为空时</p><pre><code class="java">if(cur.left == null &amp;&amp; cur.right == null) &#123;    // 终止处理逻辑&#125;</code></pre><blockquote><p>为什么不用判断<code>cur </code>是否为空呢？ 因为下面的逻辑可以保证空节点不进入循环</p></blockquote><p>终止处理逻辑：</p><p>使用<code>List&lt;Integer&gt;</code>集合<code>path</code>来记录路径，所以需要把<code>List&lt;Integer&gt;</code>集合<code>path</code>转成<code>String</code>类型存入结果集<code>List&lt;String&gt;</code></p><pre><code class="java">if(cur.left == null &amp;&amp; cur.right == null) &#123;    // 终止处理逻辑    StringBuilder sPath = new StringBuilder();    // 将path里记录的路径转成String格式    for(int i = 0; i &lt; path.size() - 1; i++) &#123;        sPath.append(path.get(i) + &quot;-&gt;&quot;);    &#125;    // 记录最后一个节点（叶子结点）    sPath.append(path.get(path.size() - 1).toString());    result.add(sPath);    return;    &#125;</code></pre></li><li><p>确定单层处理的逻辑</p><p>因为是前序遍历，需要先处理中间结点，中间结点是要记录在路径上的节点，先存入<code>path</code></p><p><code>path.add(cur.val)</code></p><p>然后是递归和回溯的过程，上面说过没有判断<code>cur ?= null</code>，那么在这里递归的时候，如果为空，就不进行下一层递归了</p><p>所以在递归前要加上判断语句，下面要递归的节点是否为空</p><pre><code class="java">if(cur.left != null) &#123;     traversal(cur.left, path, result);&#125;if(cur.right != null) &#123;    traversal(cur.righr, path, result);&#125;</code></pre><p>此时还没有结束，递归结束，还需要回溯，因为<code>path</code>不能一直加入节点，还需要删除结点，然后才能加入新的节点</p><blockquote><p>错误回溯过程：</p><pre><code class="java">if(cur.left != null) &#123;     traversal(cur.left, path, result);&#125;if(cur.right != null) &#123;    traversal(cur.righr, path, result);&#125;path.remove(path.size() - 1);</code></pre><p>这个回溯存在很大的问题！！！</p><p>回溯和递归是一一对应的，有一个递归，就要有一个回溯，这么写的话就相当于把递归和回溯拆开了，一个在花括号里，一个在花括号外</p></blockquote><p>正确回溯过程：</p><pre><code class="java">if(cur.left != null) &#123;    traversal(cur.left, path, result);    path.remove(path.size() - 1); // 回溯&#125;if(cur.right != null) &#123;    traversal(cur.righr, path, result);    path.remove(path.size() - 1); // 回溯&#125;</code></pre></li></ol><h5 id="2）-迭代法"><a href="#2）-迭代法" class="headerlink" title="2） 迭代法"></a>2） 迭代法</h5><p>⾄于⾮递归的⽅式，我们可以依然可以使⽤前序遍历的迭代⽅式来模拟遍历路径的过程，这里除了模拟递归需要一个栈，同时还需要一个栈来存放对应的遍历路径</p><h4 id="实现-15"><a href="#实现-15" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归-2"><a href="#1）递归-2" class="headerlink" title="1）递归"></a>1）递归</h5><pre><code class="java">class Solution &#123;    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;        List&lt;String&gt; result = new ArrayList&lt;&gt;();        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();        traversal(root, path, result);        return result;    &#125;    private void traversal(TreeNode cur, List&lt;Integer&gt; path, List&lt;String&gt; result) &#123;        path.add(cur.val);        // 找到了叶子结点        if(cur.left == null &amp;&amp; cur.right == null) &#123;            StringBuilder sPath = new StringBuilder();            for(int i = 0; i &lt; path.size() - 1; i++) &#123;                sPath.append(path.get(i) + &quot;-&gt;&quot;);            &#125;            // 处理叶子结点            sPath.append(path.get(path.size() - 1));            result.add(sPath.toString());        &#125;        if(cur.left != null) &#123;            traversal(cur.left, path, result);            path.remove(path.size() - 1);        &#125;        if(cur.right != null) &#123;            traversal(cur.right, path, result);            path.remove(path.size() - 1);        &#125;    &#125;&#125;</code></pre><p>精简代码：</p><pre><code class="java">class Solution &#123;    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;        List&lt;String&gt; result = new ArrayList&lt;&gt;();        String sPath = new String();        traversal(root, sPath, result);        return result;    &#125;    private void traversal(TreeNode cur, String sPath, List&lt;String&gt; result) &#123;        sPath += cur.val; // 中间结点        // 找到了叶子结点        if(cur.left == null &amp;&amp; cur.right == null) &#123;            result.add(sPath);            return;        &#125;        if(cur.left != null) &#123;            traversal(cur.left, sPath + &quot;-&gt;&quot;, result);        &#125;        if(cur.right != null) &#123;            traversal(cur.right, sPath + &quot;-&gt;&quot;, result);        &#125;    &#125;&#125;</code></pre><blockquote><p>那么在如上代码中，貌似没有看到回溯的逻辑，其实不然，回溯就隐藏在<code>traversal(cur.left, path + &quot;-&gt;&quot;, result)</code>;中的<code> path + &quot;-&gt;&quot;</code>。 每次函数调⽤完，<code>path</code>依然是没有加 上<code>&quot;-&gt;&quot;</code> 的，这就是<strong>回溯</strong>了</p></blockquote><h5 id="2）迭代法-2"><a href="#2）迭代法-2" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;        Deque&lt;TreeNode&gt; treeStack = new LinkedList&lt;&gt;(); // 保存树的遍历结点        Deque&lt;String&gt; pathStack = new LinkedList&lt;&gt;(); // 保存遍历路径的节点        List&lt;String&gt; result = new ArrayList&lt;&gt;(); // 保存最终路径的集合        if(root == null) return result;        treeStack.push(root);        pathStack.push(String.valueOf(root.val));        while(!treeStack.isEmpty()) &#123;            TreeNode cur = treeStack.pop(); // 中            String path = pathStack.pop();            // 遇到叶子结点            if(cur.left == null &amp;&amp; cur.right == null) &#123;                result.add(path);            &#125;            // 右            if(cur.right != null) &#123;                treeStack.push(cur.right);                pathStack.push(path + &quot;-&gt;&quot; + cur.right.val);            &#125;            // 左            if(cur.left != null) &#123;                treeStack.push(cur.left);                pathStack.push(path + &quot;-&gt;&quot; + cur.left.val);            &#125;        &#125;        return result;    &#125;&#125;</code></pre><p><strong>补充</strong></p><pre><code class="java">class Solution &#123;    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;        List&lt;String&gt; paths = new ArrayList&lt;String&gt;();        constructPaths(root, &quot;&quot;, paths);        return paths;    &#125;    public void constructPaths(TreeNode root, String path, List&lt;String&gt; paths) &#123;        if (root != null) &#123;            StringBuffer pathSB = new StringBuffer(path);            pathSB.append(Integer.toString(root.val));            if (root.left == null &amp;&amp; root.right == null) &#123;  // 当前节点是叶子节点                paths.add(pathSB.toString());  // 把路径加入到答案中            &#125; else &#123;                pathSB.append(&quot;-&gt;&quot;);  // 当前节点不是叶子节点，继续递归遍历                constructPaths(root.left, pathSB.toString(), paths);                constructPaths(root.right, pathSB.toString(), paths);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="十二、左叶子之和"><a href="#十二、左叶子之和" class="headerlink" title="十二、左叶子之和"></a>十二、左叶子之和</h2><h3 id="404、左叶子之和"><a href="#404、左叶子之和" class="headerlink" title="404、左叶子之和"></a>404、左叶子之和</h3><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/leftsum-tree.jpg" alt="img"></p><pre><code>输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: root = [1]输出: 0</code></pre><p><strong>提示:</strong></p><ul><li>节点数在 <code>[1, 1000]</code> 范围内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>首先要注意判断是<strong>左叶子</strong>，而不是<strong>二叉树的左侧节点</strong>，因此不要想当然的使用层序遍历</p><p><strong>左叶子的明确定义</strong>：如果左节点不为空，且左结点没有左右孩子，那么这个结点就是左叶子</p><p>下图中的左叶子之和是多少？</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221226075133692.png" alt="image-20221226075133692"></p><p>其实是0，因为这棵树根本没有左叶子！</p><p>那么<strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父结点来判断其左孩子是不是左叶子</strong></p><p>&#x3D;&gt; 如果该节点的左节点不为空，并且该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到一个左叶子</p><pre><code class="java">if(cur.left != null &amp;&amp; cur.left.left != null &amp;&amp; cur.left.right == null) &#123;    // 左叶子节点处理逻辑&#125;</code></pre><h5 id="1）递归法-1"><a href="#1）递归法-1" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>递归的遍历顺序为后序遍历，是因为要通过递归函数的返回值来累加求取左叶子的数值之和</p><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值</p><p>要求一棵树的左叶子之和，一定要传入树的根结点，递归函数的返回值为数值之和，所以类型为<code>int</code></p><pre><code class="java">// 使用题目中给出的函数即可int sumOfLeftLeaves(TreeNode root) &#123;&#125;</code></pre></li><li><p>确定终止条件</p><pre><code class="java">if(root == null) return 0;</code></pre></li><li><p>确定单层递归的逻辑</p><p>当遇到左叶子节点时，记录数值，然后通过递归求取左子树的左叶子之和，和右子树的左叶子之和，相加便是整棵树的左叶子之和</p><pre><code class="java">int leftVal = sumOfLeftLeaves(root.left); // 左子树的左叶子之和int rightVal = sumOfLeftLeaves(root.right); // 右子树的左叶子之和int midVal = 0; // 中if(root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123;    midVal = root.left.val;&#125;return leftVal + rightVal + midVal;</code></pre></li></ol><h5 id="2）迭代法-3"><a href="#2）迭代法-3" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>本题迭代法使用前中后序都是可以的，只要把叶子结点统计起来就可以了</p><h4 id="实现-16"><a href="#实现-16" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-2"><a href="#1）递归法-2" class="headerlink" title="1）递归法"></a>1）递归法</h5><pre><code class="java">class Solution &#123;    public int sumOfLeftLeaves(TreeNode root) &#123;        if(root == null) return 0;        int leftVal = sumOfLeftLeaves(root.left); // 左子树的左叶子之和        int rightVal = sumOfLeftLeaves(root.right); // 右子树的左叶子之和        int midVal = 0; // 中        if(root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123;            midVal = root.left.val;        &#125;        return leftVal + rightVal + midVal;    &#125;&#125;</code></pre><p>精简代码</p><pre><code class="java">class Solution &#123;    public int sumOfLeftLeaves(TreeNode root) &#123;        if(root == null) return 0;        int midVal = 0; // 中        if(root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123;            midVal = root.left.val;        &#125;        return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) + midVal;    &#125;&#125;</code></pre><h5 id="2）迭代法-4"><a href="#2）迭代法-4" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>前序遍历</p><pre><code class="java">class Solution &#123;    public int sumOfLeftLeaves(TreeNode root) &#123;        if(root == null) return 0;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        int result = 0;        while(!stack.isEmpty()) &#123;            TreeNode cur = stack.pop();            if(cur.left != null &amp;&amp; cur.left.left == null &amp;&amp; cur.left.right == null) &#123;                result += cur.left.val;            &#125;            if(cur.right != null) stack.push(cur.right);            if(cur.left != null) stack.push(cur.left);        &#125;        return result;    &#125;&#125;</code></pre><p>中序遍历</p><pre><code class="java">class Solution &#123;    public int sumOfLeftLeaves(TreeNode root) &#123;        if(root == null) return 0;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        int result = 0;        TreeNode cur = root;        while(cur != null || !stack.isEmpty()) &#123;            if(cur != null) &#123;                // 指针遍历                stack.push(cur);                cur = cur.left; // 左            &#125; else &#123;                // 处理节点                cur = stack.pop();                if(cur.left != null &amp;&amp; cur.left.left == null &amp;&amp; cur.left.right == null) &#123;                    result += cur.left.val;                &#125;                cur = cur.right; // 右            &#125;        &#125;        return result;    &#125;&#125;</code></pre><h2 id="十三、树左下角的值"><a href="#十三、树左下角的值" class="headerlink" title="十三、树左下角的值"></a>十三、树左下角的值</h2><h3 id="513、找树左下角的值"><a href="#513、找树左下角的值" class="headerlink" title="513、找树左下角的值"></a>513、找树左下角的值</h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（LeetCode）</a>**</p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16720139492172.jpg" alt="img"></p><pre><code>输入: root = [2,1,3]输出: 1</code></pre><p><strong>示例 2:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree2.jpg" alt="img"></p><pre><code>输入: [1,2,3,4,null,5,6,null,null,7]输出: 7</code></pre><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,10^4]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题要找出树的最后一行的最左边值，显然使用层序遍历是非常简单的，使用递归方法要困难一点</p></blockquote><h5 id="1）递归法-3"><a href="#1）递归法-3" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>分析一下题目：<strong>在树的最后一行找到最左边的值</strong></p><p>首先是最后一行，其次是最左边的值</p><p>使用递归法，</p><ol><li>判断最后一行 &#x3D;&gt; 其实就是深度最大的叶子结点一定是在最后一行 &#x3D;&gt; 找深度最大的叶子结点</li><li>找最左边的值 &#x3D;&gt; 可以使用前序遍历，这样才优先在左边搜索，然后记录深度最大的叶子结点，此时就是树的最后一行最左边的值</li></ol><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值</p><p>参数必须要要有遍历的树的根结点，其实就是一个<code>int</code>型的变量用来记录最大深度，不需要返回值，所以地府函数的返回值类型为<code>void</code></p><p>本题还需要在类里定义两个全局变量，<code>maxLen</code>用来记录最大深度，<code>maxLeftValue</code>记录最大深度最左边的数值</p><pre><code class="java">int maxLen = Integer.MIN_VALUE; // 记录最大深度int minLeftValue = 0; // 记录最大深度最左边的数值void traversal(TreeNode cur, int leftLen);</code></pre><blockquote><p>为什么不能递归函数的返回值返回最大深度呢？</p><p>递归函数的返回值：<strong>如果需要遍历整颗树，递归函数就不能有返回值。如果需要遍历某⼀条固定路线，递归函数 就⼀定要有返回值！</strong></p></blockquote></li><li><p>确定终止条件</p><p>当遇到叶子结点的时候，就需要统计下最大的深度了，所以需要与到叶子结点来更新最大深度</p><pre><code class="java">if(cur.left == null &amp;&amp; cur.right == null) &#123;    if(leftLen &gt; maxLen) &#123;        maxLen = leftLen;        maxLeftValue = cur.val;    &#125;    return;&#125;</code></pre></li><li><p>确定单层递归的逻辑</p><p>在找最大深度的时候，递归的过程依然要使用回溯</p><pre><code class="java">// 中// 左if(cur.left != null) &#123;    leftLen++; // 深度加一    traversal(cur.left, leftLen);    leftLen--; // 回溯，深度减一&#125;// 右if(cur.right != null) &#123;    leftLen++; // 深度加一    traversal(cur.right, leftLen);    leftLen--; // 回溯，深度减一&#125;</code></pre></li></ol><h5 id="2）迭代法-5"><a href="#2）迭代法-5" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>本题使用层序遍历再合适不过了，比递归要好理解的多，只需要记录最后一行的第一个数值就可以了。</p><h4 id="实现-17"><a href="#实现-17" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-4"><a href="#1）递归法-4" class="headerlink" title="1）递归法"></a>1）递归法</h5><pre><code class="java">class Solution &#123;    private int maxLen;    private int maxLeftValue;    public Solution() &#123;        maxLen = Integer.MIN_VALUE;        maxLeftValue = 0;    &#125;    public int findBottomLeftValue(TreeNode root) &#123;        traversal(root, 0);        return maxLeftValue;    &#125;    private void traversal(TreeNode cur, int leftLen) &#123;        if(cur.left == null &amp;&amp; cur.right == null) &#123;            if(leftLen &gt; maxLen) &#123;                maxLen = leftLen;                maxLeftValue = cur.val;            &#125;            return;        &#125;        // 左        if(cur.left != null) &#123;            leftLen++; // 深度加一            traversal(cur.left, leftLen);            leftLen--; // 回溯，深度减一        &#125;        // 右        if(cur.right != null) &#123;            leftLen++; // 深度加一            traversal(cur.right, leftLen);            leftLen--; // 回溯，深度减一        &#125;    &#125;&#125;</code></pre><p>精简代码</p><pre><code class="java">class Solution &#123;    private int maxLen;    private int maxLeftValue;    public Solution() &#123;        maxLen = Integer.MIN_VALUE;        maxLeftValue = 0;    &#125;    public int findBottomLeftValue(TreeNode root) &#123;        traversal(root, 0);        return maxLeftValue;    &#125;    private void traversal(TreeNode cur, int leftLen) &#123;        if(cur.left == null &amp;&amp; cur.right == null) &#123;            if(leftLen &gt; maxLen) &#123;                maxLen = leftLen;                maxLeftValue = cur.val;            &#125;            return;        &#125;        // 左        if(cur.left != null) &#123;            traversal(cur.left, leftLen + 1); // 隐含有回溯        &#125;        // 右        if(cur.right != null) &#123;            traversal(cur.right, leftLen + 1); // 隐含有回溯        &#125;    &#125;&#125;</code></pre><h5 id="2）迭代法-6"><a href="#2）迭代法-6" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public int findBottomLeftValue(TreeNode root) &#123;        Queue&lt;TreeNode&gt; seen = new LinkedList&lt;&gt;();        seen.offer(root);        int result = 0;        while(!seen.isEmpty()) &#123;            int currentLevelSize = seen.size();            for(int i = 0; i &lt; currentLevelSize; i++) &#123;                TreeNode cur = seen.poll();                if(i == 0) result = cur.val;                if(cur.left != null) seen.offer(cur.left);                if(cur.right != null) seen.offer(cur.right);            &#125;        &#125;        return result;    &#125;&#125;</code></pre><h2 id="十三、路径总和"><a href="#十三、路径总和" class="headerlink" title="十三、路径总和"></a>十三、路径总和</h2><blockquote><p>解决：递归函数什么时候需要返回值？</p></blockquote><h3 id="112、路径总和"><a href="#112、路径总和" class="headerlink" title="112、路径总和"></a>112、路径总和</h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a>**</p><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/pathsum1.jpg" alt="img"></p><pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/pathsum2.jpg" alt="img"></p><pre><code>输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>本题需要遍历从根结点到叶子结点的路径看看总和而不是目标和</p><h5 id="1）递归-3"><a href="#1）递归-3" class="headerlink" title="1）递归"></a>1）递归</h5><p>可以使用深度优先遍历的方式来遍历二叉树</p><blockquote><p>本题前中后序都可以，因为中间结点没有处理逻辑</p></blockquote><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值类型</p><p>参数：需要一个二叉树的根结点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为<code>int</code>类型</p><p>讨论一下返回值，递归函数什么时候需要返回值，什么时候不需要返回值？</p><blockquote><p>递归函数的返回值：<strong>如果需要遍历整颗树，递归函数就不能有返回值。如果需要遍历某⼀条固定路线，递归函数 就⼀定要有返回值！</strong></p></blockquote><p>而本题要找一条符合条件的路径，所以递归函数需要返回值，返回值类型是什么呢？</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221226094750601.png" alt="image-20221226094750601"></p><p>图中可以看出，遍历的路线，并不需要遍历整棵树，所以递归函数需要返回值，可以使用<code>boolean</code>类型表示</p><pre><code class="java">boolean traversal(TreeNode cur, int count);</code></pre></li><li><p>确定终止条件</p><p>首先计数器如何统计这一条路径的和呢？不要去累加然后判断是否等于目标和，那样代码比较麻烦，可以使用递减，让计数器<code>count</code>初识为目标和，然后每次减去遍历路径节点上的数值</p><p>如果最后<code>count == 0</code>，同时到了叶子结点的话，就说明找到了目标和</p><p>如果遍历到了叶子结点，<code>count != 0</code>，就说明没找到</p><pre><code class="java">if(cur.left == null &amp;&amp; cur.right == null &amp;&amp; count == 0) return true; // 遇到叶子结点，并且计数器为0if(cur.left == null &amp;&amp; cur.right == null) return false; // 与到叶子结点还没有找合适的边，直接返回</code></pre></li><li><p>确定单层递归的逻辑</p><p>因为终止条件是判断叶子结点，所以递归的过程中就不要让空节点进入递归了</p><p>递归函数是有返回值的，如果递归函数<code>return true</code>，说明找到了合适的路径，就直接返回</p><pre><code class="java">if (cur.left != null) &#123; // 左 （空节点不遍历） // 遇到叶⼦节点返回true，则直接返回true     if (traversal(cur.left, count - cur.left.val)) return true; // 注意这⾥有回溯的逻辑&#125;if (cur.right != null) &#123; // 右 （空节点不遍历） // 遇到叶⼦节点返回true，则直接返回true     if (traversal(cur.right, count - cur.right.val)) return true; // 注意这⾥有回溯的逻辑&#125;return false;</code></pre><blockquote><p>以上代码中是包含着回溯的。 回溯隐藏在<code>traversal(cur.left, count - cur.left.val)</code>这⾥， 因为把<code>count - cur.left.val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p><p>为了把回溯的过程体现出来，可以改为如下代码：</p><pre><code class="java">if (cur.left != null) &#123; // 左 （空节点不遍历） // 遇到叶⼦节点返回true，则直接返回true    count -= cur.left.val; // 递归，处理节点     if (traversal(cur.left, count)) return true;     count += cur.left.val; // 回溯，撤销处理结果&#125;if (cur.right != null) &#123; // 右 （空节点不遍历） // 遇到叶⼦节点返回true，则直接返回true     count -= cur.right.val; // 递归，处理节点     if (traversal(cur.right, count)) return true;     count += cur.right.val; // 回溯，撤销处理结果&#125;return false;</code></pre></blockquote></li></ol><h5 id="2）迭代"><a href="#2）迭代" class="headerlink" title="2）迭代"></a>2）迭代</h5><p>可以使用两个队列，一个队列保存遍历的节点，一个队列保存遍历结点的数值和</p><blockquote><p>也可以使用<code>javafx.util.Pair</code>类实现，键保存节点，值保存节点数值和</p></blockquote><h4 id="实现-18"><a href="#实现-18" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-5"><a href="#1）递归法-5" class="headerlink" title="1）递归法"></a>1）递归法</h5><pre><code class="java">class Solution &#123;    public boolean hasPathSum(TreeNode root, int targetSum) &#123;        if(root == null) return false;        return traversal(root, targetSum - root.val);    &#125;    private boolean traversal(TreeNode cur, int count) &#123;        if(cur.left == null &amp;&amp; cur.right == null &amp;&amp; count == 0) return true;        if(cur.left == null &amp;&amp; cur.right == null) return false;        if(cur.left != null) &#123;            if(traversal(cur.left, count - cur.left.val)) &#123;                return true;            &#125;        &#125;        if(cur.right != null) &#123;            if(traversal(cur.right, count - cur.right.val)) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;</code></pre><p>精简代码</p><pre><code class="java">class Solution &#123;    public boolean hasPathSum(TreeNode root, int targetSum) &#123;        if(root == null) return false;        if(root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == root.val) return true;        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);    &#125;&#125;</code></pre><h5 id="2）迭代法-7"><a href="#2）迭代法-7" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public boolean hasPathSum(TreeNode root, int targetSum) &#123;        if(root == null) return false;        Queue&lt;TreeNode&gt; queNode = new LinkedList&lt;&gt;();        Queue&lt;Integer&gt; queVal = new LinkedList&lt;&gt;();        queNode.offer(root);        queVal.offer(root.val);        while(!queNode.isEmpty()) &#123;            TreeNode node = queNode.poll();            int temp = queVal.poll();            if(node.left == null &amp;&amp; node.right == null) &#123;                if(temp == targetSum)  return true;                continue;            &#125;                        if(node.left != null) &#123;                queNode.offer(node.left);                queVal.offer(temp + node.left.val);            &#125;            if(node.right != null) &#123;                queNode.offer(node.right);                queVal.offer(temp + node.right.val);            &#125;        &#125;        return false;    &#125;&#125;</code></pre><h3 id="113、路径总和II"><a href="#113、路径总和II" class="headerlink" title="113、路径总和II"></a>113、路径总和II</h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II - 力扣（LeetCode）</a>**</p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/pathsumii1.jpg" alt="img"></p><pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/pathsum2-16720215039598.jpg" alt="img"></p><pre><code>输入：root = [1,2,3], targetSum = 5输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1,2], targetSum = 0输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p><strong>递归法</strong></p><p>本题要遍历整棵树，找到所有路径，所以递归函数不需要返回值</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221226103246506.png" alt="image-20221226103246506"></p><h4 id="实现-19"><a href="#实现-19" class="headerlink" title="实现"></a>实现</h4><p><strong>递归法</strong></p><p>完整版本</p><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;        if(root == null) return ans;        path.offerLast(root.val); // 把根结点传入路径        traversal(root, targetSum - root.val);        return ans;    &#125;    private void traversal(TreeNode cur, int count) &#123;        // 遇到了叶子结点且找到了和为targetSum的路径        if(cur.left == null &amp;&amp; cur.right == null &amp;&amp; count == 0) &#123;            ans.add(new ArrayList&lt;&gt;(path));            return;        &#125;        // 遇到叶子结点而没有找合适的边，直接返回        if(cur.left == null &amp;&amp; cur.right == null) &#123;            return;        &#125;        // 左（空节点不遍历）        if(cur.left != null) &#123;            path.offerLast(cur.left.val);            traversal(cur.left, count - cur.left.val); // 包含回溯            path.pollLast(); // 回溯        &#125;        // 右（空节点不遍历）        if(cur.right != null) &#123;            path.offerLast(cur.right.val);            traversal(cur.right, count - cur.right.val); // 包含回溯            path.pollLast(); // 回溯        &#125;    &#125;&#125;</code></pre><p>精简改编版：</p><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;        traversal(root, targetSum);        return ans;    &#125;    private void traversal(TreeNode cur, int targetSum) &#123;        if(cur == null) return;        path.offerLast(cur.val);        targetSum -= cur.val;        if(cur.left == null &amp;&amp; cur.right == null &amp;&amp; targetSum == 0) &#123;            ans.add(new ArrayList&lt;&gt;(path));        &#125;        traversal(cur.left, targetSum);        traversal(cur.right, targetSum);        path.pollLast(); // 回溯    &#125;&#125;</code></pre><h2 id="十四、构造二叉树"><a href="#十四、构造二叉树" class="headerlink" title="十四、构造二叉树"></a>十四、构造二叉树</h2><h3 id="106、从中序和后序遍历序列构造二叉树"><a href="#106、从中序和后序遍历序列构造二叉树" class="headerlink" title="106、从中序和后序遍历序列构造二叉树"></a>106、从中序和后序遍历序列构造二叉树</h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a>**</p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree-16720637433131.jpg" alt="img"></p><pre><code>输入：inorder = [9,3,15,20,7],postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入：inorder = [-1], postorder = [-1]输出：[-1]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><blockquote><p>根据两个顺序构造出一个唯一的二叉树：</p><p>&#x3D;&gt; 以后序数组的最后一个元素为切割点，先切割中序数组，根据中序数组反过来切割后序数组，一层一层切下去，每次后续数组的最后一个元素就是节点元素</p><p>以<code>inorder = [9,3,15,20,7],postorder = [9,15,7,20,3]</code>为例，流程如图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221226222511312.png" alt="image-20221226222511312"></p></blockquote><p>一层一层切割 &#x3D;&gt; 递归</p><p>步骤：</p><ol><li>如果数组大小为零，说明是空节点</li><li>如果不为空，那么取后序数组的最后一个元素作为节点元素</li><li>找到后序数组最后一个元素在中序数组中的位置，作为切割点</li><li>切割中序数组，切割成中序左数组和中序右数组</li><li>切割后序数组，切成后序左数组和后序右数组</li><li>递归处理左区间和右区间</li></ol><p><strong>难点：</strong>如何切割，以及如何找边界值</p><blockquote><p>注意切割的标准，是左闭右闭，还是左开右闭，还是左闭右开，这个是个不变量，要在递归中保持这个变量</p><p>在切割的过程会产生四个区间，把握不好不变量的结果就是乱套</p></blockquote><p>1）首先要切割中序数组</p><blockquote><p>为什么？</p><p>切割点在后序数组的最后一个元素，就是利用这个元素来切割中序数组，所以必要先切割中序数组</p></blockquote><p>中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割（以下代码采用<strong>左闭右开</strong>的原则）</p><p>2）然后切割后序数组</p><p>首先后序数组的最后一个元素需要丢弃，这是切割点也是当前二叉树中间结点的元素</p><p>后序数组的切割点怎么找？</p><p>后序数组没有明确的切割元素来进⾏左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。</p><p><strong>一个很重要的点，就是中序数组大小一定是和后序数组的大小相同的</strong></p><p>中序数组已经拆分成中序左数组和中序右数组，那么后序数组就可以按照中序左数组的大小来切割，切割成后序左数组和后序右数组</p><p>此时，中序数组和后序数组切割完成，可以递归了</p><h4 id="实现-20"><a href="#实现-20" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    Map&lt;Integer, Integer&gt; map;  // 方便根据数值查找位置    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;        map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; inorder.length; i++) &#123; // 用map保存中序序列的数值对应位置            // key - 数值   value - 下标            map.put(inorder[i], i);        &#125;        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  // 前闭后开    &#125;    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;        // 参数里的范围都是前闭后开        if (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  // 不满足左闭右开，说明没有元素，返回空树            return null;        &#125;        int rootIndex = map.get(postorder[postEnd - 1]);  // 找到后序遍历的最后一个元素在中序遍历中的位置        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数        root.left = findNode(inorder, inBegin, rootIndex,                postorder, postBegin, postBegin + lenOfLeft);        root.right = findNode(inorder, rootIndex + 1, inEnd,                postorder, postBegin + lenOfLeft, postEnd - 1);        return root;    &#125;&#125;</code></pre><h3 id="105、从前序与后序遍历序列构造二叉树"><a href="#105、从前序与后序遍历序列构造二叉树" class="headerlink" title="105、从前序与后序遍历序列构造二叉树"></a>105、从前序与后序遍历序列构造二叉树</h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a>**</p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>，<code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree-16721014893041.jpg" alt="img"></p><pre><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: preorder = [-1], inorder = [-1]输出: [-1]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>和**<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a>**一个道理，后序数组的最后一个元素 &#x3D;&#x3D;&gt; 前序数组的第一个元素</p><h4 id="实现-21"><a href="#实现-21" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    // 方便根据数值查找位置（数值 -&gt; 下标）    Map&lt;Integer, Integer&gt; map;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        map = new HashMap&lt;&gt;();        for(int i = 0; i &lt; inorder.length; i++) &#123;            map.put(inorder[i], i);        &#125;        // 左闭右开        return findNode(inorder, 0, inorder.length, preorder, 0, preorder.length);    &#125;    private TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] preorder, int preBegin, int preEnd) &#123;        // 参数范围都是左闭右开        if(inBegin &gt;= inEnd || preBegin &gt;= preEnd) &#123;            // 不满足左闭右开，说明没有元素，返回空树            return null;        &#125;        // 找到前序遍历的第一个元素在中序遍历中的位置        int rootIndex = map.get(preorder[preBegin]);        // 构造根节点        TreeNode root = new TreeNode(inorder[rootIndex]);        // 中序左数组元素个数        int lenOfLeft = rootIndex - inBegin;        // 注意好范围        root.left = findNode(inorder, inBegin, rootIndex, preorder, preBegin + 1, preBegin + 1 + lenOfLeft);        root.right = findNode(inorder, rootIndex + 1, inEnd, preorder, preBegin + 1 + lenOfLeft, preEnd);        return root;    &#125;&#125;</code></pre><blockquote><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol><li>前序和中序可以唯一确定一棵二叉树</li><li>后序和中序可以唯一确定一棵二叉树</li></ol><p>那么前序和后序能否唯一确定一棵二叉树呢？</p><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><p><strong>前序和后序不能唯一确定一棵二叉树</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221227085915397.png" alt="image-20221227085915397"></p><p>上图中</p><ul><li>tree1的前序遍历为[1,2,3]，后序遍历为[3,2,1]</li><li>tree2的前序遍历为[1,2,3]，后序遍历为[3,2,1]</li></ul><p>&#x3D;&gt;  两棵不同的树的前序和后序完全相同！！！  &#x3D;&gt;  前序和后序不能唯一确定一棵二叉树的</p></blockquote><h3 id="654、最大二叉树"><a href="#654、最大二叉树" class="headerlink" title="654、最大二叉树"></a>654、最大二叉树</h3><h4 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a>**</p><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> <em><strong>最大二叉树</strong></em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16721037775083.jpg" alt="img"></p><pre><code>输入：nums = [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示：- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。        - 空数组，无子节点        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。            - 空数组，无子节点。            - 只有一个元素，所以子节点是一个值为 1 的节点。    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。          - 只有一个元素，所以子节点是一个值为 0 的节点。        - 空数组，无子节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree2-16721038965555.jpg" alt="img"></p><pre><code>输入：nums = [3,2,1]输出：[3,null,2,null,1]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><p>以[3,2,1,6,0,5]为例，最大二叉树构造过程：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/1660983388-JCEHCH-1.png" alt="1.png"></p><p>构造树一般采用前序遍历，因为先构造中间结点，然后递归构造左子树和右子树</p><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值</p><p>参数就是传入存放元素的数组，以及要构造二叉树的数组的左边界和右边界（左闭右开），返回该数组构造的二叉树的根结点，返回值类型是节点类型</p><pre><code class="java">TreeNode helper(int[] nums, int leftIndex, int rightIndex);</code></pre></li><li><p>确定终止条件</p><p>题目中说输入的数组大小一定是大于等于1的，所以不需要考虑小于1的情况，那么当递归遍历的时候，如果传入的数组大小为1，说明遍历到叶子结点了，那么应该定义一个新的节点，并把这个数组的数值赋值给新的节点，然后返回这个节点。这表示一个数组的大小是1的时候，构造了一个新节点，并返回。</p><pre><code class="java">if(rightIndex - leftIndex &lt; 1) &#123;    // 没有元素了    return null;&#125;if(rightIndex - leftIndex == 1) &#123;    // 只有一个元素    return new TreeNode(nums[leftIndex]);&#125;</code></pre></li><li><p>确定单层递归的逻辑</p><p>1）先找到数组中最大的值和对应的下标，最大的值构造根结点，下标用来下一步分割数组</p><p>2）最大值所在的下标左区间构造左子树，这里需要判断<code>maxValueIndex &gt; 0</code>，因为要保证左区间至少有一个数值</p><p>3）最大值所在的下标右区间构造右子树，这里需要判断<code>maxValueIndex &lt; (nums.length - 1)</code>，因为要保证右区间至少有一个数值</p><blockquote><p>上述判断过程可以使用传参的方式约束</p></blockquote></li></ol><h4 id="实现-22"><a href="#实现-22" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;        return helper(nums, 0, nums.length);    &#125;    private TreeNode helper(int[] nums, int leftIndex, int rightIndex) &#123;        if(rightIndex - leftIndex &lt; 1) &#123;            // 没有元素了            return null;        &#125;        if(rightIndex - leftIndex == 1) &#123;            // 只剩下一个元素了            return new TreeNode(nums[leftIndex]);        &#125;        // 最大值的下标        int maxValueIndex = leftIndex;        // 最大值        int maxValue = nums[leftIndex];        for(int i = leftIndex + 1; i &lt; rightIndex; i++) &#123;            if(nums[i] &gt; maxValue) &#123;                maxValue = nums[i];                maxValueIndex = i;            &#125;        &#125;         // 构造当前区间的根结点        TreeNode root = new TreeNode(maxValue);        // 根据maxValueIndex划分左右子树        root.left = helper(nums, leftIndex, maxValueIndex);        root.right = helper(nums, maxValueIndex + 1, rightIndex);        return root;    &#125;&#125;</code></pre><h2 id="十五、合并二叉树"><a href="#十五、合并二叉树" class="headerlink" title="十五、合并二叉树"></a>十五、合并二叉树</h2><h3 id="617、合并二叉树"><a href="#617、合并二叉树" class="headerlink" title="617、合并二叉树"></a>617、合并二叉树</h3><h4 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树 - 力扣（LeetCode）</a>**</p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/merge.jpg" alt="img"></p><pre><code>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root1 = [1], root2 = [1,2]输出：[2,2]</code></pre><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li></ul><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><h5 id="1）递归法-6"><a href="#1）递归法-6" class="headerlink" title="1）递归法"></a>1）递归法</h5><blockquote><p>二叉树使用递归，就要想使用哪种遍历方式？</p><p><strong>本题使用哪种遍历都是可以的 ！</strong></p></blockquote><p>前序遍历：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/23fbf9388a4193475a7606a6390729f575e3329e0a810d2047682f701d3ddd1f-recursion.gif" alt="recursion.gif"></p><p>递归三部曲：</p><ol><li><p>确定递归函数的参数和返回值</p><p>首先要想合并两棵二叉树，那么参数至少是要传入两棵二叉树的根结点，返回值就是合并之后的二叉树根结点</p><pre><code class="java">TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;&#125;</code></pre></li><li><p>确定终止条件</p><p>因为是传入了两棵树，那么就有两棵树的遍历结点<code>root1</code>，<code>root2</code>，如果<code>root1 == null</code>，两棵树合并之后就是<code>root2</code>（<code>root2 == null</code>也没有关系，合并之后就是<code>null</code>）</p><p>反之同理</p><pre><code class="java">if(root1 == null) return root2;if(root2 == null) return root1;</code></pre></li><li><p>确定单层递归的逻辑</p><p>单层递归的逻辑就比较好写了，此处我们复用<code>root1</code>这棵树</p><p>在单层递归中，就要把两棵树的元素加在一起</p><pre><code class="java">root1.val += root2.val;</code></pre><p>接下来合并两棵树的左子树和右子树</p><pre><code class="java">root1.left = mergeTrees(root1.left, root2.left);root1.right = mergeTrees(root1.right, root2.right);return root1;</code></pre></li></ol><h5 id="2）迭代法-8"><a href="#2）迭代法-8" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><ul><li>使用栈</li><li>使用队列</li></ul><h4 id="实现-23"><a href="#实现-23" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-7"><a href="#1）递归法-7" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>前序遍历</p><pre><code class="java">class Solution &#123;    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;        if(root1 == null) return root2;        if(root2 == null) return root1;        root1.val += root2.val; // 中        root1.left = mergeTrees(root1.left, root2.left); // 左        root1.right = mergeTrees(root1.right, root2.right); // 右        return root1;    &#125;&#125;</code></pre><p>中序遍历</p><pre><code class="java">class Solution &#123;    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;        if(root1 == null) return root2;        if(root2 == null) return root1;        root1.left = mergeTrees(root1.left, root2.left); // 左        root1.val += root2.val; // 中        root1.right = mergeTrees(root1.right, root2.right); // 右        return root1;    &#125;&#125;</code></pre><p>后序遍历</p><pre><code class="java">class Solution &#123;    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;        if(root1 == null) return root2;        if(root2 == null) return root1;        root1.left = mergeTrees(root1.left, root2.left); // 左        root1.right = mergeTrees(root1.right, root2.right); // 右        root1.val += root2.val; // 中        return root1;    &#125;&#125;</code></pre><p>不改变树结构的前序遍历</p><pre><code class="java">class Solution &#123;    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;        if(root1 == null) return root2;        if(root2 == null) return root1;                TreeNode root = new TreeNode(0);                root.val = root1.val + root2.val; // 中        root.left = mergeTrees(root1.left, root2.left); // 左        root.right = mergeTrees(root1.right, root2.right); // 右        return root;    &#125;&#125;</code></pre><h5 id="2）迭代法-9"><a href="#2）迭代法-9" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>使用栈</p><pre><code class="java">class Solution &#123;    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;        if(root1 == null) return root2;        if(root2 == null) return root1;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root2);        stack.push(root1);        while(!stack.isEmpty()) &#123;            TreeNode node1 = stack.pop();            TreeNode node2 = stack.pop();            node1.val += node2.val; // 中            // 右            if(node2.right != null &amp;&amp; node1.right != null) &#123;                stack.push(node2.right);                stack.push(node1.right);            &#125; else &#123;                if(node1.right == null) &#123;                    node1.right = node2.right;                &#125;            &#125;            // 左            if(node2.left != null &amp;&amp; node1.left != null) &#123;                stack.push(node2.left);                stack.push(node1.left);            &#125; else &#123;                if(node1.left == null) &#123;                    node1.left = node2.left;                &#125;            &#125;        &#125;        return root1;    &#125;&#125;</code></pre><p>使用队列</p><pre><code class="java">class Solution &#123;    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;        if(root1 == null) return root2;        if(root2 == null) return root1;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root1);        queue.offer(root2);        while(!queue.isEmpty()) &#123;            TreeNode node1 = queue.poll();            TreeNode node2 = queue.poll();            // 此时两个节点一定不为空，val相加            node1.val += node2.val;            // 如果两棵树的左节点都不空，加入队列            if(node1.left != null &amp;&amp; node2.left != null) &#123;                queue.offer(node1.left);                queue.offer(node2.left);            &#125;            // 如果两棵树的右节点都不空，加入队列            if(node1.right != null &amp;&amp; node2.right != null) &#123;                queue.offer(node1.right);                queue.offer(node2.right);            &#125;            // 若node1的左节点为空，直接赋值            if (node1.left == null) &#123;                node1.left = node2.left;            &#125;            // 若node2的左节点为空，直接赋值            if (node1.right == null) &#123;                node1.right = node2.right;            &#125;        &#125;        return root1;    &#125;&#125;</code></pre><h2 id="十六、二叉树中的搜索专题"><a href="#十六、二叉树中的搜索专题" class="headerlink" title="十六、二叉树中的搜索专题"></a>十六、二叉树中的搜索专题</h2><h3 id="700、二叉搜索树中的搜索"><a href="#700、二叉搜索树中的搜索" class="headerlink" title="700、二叉搜索树中的搜索"></a>700、二叉搜索树中的搜索</h3><h4 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a>**</p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16721431158231.jpg" alt="img"></p><pre><code>输入：root = [4,2,7,1,3], val = 2输出：[2,1,3]</code></pre><p><strong>示例 2:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree2-16721431806195.jpg" alt="img"></p><pre><code>输入：root = [4,2,7,1,3], val = 5输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>数中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 10^7</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 10^7</code></li></ul><h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><blockquote><p>二叉搜索树是一颗有序树：</p><ul><li>若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值； </li><li>若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值； </li><li>它的左、右⼦树也分别为⼆叉搜索树</li></ul></blockquote><h5 id="1）递归法-8"><a href="#1）递归法-8" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>递归三部曲：</p><ol><li><p>确定递归函数的参数和返回值</p><p>递归函数的参数就是根结点和要搜索的数值，返回值就是这个搜索数值所在的节点</p><pre><code class="java">TreeNode searchBST(TreeNode root, int val);</code></pre></li><li><p>确定终止条件</p><p>如果root为空，或者找到了这个数值了，就返回root节点</p><pre><code class="java">if(root == null &amp;&amp; root.val == val) return root;</code></pre></li><li><p>确定单层递归的逻辑</p><p>因为二叉搜索树的节点是有序的，所以可以有方向的去搜素</p><p>如果<code>root.val &gt; val</code>，就去搜索左子树，如果<code>root.val &lt; val</code>，就去搜索右子树，最后如果都没有搜索到，就返回<code>null</code></p><pre><code class="java">if(root.val &gt; val) return searchBST(root.left, val);if(root.val &lt; val) return searchBST(root.right, val);return null;</code></pre><blockquote><p>之前提过，如要要搜素一条边，递归函数就要加返回值</p><p>这里也是一样的道理，因为搜索到了目标节点，就要立即<code>return</code>，这样才是找到节点就返回（叟座某一条边），如果不加<code>return</code>，就是遍历整棵树了</p></blockquote></li></ol><h5 id="2）迭代法-10"><a href="#2）迭代法-10" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><blockquote><p>一提到二叉树遍历的迭代法，可能立刻就想起使用栈来模拟深度优先遍历，使用队列来模拟广度优先遍历</p><p>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用栈或者队列就可以写出迭代法</p></blockquote><p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么就要掉头，走右分支</p><p><strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮助我们确定了搜索的方向</strong></p><p>【例子】要搜素元素3的节点，我们不需要搜索其他节点，也不需要回溯，查找的路径已经规划好了</p><p>中间结点如果小于3就往右走，如果大于3就往左走</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221227204825710.png" alt="image-20221227204825710"></p><h4 id="实现-24"><a href="#实现-24" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-9"><a href="#1）递归法-9" class="headerlink" title="1）递归法"></a>1）递归法</h5><pre><code class="java">class Solution &#123;    public TreeNode searchBST(TreeNode root, int val) &#123;        if(root == null || root.val == val) return root;        if(root.val &gt; val) return searchBST(root.left, val);        if(root.val &lt; val) return searchBST(root.right, val);        return null;    &#125;&#125;</code></pre><h5 id="2）迭代法-11"><a href="#2）迭代法-11" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public TreeNode searchBST(TreeNode root, int val) &#123;        while(root != null) &#123;            if(root.val == val) return root;            else if(root.val &gt; val) root = root.left;            else root = root.right;        &#125;        return root;    &#125;&#125;</code></pre><h3 id="98、验证二叉搜索树"><a href="#98、验证二叉搜索树" class="headerlink" title="98、验证二叉搜索树"></a>98、验证二叉搜索树</h3><h4 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a>**</p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree1-16721878442281.jpg" alt="img"></p><pre><code>输入：root = [2,1,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree2-16721879146145.jpg" alt="img"></p><pre><code>输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 10^4]</code> 内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h4><p>在中序遍历下，输出的二叉搜索树节点的数值是有序序列</p><h5 id="1）递归法-10"><a href="#1）递归法-10" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>方法一：递归中序遍历将二叉搜索树转变成一个数组，然后判断这个数组是否有序，注意二叉搜索树中不能有重复元素</p><p>方法二：在递归遍历的过程中直接判断是否有序</p><blockquote><p>本题比较容易踩的坑：</p><ul><li><p>坑1：<strong>不能单纯的比较左节点小于中间结点，右节点大于中间结点</strong></p><pre><code class="java">// 此代码是错误的if (root.val &gt; root.left.val &amp;&amp; root.val &lt; root.right.val) &#123;     return true;&#125; else &#123;     return false;&#125;</code></pre><p><strong>要比较的是 左子树的所有节点小于中间结点，右子树的所有节点大于中间结点</strong></p><p>【例子】：<code>[10,5,15,null,null,6,20]</code></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221228085116770.png" alt="image-20221228085116770"></p><p>节点10大于左节点5，小于右节点15，但是在右子树中出现了一个6，这就不符合二叉搜索树的定义</p></li><li><p>坑2：<strong>样例中的最小节点可能是Integer.MIN_VALUE</strong></p><p>此时可以初始化比较元素为<strong>Long.MIN_VLAUE</strong></p><p>问题可以进一步演化，如果样例中的最小节点为<strong>Long.MIN_VALUE</strong>，怎么办？后续解答</p></li></ul></blockquote><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值</p><p>定义一个<code>long</code>类型的全局变量，用来比较遍历的节点是否有序，初始化为<code>Long.MIN_VALUE</code></p><p>递归函数的返回值为<code>boolean</code>，因为本题是在寻找一个不符合条件的节点，如果没有找到这个结点就遍历整棵树，如果找到了不符合条件的节点，立即返回</p><pre><code class="java">long maxVal = Long.MIN_VALUE;boolean isValidBST(TreeNode root);</code></pre></li><li><p>确定终止条件</p><p>如果遍历到了空节点，返回<code>true</code>，因为二叉搜索树也可以为空！</p><pre><code class="java">if(root == null) &#123;    return true;&#125;</code></pre></li><li><p>确定单层递归的逻辑</p><p>中序遍历，一直更新<code>maxVal</code>，一旦发现<code>maxVal &gt;= root.val</code>，就返回<code>false</code>，注意元素相同的时候也要返回<code>false</code></p><pre><code class="java">boolean left = isValidBST(root.left);if(root.val &gt; maxVal) maxVal = root.val;else return false;boolean right = isValidBST(root.right);return left &amp;&amp; right;</code></pre></li></ol><h5 id="2）迭代法-12"><a href="#2）迭代法-12" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>迭代法中序遍历稍加改就可以了</p><h4 id="实现-25"><a href="#实现-25" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-11"><a href="#1）递归法-11" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>方法一</p><pre><code class="java">class Solution &#123;    private List&lt;Integer&gt; nodeValueList;    public boolean isValidBST(TreeNode root) &#123;        nodeValueList = new ArrayList&lt;&gt;();        traversal(root);        for(int i = 1; i &lt; nodeValueList.size(); i++) &#123;            if(nodeValueList.get(i) &lt;= nodeValueList.get(i - 1)) return false;        &#125;        return true;    &#125;    private void traversal(TreeNode root) &#123;        if(root == null) return;        traversal(root.left);        nodeValueList.add(root.val);        traversal(root.right);    &#125;&#125;</code></pre><p>方法二：</p><pre><code class="java">class Solution &#123;    long maxVal = Long.MIN_VALUE;    public boolean isValidBST(TreeNode root) &#123;        if(root == null) return true;        boolean left = isValidBST(root.left);        if(root.val &gt; maxVal) maxVal = root.val;        else return false;        boolean right = isValidBST(root.right);        return left &amp;&amp; right;    &#125;&#125;</code></pre><blockquote><p>如果样例中的最小节点为<strong>Long.MIN_VALUE</strong>，建议避免初始化最小值，使用如下方法取到最左面的节点的数值来比较</p></blockquote><pre><code class="java">class Solution &#123;    TreeNode pre = null;    public boolean isValidBST(TreeNode root) &#123;        if(root == null) return true;        boolean left = isValidBST(root.left);        if(pre != null &amp;&amp; root.val &lt;= pre.val) return false;;        // 记录前一个节点        pre = root;        boolean right = isValidBST(root.right);        return left &amp;&amp; right;    &#125;&#125;</code></pre><h5 id="2）迭代法-13"><a href="#2）迭代法-13" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        TreeNode cur = root;        TreeNode pre = null;        while(cur != null || !stack.isEmpty()) &#123;            if(cur != null) &#123;                stack.push(cur);                cur = cur.left; // 左            &#125; else &#123;                cur = stack.pop(); // 中                if(pre != null &amp;&amp; cur.val &lt;= pre.val) return false;                pre = cur;                  cur = cur.right; // 右            &#125;        &#125;        return true;    &#125;&#125;</code></pre><h3 id="530、二叉搜索树的最小绝对差"><a href="#530、二叉搜索树的最小绝对差" class="headerlink" title="530、二叉搜索树的最小绝对差"></a>530、二叉搜索树的最小绝对差</h3><h4 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a>**</p><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/bst1.jpg" alt="img"></p><pre><code>输入：root = [4,2,6,1,3]输出：1</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/bst2.jpg" alt="img"></p><pre><code>输入：root = [1,0,48,null,null,12,49]输出：1</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <code>[2, 10^4]</code></li><li><code>0 &lt;= Node.val &lt;= 10^5</code></li></ul><h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h4><h5 id="1）递归-4"><a href="#1）递归-4" class="headerlink" title="1）递归"></a>1）递归</h5><p>方法一：最直观的想法，把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了</p><p>方法二：在二叉搜索树的中序遍历过程中，直接计算差值，需要用到一个pre节点来记录cur节点的前一个节点</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221228092838398.png" alt="image-20221228092838398"></p><h5 id="2）迭代法-14"><a href="#2）迭代法-14" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>普通迭代法</p><p>统一迭代法</p><h4 id="实现-26"><a href="#实现-26" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归-5"><a href="#1）递归-5" class="headerlink" title="1）递归"></a>1）递归</h5><p>方法一：</p><pre><code class="java">class Solution &#123;    private List&lt;Integer&gt; nodeValueList;    public int getMinimumDifference(TreeNode root) &#123;        nodeValueList = new ArrayList&lt;&gt;();        traversal(root);        if(nodeValueList.size() &lt; 2) return 0;        int result = Integer.MAX_VALUE;        for(int i = 1; i &lt; nodeValueList.size(); i++) &#123;            result = Math.min(result, nodeValueList.get(i) - nodeValueList.get(i - 1));        &#125;        return result;    &#125;        private void traversal(TreeNode root) &#123;        if(root == null) return;        traversal(root.left);        nodeValueList.add(root.val);        traversal(root.right);    &#125;&#125;</code></pre><p>方法二：</p><pre><code class="java">class Solution &#123;    int result = Integer.MAX_VALUE;    TreeNode pre = null;    public int getMinimumDifference(TreeNode root) &#123;        traversal(root);        return result;    &#125;    private void traversal(TreeNode cur) &#123;        if(cur == null) return;        traversal(cur.left);        if(pre != null) &#123;            result = Math.min(result, cur.val - pre.val);        &#125;        pre = cur;        traversal(cur.right);    &#125;&#125;</code></pre><h5 id="2）迭代法-15"><a href="#2）迭代法-15" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public int getMinimumDifference(TreeNode root) &#123;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        TreeNode cur = root;        TreeNode pre = null;        int result = Integer.MAX_VALUE;        while(cur != null || !stack.isEmpty()) &#123;            if(cur != null) &#123;                stack.push(cur);                cur = cur.left; // 左            &#125; else &#123;                cur = stack.pop(); // 中                if(pre != null) &#123;                    result = Math.min(result, cur.val - pre.val);                &#125;                 pre = cur;                  cur = cur.right; // 右            &#125;        &#125;        return result;    &#125;&#125;</code></pre><h3 id="501、二叉搜索树中的众数"><a href="#501、二叉搜索树中的众数" class="headerlink" title="501、二叉搜索树中的众数"></a>501、二叉搜索树中的众数</h3><h4 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a>**</p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p> <strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/mode-tree.jpg" alt="img"></p><pre><code>输入：root = [1,null,2,2]输出：[2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 10^4]</code> 内</li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li></ul><h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h4><h5 id="1）递归法-12"><a href="#1）递归法-12" class="headerlink" title="1）递归法"></a>1）递归法</h5><p><strong>1、如果不是二叉搜索树</strong></p><p>如果不是二叉搜索树，最直观的方法就是遍历整棵树，用map统计频率，按照频率排序，最后取前面高频的元素的集合</p><p>具体步骤：</p><ol><li><p>遍历整棵树，用map统计频率（key - 元素，value - 出现频率）</p><p>遍历顺序无所谓</p></li><li><p>统计，按照value排序</p></li><li><p>取前面高频的元素</p></li></ol><p><strong>2）如果是二叉搜索树</strong></p><p>二叉搜索树的中序遍历是有序的</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221228100114295.png" alt="image-20221228100114295"></p><p>遍历有序数组的元素出现频率，从头遍历，那么⼀定是相邻两个元素作⽐较，然后就把出现频率最⾼的元素输出就可以了。</p><p>针对于在二叉搜索树上的操作：设置⼀个指针指向前⼀个节点，这样每次<code>cur</code>（当前节点）才能和<code>pre</code>（前⼀个节点）作⽐较。 ⽽且初始化的时候<code>pre = null</code>，这样当pre为null时候，我们就知道这是⽐较的第⼀个元素。</p><pre><code class="java">if (pre == null) &#123; // 第⼀个节点    count = 1; // 频率为1&#125; else if (pre.val == cur.val) &#123; // 与前⼀个节点数值相同    count++;&#125; else &#123; // 与前⼀个节点数值不同    count = 1;&#125;pre = cur; // 更新上⼀个节点</code></pre><blockquote><p>此时又有问题了，因为要求最⼤频率的元素集合（注意是集合，不是⼀个元素，可以有多个众数），</p><p>数组的处理：应该是先遍历⼀遍数组，找出最⼤频率（<code>maxCount</code>），然后再重新遍历⼀遍数组把出现频率 为<code>maxCount</code>的元素放进集合。（因为众数有多个） 这种⽅式遍历了两遍数组。 </p><p>那么遍历两遍⼆叉搜索树，把众数集合算出来也是可以的。 但这⾥其实只需要遍历⼀次就可以找到所有的众数。</p></blockquote><p>如果频率<code>count </code>等于 <code>maxCount</code>（最⼤频率），当然要把这个元素加⼊到结果集中</p><pre><code class="java">if (count == maxCount) &#123;    resList.add(rootValue);&#125;</code></pre><p>有一个问题，如果此时的maxCount不是最大频率呢？</p><p>解决操作：频率<code>count </code>⼤于 <code>maxCount</code>的时候，不仅要更新<code>maxCount</code>，⽽且要<strong>清空结果集</strong>，因为结果集之前的元素都失效了。</p><pre><code class="java">if (count &gt; maxCount) &#123;    resList.clear();    resList.add(rootValue);    maxCount = count;&#125;</code></pre><h5 id="2）迭代法-16"><a href="#2）迭代法-16" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>普通迭代法</p><p>统一迭代法</p><h4 id="实现-27"><a href="#实现-27" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-13"><a href="#1）递归法-13" class="headerlink" title="1）递归法"></a>1）递归法</h5><p><strong>1、如果不是二叉搜索树</strong></p><pre><code class="java">class Solution &#123;    Map&lt;Integer, Integer&gt; frequencyMap;    public int[] findMode(TreeNode root) &#123;        frequencyMap = new HashMap&lt;&gt;();        if(root == null) return new int[]&#123;&#125;;        List&lt;Integer&gt; resultList = new ArrayList&lt;&gt;();        // 获取 元素值-频率 map        searchBST(root);        // 按照频率降序排列        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = frequencyMap.entrySet().stream()                .sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))                .collect(Collectors.toList());        // 取最高频次的元素        resultList.add(mapList.get(0).getKey());        // 把同样最高频次的元素加入集合        for(int i = 1; i &lt; mapList.size(); i++) &#123;            if (mapList.get(i).getValue() == mapList.get(i - 1).getValue()) &#123;                resultList.add(mapList.get(i).getKey());            &#125; else &#123;                break;            &#125;        &#125;        return resultList.stream().mapToInt(Integer::intValue).toArray();    &#125;    private void searchBST(TreeNode cur) &#123;        if (cur == null) return;        frequencyMap.put(cur.val, frequencyMap.getOrDefault(cur.val, 0) + 1);        searchBST(cur.left);        searchBST(cur.right);    &#125;&#125;</code></pre><p><strong>2、如果是二叉搜索树</strong></p><pre><code class="java">class Solution &#123;    private ArrayList&lt;Integer&gt; resultList;    private int maxCount;    private int count;    private TreeNode pre;    public Solution() &#123;        resultList = new ArrayList&lt;&gt;();        maxCount = 0;        count = 0;        pre = null;    &#125;    public int[] findMode(TreeNode root) &#123;        helper(root);        int[] result = new int[resultList.size()];        for (int i = 0; i &lt; resultList.size(); i++) &#123;            result[i] = resultList.get(i);        &#125;        return result;    &#125;    private void helper(TreeNode cur) &#123;        if(cur == null) return;        helper(cur.left);        int rootValue = cur.val;        // 计算频率        if (pre == null || pre.val != rootValue) &#123;            count = 1; // 频率为1        &#125; else if (pre.val == rootValue) &#123;            count++;        &#125;         if(count &gt; maxCount) &#123;            resultList.clear();            resultList.add(rootValue);            maxCount = count;        &#125; else if(count == maxCount)&#123;            resultList.add(rootValue);        &#125;        // 更新上⼀个节点        pre = cur;         helper(cur.right);    &#125;&#125;</code></pre><h5 id="2）迭代法-17"><a href="#2）迭代法-17" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public int[] findMode(TreeNode root) &#123;        int count = 0;        int maxCount = 0;        List&lt;Integer&gt; resultList = new ArrayList&lt;&gt;();        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        TreeNode cur = root;        TreeNode pre = null;        while(cur != null || !stack.isEmpty()) &#123;            if(cur != null) &#123;                stack.push(cur);                cur = cur.left; // 左            &#125; else &#123;                cur = stack.pop(); // 中                if(pre == null || pre.val != cur.val) &#123;                    count = 1;                &#125; else &#123;                    count++;                &#125;                if(count &gt; maxCount) &#123;                    resultList.clear();                    resultList.add(cur.val);                    maxCount = count;                &#125; else if(count == maxCount) &#123;                    resultList.add(cur.val);                &#125;                pre = cur;                  cur = cur.right; // 右            &#125;        &#125;        return resultList.stream().mapToInt(Integer::intValue).toArray();    &#125;&#125;</code></pre><h3 id="236、二叉树的最近公共祖先"><a href="#236、二叉树的最近公共祖先" class="headerlink" title="236、二叉树的最近公共祖先"></a>236、二叉树的最近公共祖先</h3><h4 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a>**</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/binarytree.png" alt="img"></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/binarytree-16722748834414.png" alt="img"></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1,2], p = 1, q = 2输出：1</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 10^5]</code> 内。</li><li><code>-10^9 &lt;= Node.val &lt;= 10^9</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h4><p>本题首先想到的是自底向上查找二叉树的节点，自底向上查找的方式：<strong>回溯、后序遍历</strong></p><p>判断一个节点是节点q和节点p的公共祖先：如果找到了一个节点，发现左子树出现节点p，右子树出现节点q，或者左子树出现节点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</p><p>流程：使用后序遍历，回溯的过程就是从底向上遍历结点，一旦发现满足这个条件的节点，就是最近公共节点。</p><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值</p><p>递归函数的返回值用来标识是否找到节点p和节点q，返回值类型为<code>boolean</code>就可以了，但是还要返回最近公共节点，可以利用题目所给函数的返回值类型<code>TreeNode</code>，如果遇到了p或者q，就返回节点p或者q，返回值不为空，就说明找到了节点p或者q</p><pre><code class="java">TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;&#125;</code></pre></li><li><p>确定终止条件</p><p>如果找到了节点p或者q，或者遇到空节点，就返回。</p><pre><code class="java">if(root == q || root == p || root == null) return root;</code></pre></li><li><p>确定单层递归的逻辑</p><p>值得关注的是本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但是本题我们依然要遍历树的所有节点。</p><p>因为本题处理返回值的方式有所不同。</p><blockquote><p>如果递归函数有返回值，如何区分要搜索一条边还是搜索整棵树？</p><ol><li><p>搜索一条边：</p><pre><code class="java">if(recursionFunction(root.left)) return;if(recursionFunction(root.right)) return;</code></pre></li><li><p>搜索整棵树：</p><pre><code class="java">left = recursionFunction(root.left);right = recursionFunction(root.right);// 处理 left 和 right</code></pre></li></ol><p>&#x3D;&gt; 在递归函数有返回值的情况下：</p><ul><li>如果要搜索一条边，递归函数返回值不为空的时候，立即返回；</li><li>如果要搜索整棵树，直接使用变量接收递归函数的返回值，并对返回值做后续处理，这也就是后序遍历中处理中间节点的逻辑（也是回溯）</li></ul></blockquote></li></ol><p>那么为什么要遍历整棵树呢？从直观上来看，找到了最近的公共祖先，直接一路返回就可以了。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221229152648409.png" alt="image-20221229152648409"></p><p>就如上图中一样，直接返回7.</p><p>但是事实上还要遍历根结点的右子树（即使此时已经找到了目标节点），也就是图中的节点4、15、20</p><p>因为在本题的后序遍历中国，如果想要利用递归函数的返回值做逻辑处理，不能立即返回，而要等着返回值逻辑处理结束后才能返回。</p><pre><code class="java">left = recursionFunction(root.left);right = recursionFunction(root.right);// 处理 left 和 right</code></pre><p>这也就是为什么要遍历整棵树的原因。</p><p>处理本题的递归函数的返回值：</p><pre><code class="java">TreeNode left = lowestCommonAncestor(root。left, p, q);TreeNode right = lowestCommonAncestor(root。right, p, q);</code></pre><ul><li>如果<code>left != null &amp;&amp; right != null</code>，就说明此时root就是最近公共节点</li><li>如果<code>left == null &amp;&amp; right != null</code>，就返回right，<strong>说明目标节点是通过right返回的</strong>，反之亦然</li></ul><blockquote><p>解释：如果<code>left == null &amp;&amp; right != null</code>，就返回right，为什么<strong>说明目标节点是通过right返回的</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221229153829948.png" alt="image-20221229153829948"></p><p>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</p></blockquote><ul><li>如果<code>left == null &amp;&amp; right == null</code>，则返回left或者right都是可以的，也就返回null</li></ul><pre><code class="java">if(left != null &amp;&amp; right != null) return root;if (left == null &amp;&amp; right != null) return right;else if (left != null &amp;&amp; right == null) return left;else &#123; // (left == null &amp;&amp; right == null)    return null;&#125;</code></pre><p>&#x3D;&gt; 寻找最小公共祖先的完成流程图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221229154346186.png" alt="image-20221229154346186"></p><p>图中可以看出回溯遍历整棵二叉树并将结果返回给根结点。</p><h4 id="实现-28"><a href="#实现-28" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        if(root == q || root == p || root == null) return root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        if(left != null &amp;&amp; right != null) return root;        if(left != null &amp;&amp; right == null) return left;        else if(left == null &amp;&amp; right != null) return right;        else return null;    &#125;&#125;</code></pre><p>精简版：</p><pre><code class="java">class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        if(root == q || root == p || root == null) return root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        if(left != null &amp;&amp; right != null) return root;        if(left != null) return left;        else return right;    &#125;&#125;</code></pre><h3 id="235、二叉搜索树的最近公共祖先"><a href="#235、二叉搜索树的最近公共祖先" class="headerlink" title="235、二叉搜索树的最近公共祖先"></a>235、二叉搜索树的最近公共祖先</h3><h4 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a>**</p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/binarysearchtree_improved.png" alt="img"></p><p><strong>示例 1:</strong></p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h4><p><strong>二叉搜索树是一颗有序树。</strong></p><p>在有序树中，如何判断一个节点的左子树里有p，右子树里有q呢？</p><p>&#x3D;&gt; 只要从上到下遍历的时候，cur节点的数值在[p.val, q.val]区间中，则说明该节点cur就是最近公共祖先了</p><p>和普通二叉树求最近公共祖先问题不同，二叉搜索树是有序的（相当于自带方向），那么只要从上向下遍历就可以了，不需要使用回溯。</p><p>此时可以采用前序遍历（其实这里没有中间结点的处理逻辑，遍历顺序是无所谓的）</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221229162510598.png" alt="image-20221229162510598"></p><p>可以看出直接按照指定的方向，就可以找到对应的节点为最近公共祖先，而且不需要遍历整棵树，找到结果就可以返回。</p><h5 id="1）递归法-14"><a href="#1）递归法-14" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值类型</p><p>参数就是当前节点，以及两个节点p, q</p><p>返回值是要返回的最近公共祖先，所以是<code>TreeNode</code></p><pre><code class="java">TreeNode traversal(TreeNode cur, TreeNode p, TreeNode q)</code></pre></li><li><p>确定终止条件</p><p>遇到空节点就可以返回了，</p><pre><code class="java">if(cur == null) return cur;</code></pre><p>其实都不需要这个终⽌条件，因为题⽬中说了p、q 为不同节点且均存在于给定的⼆叉搜索树 中。也就是说⼀定会找到公共祖先的，所以并不存在遇到空的情况。</p></li><li><p>确定单层递归的逻辑</p><p>在遍历二叉搜索树的时候就是寻找区间<code>[p.val, q.val]</code>（注意这里是左闭右闭）</p><p>1）那么如果<code>cur.val &gt; p.val &amp;&amp; cur.val &gt; q.val </code>，那就应该向左遍历，说明目标区间在左子树上。<strong>需要注意的是，此时并不知道p.val 和 q.val哪个大，所以两个都要判断</strong></p><pre><code class="java">if (cur.val &gt; p.val &amp;&amp; cur.val &gt; q.val) &#123;    TreeNode left = traversal(cur.left, p, q);    if (left != null) &#123;        return left;    &#125;&#125;</code></pre><blockquote><p>在这⾥调⽤递归函数的地⽅，把递归函数的返回值left，直接return</p><p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值不为空直接返回</p></blockquote><p>2）如果<code>cur.val &lt; p.val &amp;&amp; cur.val &lt; q.val</code>，那么就应该向右遍历，说明目标区间在右子树上</p><pre><code class="java">if (cur.val &lt; p.val &amp;&amp; cur.val &lt; q.val) &#123;    TreeNode right = traversal(cur.right, p, q);    if (right != null) &#123;        return right;    &#125;&#125;</code></pre><p>3）剩下的情况就是<code>cur.val &lt;= p.val &amp;&amp; cur.val &gt;= q.val</code>或者<code>cur.val &gt;= p.val &amp;&amp; cur.val &lt;= q.val</code>，那么cur就是最近公共祖先了，直接返回cur</p></li></ol><h5 id="2）迭代法-18"><a href="#2）迭代法-18" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>思路同递归单层处理的逻辑</p><h4 id="实现-29"><a href="#实现-29" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-15"><a href="#1）递归法-15" class="headerlink" title="1）递归法"></a>1）递归法</h5><pre><code class="java">class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        return traversal(root, p, q);    &#125;    private TreeNode traversal(TreeNode cur, TreeNode p, TreeNode q) &#123;        if(cur == null) return cur;        if(cur.val &lt; p.val &amp;&amp; cur.val &lt; q.val) &#123;            TreeNode right = traversal(cur.right, p, q);            if(right != null) &#123;                return right;            &#125;        &#125;        if (cur.val &gt; p.val &amp;&amp; cur.val &gt; q.val) &#123;            TreeNode left = traversal(cur.left, p, q);            if (left != null) &#123;                return left;            &#125;        &#125;        return cur;    &#125;&#125;</code></pre><p>精简版：</p><pre><code class="java">class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        if(root.val &gt; q.val &amp;&amp; root.val &gt; p.val) &#123;            return lowestCommonAncestor(root.left, p, q);        &#125; else if(root.val &lt; q.val &amp;&amp; root.val &lt; p.val) &#123;            return lowestCommonAncestor(root.right, p, q);        &#125; else return root;    &#125;&#125;</code></pre><h5 id="2）迭代法-19"><a href="#2）迭代法-19" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        while(root != null) &#123;            if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;                root = root.right;            &#125; else if(root.val &gt; q.val &amp;&amp; root.val &gt; p.val) &#123;                root = root.left;            &#125; else &#123;                return root;            &#125;        &#125;        return root;    &#125;&#125;</code></pre><h3 id="701、二叉搜索树中的插入操作"><a href="#701、二叉搜索树中的插入操作" class="headerlink" title="701、二叉搜索树中的插入操作"></a>701、二叉搜索树中的插入操作</h3><h4 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a>**</p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/insertbst.jpg" alt="img"></p><pre><code>输入：root = [4,2,7,1,3], val = 5输出：[4,2,7,1,3,5]解释：另一个满足题目要求可以通过的树是：</code></pre><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230090926517.png" alt="image-20221230090926517" style="zoom:50%;" /><p><strong>示例 2：</strong></p><pre><code>输入：root = [40,20,60,10,30,50,70], val = 25输出：[40,20,60,10,30,50,70,null,null,25]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5输出：[4,2,7,1,3,5]</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 10^4]</code>的范围内。</li><li><code>-10^8 &lt;= Node.val &lt;= 10^8</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-10^8 &lt;= val &lt;= 10^8</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul><h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h4><blockquote><p>其实这道题⽬其实是⼀道简单题⽬，但是题⽬中的提⽰：<strong>有多种有效的插⼊⽅式，还可以重构⼆叉搜索树</strong>，⼀下⼦提高了层次，瞬间感觉题⽬复杂了很多。 其实可以不考虑题⽬中提⽰所说的改变树的结构的插⼊⽅式。</p><p>其实只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了</p></blockquote><h5 id="1）递归法-16"><a href="#1）递归法-16" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值</p><p>参数就是根结点，以及要插入的元素。</p><p>本题递归函数的返回值可以有也可以没有，但是递归函数没有返回值的情况处理起来比较麻烦。<strong>有返回值的话，可以利用返回值完成新加入节点与其父结点的赋值操作</strong>，递归函数的返回值类型为<code>TreeNode</code></p><pre><code class="java">TreeNode insertIntoBST(TreeNode root, int val)</code></pre></li><li><p>确定终止条件</p><p>终止条件就是找到遍历的节点为null的时候，就是要插入节点的位置了，并把插入的节点返回</p><pre><code class="java">if(root == null) &#123;    TreeNode node = new TreeNode(val);    return node;&#125;</code></pre><p>此处把添加的节点返回给上一层，就完成了父子节点的赋值操作了</p></li><li><p>确定单层递归的逻辑</p><p>由于是二叉搜索树BST，所以不需要遍历整棵树。搜索树是有方向的，可以根据插入元素的数值，决定递归方向</p><pre><code class="java">if(root.val &lt; val) root.right = insertIntoBST(root.right, val);if(root.val &gt; val) root.left = insertIntoBST(root.left, val);return root;</code></pre><p>本层通过<code>root.left</code>或者<code>root.right</code>接收递归函数返回值，这也就通过递归函数返回值完成了新加入节点的父子关系赋值操作</p><blockquote><p><strong>没有返回值的话</strong>，找到插入位置，直接让其父结点指向插入节点，结束递归</p><p>递归函数定义：</p><pre><code class="java">TreeNode parent = null; // 记录遍历节点的父结点void traversal(TreeNode cur, int val)</code></pre><p>没有返回值，需要记录上一个节点(<code>parent</code>)，遇到空节点了，就让parent左节点或者右节点指向新插入的节点。</p></blockquote></li></ol><h5 id="2）迭代法-20"><a href="#2）迭代法-20" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>在迭代法遍历的过程中，需要记录下当前遍历的节点的父结点，这样才能做插入节点的操作</p><p>在**<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a><strong>和</strong><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a>**中都是使用了<code>pre</code>和<code>cur</code>两个指针，在本题也适用。</p><h4 id="实现-30"><a href="#实现-30" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-17"><a href="#1）递归法-17" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>递归函数带返回值：</p><pre><code class="java">class Solution &#123;    public TreeNode insertIntoBST(TreeNode root, int val) &#123;        if(root == null) return new TreeNode(val);        if(root.val &lt; val) root.right = insertIntoBST(root.right, val);        if(root.val &gt; val) root.left = insertIntoBST(root.left, val);        return root;    &#125;&#125;</code></pre><p>递归函数不带返回值</p><pre><code class="java">class Solution &#123;    private TreeNode parent;    public TreeNode insertIntoBST(TreeNode root, int val) &#123;        if(root == null) &#123;            return new TreeNode(val);        &#125;        traversal(root, val);        return root;    &#125;    private void traversal(TreeNode cur, int val) &#123;        if(cur == null) &#123;            TreeNode node = new TreeNode(val);            if(val &gt; parent.val) parent.right = node;            else parent.left = node;            return;        &#125;        parent = cur;        if(val &lt; cur.val) traversal(cur.left, val);        if(val &gt; cur.val) traversal(cur.right, val);    &#125;&#125;</code></pre><h5 id="2）迭代法-21"><a href="#2）迭代法-21" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public TreeNode insertIntoBST(TreeNode root, int val) &#123;        if(root == null) return new TreeNode(val);        TreeNode cur = root;        // 记录上一个节点，方便进行插入节点的操作        TreeNode pre = root;        while(cur != null) &#123;            pre = cur;            if(cur.val &gt; val) cur = cur.left;            else cur = cur.right;        &#125;        TreeNode node = new TreeNode(val);        if(pre.val &gt; val) pre.left = node;        else pre.right = node;                return root;    &#125;&#125;</code></pre><h3 id="450、删除二叉搜索树中的节点"><a href="#450、删除二叉搜索树中的节点" class="headerlink" title="450、删除二叉搜索树中的节点"></a>450、删除二叉搜索树中的节点</h3><h4 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a>**</p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img src="E:/MyFile/TyporaImgs/del_node_1.jpg" alt="img"></p><pre><code>输入：root = [5,3,6,2,4,null,7], key = 3输出：[5,4,6,2,null,null,7]解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。</code></pre><img src="E:/MyFile/TyporaImgs/image-20221230095022389.png" alt="image-20221230095022389" style="zoom: 50%;" /><p><strong>示例 2:</strong></p><pre><code>输入: root = [5,3,6,2,4,null,7], key = 0输出: [5,3,6,2,4,null,7]解释: 二叉树不包含值为 0 的节点</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: root = [], key = 0输出: []</code></pre><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 10^4]</code>.</li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-10^5 &lt;= key &lt;= 10^5</code></li></ul><h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h4><h5 id="1）递归法-18"><a href="#1）递归法-18" class="headerlink" title="1）递归法"></a>1）递归法</h5><p>递归三部曲：</p><ol><li><p>确定递归函数参数以及返回值</p><p>参数就是根结点和要删除的节点值，返回值同**<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a>**，本题也可以通过递归返回值来删除节点</p><pre><code class="java">TreeNode deleteNode(TreeNode root, int val)</code></pre></li><li><p>确定终止条件</p><p>遇到空节点返回，这也说明没有找到要删除的节点，遍历到空节点直接返回了</p><pre><code class="java">if(root == null) return root;</code></pre></li><li><p>确定单层递归的逻辑</p><p>平衡二叉树中删除结点的情况有以下五种：</p><p>没找到删除的节点</p><ul><li>情况一：遍历到空节点直接返回</li></ul><p>找到删除的节点：</p><ul><li><p>情况二：左右节点都为空，直接删除节点，返回null为根结点</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230100313240.png" alt="image-20221230100313240"></p></li><li><p>情况三：删除结点的左节点为空，右节点不为空，删除结点，右节点补位，返回右节点为根结点</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230100302623.png" alt="image-20221230100302623"></p></li><li><p>情况四：删除结点的右节点为空，左节点不为空，删除结点，左节点补位，返回左节点为根结点</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230100253791.png" alt="image-20221230100253791"></p></li><li><p>情况五：删除结点的左右节点都不为空，则将删除结点的左子树头节点（删除结点的左节点）放到删除结点的右子树的最左面结点的左节点上，返回删除结点的右节点为新的根结点</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230100217296.png" alt="image-20221230100217296"></p></li></ul><pre><code class="java">// 情况一：遍历到空节点直接返回if(root == null) return root;if(root.val == key) &#123;    // 情况二：左右节点都为空，直接删除节点，返回null为根结点    // 情况三：删除结点的左节点为空，右节点不为空，删除结点，右节点补位，返回右节点为根结点    if(root.left == null) return root.right;    // 情况四：删除结点的右节点为空，左节点不为空，删除结点，左节点补位，返回左节点为根结点    else if(root.right == null) return root.left;    // 情况五：删除结点的左右节点都不为空，则将删除结点的左子树头节点（删除结点的左节点）放到删除结点的右子树的最左面结点的左节点上    // 返回删除结点的右节点为新的根结点    else &#123;        // 寻找右子树最左面的节点        TreeNode cur = root.right;        while(cur.left != null) &#123;            cur = cur.left;        &#125;        // 把要删除的节点(root)左子树放在cur的左节点的位置        cur.left = root.left;        // 返回root的右节点作为新的root        return root.right;    &#125;   &#125;</code></pre><p>此处相当于把新的节点返回给上一层，上一层需要接收返回值</p><pre><code class="java">if(root.val &gt; key) root.left = deleteNode(root.left, key);if(root.val &lt; key) root.right = deleteNode(root.right, key);return root;</code></pre></li></ol><h5 id="2）普通二叉树的删除方式"><a href="#2）普通二叉树的删除方式" class="headerlink" title="2）普通二叉树的删除方式"></a>2）普通二叉树的删除方式</h5><p>普通⼆叉树的删除⽅式（没有使⽤搜索树的特性，遍历整棵树），⽤交换值的操作来删除⽬标节点</p><p>此处目标节点（要删除的节点）被操作了两次：</p><ul><li>第一次是和目标节点的右子树最左面的节点交换</li><li>第二次直接被null覆盖了</li></ul><h5 id="3）迭代法"><a href="#3）迭代法" class="headerlink" title="3）迭代法"></a>3）迭代法</h5><p>思想跟递归一样，最关键的是删除结点的操作</p><h4 id="实现-31"><a href="#实现-31" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-19"><a href="#1）递归法-19" class="headerlink" title="1）递归法"></a>1）递归法</h5><pre><code class="java">class Solution &#123;    public TreeNode deleteNode(TreeNode root, int key) &#123;        // 情况一：遍历到空节点直接返回        if(root == null) return root;        if(root.val == key) &#123;            // 情况二：左右节点都为空，直接删除节点，返回null为根结点            // 情况三：删除结点的左节点为空，右节点不为空，删除结点，右节点补位，返回右节点为根结点            if(root.left == null) return root.right;            // 情况四：删除结点的右节点为空，左节点不为空，删除结点，左节点补位，返回左节点为根结点            else if(root.right == null) return root.left;            // 情况五：删除结点的左右节点都不为空，则将删除结点的左子树头节点（删除结点的左节点）放到删除结点的右子树的最左面结点的左节点上            // 返回删除结点的右节点为新的根结点            else &#123;                // 寻找右子树最左面的节点                TreeNode cur = root.right;                while(cur.left != null) &#123;                    cur = cur.left;                &#125;                // 把要删除的节点(root)左子树放在cur的左节点的位置                cur.left = root.left;                // 返回root的右节点作为新的root                return root.right;            &#125;           &#125;        if(root.val &gt; key) root.left = deleteNode(root.left, key);        if(root.val &lt; key) root.right = deleteNode(root.right, key);        return root;    &#125;&#125;</code></pre><h5 id="2）普通二叉树的删除"><a href="#2）普通二叉树的删除" class="headerlink" title="2）普通二叉树的删除"></a>2）普通二叉树的删除</h5><pre><code class="java">class Solution &#123;    public TreeNode deleteNode(TreeNode root, int key) &#123;        if(root == null) &#123;            return root;        &#125;        if(root.val == key) &#123;            // 第二次操作目标值：最终删除的作用            if(root.right == null) &#123;                return root.left;            &#125;            TreeNode cur = root.right;            while(cur.left != null) &#123;                cur = cur.left;            &#125;            // 第一次操作目标值，交换目标值其右子树最左面节点的值            int tmp = root.val;            root.val = cur.val;            cur.val = tmp;        &#125;        root.left = deleteNode(root.left, key);        root.right = deleteNode(root.right, key);        return root;    &#125;&#125;</code></pre><h5 id="3）迭代法-1"><a href="#3）迭代法-1" class="headerlink" title="3）迭代法"></a>3）迭代法</h5><pre><code class="java">class Solution &#123;    public TreeNode deleteNode(TreeNode root, int key) &#123;        if(root == null) return root;        TreeNode cur = root;        TreeNode pre = null;        while(cur != null) &#123;            if(cur.val == key) break;            pre = cur;            if(cur.val &gt; key) cur = cur.left;            else cur = cur.right;        &#125;        // 如果搜索树只有头节点        if(pre == null) &#123;            return deleteOneNode(cur);        &#125;        // pre 要知道是删左节点还是右节点        if(pre.left != null &amp;&amp; pre.left.val == key) &#123;            pre.left = deleteOneNode(cur);        &#125;        if(pre.right != null &amp;&amp; pre.right.val == key) &#123;            pre.right = deleteOneNode(cur);        &#125;        return root;    &#125;    /*        将目标节点（删除结点）的左子树放到目标节点的右子树的最左面节点的左节点的位置上        并返回目标节点右孩子作为新的根结点        对应情况五     */    private TreeNode deleteOneNode(TreeNode target) &#123;        if(target == null) return target;        if(target.right == null) return target.left;        TreeNode cur = target.right;        while(cur.left != null) &#123;            cur = cur.left;        &#125;        cur.left = target.left;        return target.right;    &#125;&#125;</code></pre><h3 id="669、修建二叉搜索树"><a href="#669、修建二叉搜索树" class="headerlink" title="669、修建二叉搜索树"></a>669、修建二叉搜索树</h3><h4 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a>**</p><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例 1：</strong></p><p><img src="E:/MyFile/TyporaImgs/trim1.jpg" alt="img"></p><pre><code>输入：root = [1,0,2], low = 1, high = 2输出：[1,null,2]</code></pre><p><strong>示例 2：</strong></p><p><img src="E:/MyFile/TyporaImgs/trim2.jpg" alt="img"></p><pre><code>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3输出：[3,2,null,1]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数在范围 <code>[1, 10^4]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 10^4</code></li><li>树中每个节点的值都是 <strong>唯一</strong> 的</li><li>题目数据保证输入是一棵有效的二叉搜索树</li><li><code>0 &lt;= low &lt;= high &lt;= 10^4</code></li></ul><h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h4><h5 id="1）递归法-20"><a href="#1）递归法-20" class="headerlink" title="1）递归法"></a>1）递归法</h5><blockquote><p>直接想法就是：递归处理，然后遇到<code>root.val &lt; low || root.val &gt; high</code>的时候直接<code>return null</code>，</p><pre><code class="java">class Solution &#123;    public TreeNode trimBST(TreeNode root, int low, int high) &#123;        if (root == null || root.val &lt; low || root.val &gt; high)            return null;        root.left = trimBST(root.left, low, high);        root.right = trimBST(root.right, low, high);        return root;    &#125;&#125;;</code></pre><p><strong>然⽽[1, 3]区间在⼆叉搜索树的中可不是单纯的节点3和左孩⼦节点0就决定的，还要考虑节点0的右⼦树。</strong></p><p>第二个示例：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230104800238.png" alt="image-20221230104800238"></p><p>所以以上代码是行不通的</p></blockquote><p>从图中可以看出需要重构二叉树，但其实不需要重构二叉树。</p><p>从上图中可以发现节点0不符合区间要求，那么将节点0的右节点2直接赋给节点3的左节点就可以了（就是把节点0从二叉树中移除）</p><img src="E:/MyFile/TyporaImgs/image-20221230105457413.png" alt="image-20221230105457413" style="zoom: 67%;" /><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值</p><p>参数就是根结点和区间值。</p><p>此处为什么需要返回值？因为是要遍历整棵树，做修改，其实不需要返回值也可以，同样可以完成修改（其实就是从二叉树中移除节点）的操作，但是有返回值，更方便，可以通过递归函数的返回值来移除节点</p><pre><code class="java">TreeNode trimBST(TreeNode root, int low, int high)</code></pre></li><li><p>确定终止条件</p><p>修建的操作并不是在终止条件上进行的，所以遇到空节点返回就可以了</p><pre><code class="java">if(root == null) return root;</code></pre></li><li><p>确定单层递归的逻辑</p><ul><li><p>如果<code>root</code>（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头节点。</p><pre><code class="java">if (root.val &lt; low) &#123;    TreeNode right = trimBST(root.right, low, high); // 寻找符合区间[low, high]的节点    return right;&#125;</code></pre></li><li><p>如果<code>root</code>（当前节点）的元素大于high的数值，那么应该递归左子树，并返回左子树符合条件的头节点。</p><pre><code class="java">if (root.val &gt; high) &#123;    TreeNode left = trimBST(root.left, low, high); // 寻找符合区间[low, high]的节点    return left;&#125;</code></pre></li><li><p>接下来要将下一层处理完的左子树的结果赋给<code>root.left</code>，处理完的右子树的结果赋给<code>root.right</code>，最后返回<code>root</code>节点</p><pre><code class="java">root.left = trimBST(root.left, low, right);// root.left接⼊符合条件的左孩⼦root.right = trimBST(root.right, low, right);// root.right接⼊符合条件的右孩⼦return root;</code></pre></li></ul><blockquote><p>回顾下移除节点的过程：</p><img src="E:/MyFile/TyporaImgs/image-20221230110655079.png" alt="image-20221230110655079" style="zoom:67%;" /><p>如下代码相当于把节点0的右节点（节点2）返回给上一层</p><pre><code class="java">if (root.val &lt; low) &#123;    TreeNode right = trimBST(root.right, low, high); // 寻找符合区间[low, high]的节点    return right;&#125;</code></pre><p>然后如下代码相当于用节点3的左节点接收下一层返回的节点2</p><pre><code class="java">root.left = trimBST(root.left, low, right);// root.left接⼊符合条件的左孩⼦</code></pre><p>此时节点3的左节点变成了节点2，将节点0从二叉树中移除了</p></blockquote></li></ol><h5 id="2）迭代法-22"><a href="#2）迭代法-22" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>因为二叉搜索树的有序性，不需要使用栈来模拟递归的过程</p><p>在剪枝的时候，可以分成三步：</p><ul><li>将<code>root</code>移动到<code>[low, high]</code>范围内，注意是左闭右闭</li><li>剪枝左子树</li><li>剪枝右子树</li></ul><h4 id="实现-32"><a href="#实现-32" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-21"><a href="#1）递归法-21" class="headerlink" title="1）递归法"></a>1）递归法</h5><pre><code class="java">class Solution &#123;    public TreeNode trimBST(TreeNode root, int low, int high) &#123;        if(root == null) return root;        if(root.val &lt; low) &#123;            return trimBST(root.right, low, high);        &#125;        if(root.val &gt; high) &#123;            return trimBST(root.left, low, high);        &#125;        root.left = trimBST(root.left, low, high);        root.right = trimBST(root.right, low, high);        return root;    &#125; &#125;</code></pre><h5 id="2）迭代法-23"><a href="#2）迭代法-23" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public TreeNode trimBST(TreeNode root, int low, int high) &#123;        if(root == null) return root;        // 处理头结点，将root移动到[low, high]范围内，注意是左闭右闭        while(root != null &amp;&amp; (root.val &gt; high || root.val &lt; low)) &#123;            // 小于low 向右走            if(root.val &lt; low) root = root.right;            // 大于high往左走            else root = root.left;        &#125;        TreeNode cur = root;        // 此时root已经在[low, high]范围内，处理左节点元素小于low的情况        while(cur != null) &#123;            while(cur.left != null &amp;&amp; cur.left.val &lt; low) &#123;                cur.left = cur.left.right;            &#125;            cur = cur.left;        &#125;        cur = root;        // 此时root已经在[low, high]范围内，处理右节点元素大于high的情况        while(cur != null) &#123;            while(cur.right != null &amp;&amp; cur.right.val &gt; high) &#123;                cur.right = cur.right.left;            &#125;            cur = cur.right;        &#125;        return root;    &#125;&#125;</code></pre><h3 id="108、将有序数组转换成为二叉搜索树"><a href="#108、将有序数组转换成为二叉搜索树" class="headerlink" title="108、将有序数组转换成为二叉搜索树"></a>108、将有序数组转换成为二叉搜索树</h3><h4 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h4><p>题目链接：</p><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img src="E:/MyFile/TyporaImgs/btree1.jpg" alt="img"></p><pre><code>输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</code></pre><img src="E:/MyFile/TyporaImgs/image-20221230121012695.png" alt="image-20221230121012695" style="zoom:67%;" /><p><strong>示例 2：</strong></p><p><img src="E:/MyFile/TyporaImgs/btree.jpg" alt="img"></p><pre><code>输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题其实不需要强调平衡二叉搜索树，数组构造二叉树，构造成平衡树是自然而然的事，因为默认都是从数组中间位置取值作为节点元素，一般不会随便取，所以想构造成不平衡的二叉树是自找麻烦</p></blockquote><p>本题<strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong></p><blockquote><p>本题其实比<a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a>、<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a>、<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a>要简单一些，因为有序数组构造二叉搜索树，寻找分割点比较容易</p></blockquote><p><strong>分割点就是数组中间位置的节点。</strong></p><blockquote><p>问题：如果数组长度为偶数，中间结点有两个，取哪一个合适？</p><p>取哪一个都可以，只不过构成了不同的平衡二叉树</p><p>例如：[-10,-3,0,5,9]</p><p>如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素就是树1，取右边元素就是树2（这也是题目中强调答案不唯一的原因）</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230122247062.png" alt="image-20221230122247062"></p></blockquote><h5 id="1）递归-6"><a href="#1）递归-6" class="headerlink" title="1）递归"></a>1）递归</h5><p>递归三部曲：</p><ol><li><p>确定递归函数的参数以及返回值</p><p>删除二叉树节点、增加二叉树节点都是通过用递归函数的返回值来完成，这样相对方便。本题要构造二叉树，依然使用递归函数的返回值来构造中间结点的左右节点，返回值类型为<code>TreeNode</code></p><p>参数首先是传入数组，然后就是左闭右闭区间<code>[left, right]</code>，构造二叉树的时候尽量不要重新定义左右区间数组，而是使用下标的方式操作数组</p><pre><code class="java">// 左闭右闭区间[left, right]TreeNode traversal(int[] nums, int left, int right)</code></pre><p><strong>注意：左闭右闭区间是一个循环不变量</strong></p></li><li><p>确定终止条件</p><p>此处定义的是左闭右闭区间，所以当区间<code>left &gt; right</code>的时候，就是空节点了</p><pre><code class="java">if(left &gt; right) return null;</code></pre></li><li><p>确定单层递归的逻辑</p><p>1）首先取数组中间元素的位置，<code>int mid = left + (right - left) / 2</code></p><p>2）构造节点：<code>TreeNode root = new TreeNode(nums[mid])</code></p><p>3）划分区间，root的左节点接收下一层左区间的构造的节点，右节点接收下一层右区间构造的节点</p><p>4）返回<code>root</code></p><pre><code class="java"></code></pre><blockquote><p>这里<code>int mid = left + (right - left) / 2</code>的写法是向下取整的，也就是说如果数组长度为偶数，中间位置有两个元素，取靠左边的</p></blockquote></li></ol><h5 id="2）迭代法-24"><a href="#2）迭代法-24" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>迭代法可以通过三个队列来模拟，一个队列放遍历的节点，一个队列放左区间下标，一个队列放右区间下标</p><p>模拟的就是不断分割的过程</p><h4 id="实现-33"><a href="#实现-33" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归法-22"><a href="#1）递归法-22" class="headerlink" title="1）递归法"></a>1）递归法</h5><pre><code class="java">class Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        return traversal(nums, 0, nums.length - 1);    &#125;    private TreeNode traversal(int[] nums, int left, int right) &#123;        if(left &gt; right) return null;        int mid = left + (right - left) / 2;        TreeNode root = new TreeNode(nums[mid]);        root.left = traversal(nums, left, mid - 1);        root.right = traversal(nums, mid + 1, right);        return root;    &#125;&#125;</code></pre><h5 id="2）迭代法-25"><a href="#2）迭代法-25" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;        if(nums.length == 0) return null;        // 初始化根结点        TreeNode root = new TreeNode(0);        // 存放遍历的节点        Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;();        // 存放左区间下标        Queue&lt;Integer&gt; leftQueue = new LinkedList&lt;&gt;();        // 存放右区间下标        Queue&lt;Integer&gt; rightQueue = new LinkedList&lt;&gt;();        // 根结点入队列        nodeQueue.offer(root);        // 0为左区间下标初始位置        leftQueue.offer(0);        // nums.length - 1为右区间下标初识位置        rightQueue.offer(nums.length - 1);        while(!nodeQueue.isEmpty()) &#123;            TreeNode curNode = nodeQueue.poll();            int leftIndex = leftQueue.poll();            int rightIndex = rightQueue.poll();            int mid = leftIndex + (rightIndex - leftIndex) / 2;            // 将mid对应的元素赋值给中间节点            curNode.val = nums[mid];            // 处理左区间            if(leftIndex &lt;= mid - 1) &#123;                curNode.left = new TreeNode(0);                nodeQueue.offer(curNode.left);                leftQueue.offer(leftIndex);                rightQueue.offer(mid - 1);            &#125;             // 处理右区间            if(rightIndex &gt;= mid + 1) &#123;                curNode.right = new TreeNode(0);                nodeQueue.offer(curNode.right);                leftQueue.offer(mid + 1);                rightQueue.offer(rightIndex);            &#125;        &#125;        return root;    &#125;&#125;</code></pre><h3 id="538、把二叉搜索树转换为累加树"><a href="#538、把二叉搜索树转换为累加树" class="headerlink" title="538、把二叉搜索树转换为累加树"></a>538、把二叉搜索树转换为累加树</h3><h4 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a>**</p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><strong><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/tree.png" alt="img"></strong></p><pre><code>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [0,null,1]输出：[1,null,1]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1,0,2]输出：[3,3,2]</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：root = [3,2,4,1]输出：[7,9,4,10]</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数介于 <code>0</code> 和 <code>10^4</code> 之间。</li><li>每个节点的值介于 <code>-10^4</code> 和 <code>10^4</code> 之间。</li><li>树中的所有值 <strong>互不相同</strong> 。</li><li>给定的树为二叉搜索树。</li></ul><h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h4><p>由于二叉搜索树是有序的，那么有序的元素如何求累加呢？</p><p>其实换个角度看，这就是一个有序数组，例如<code>[2, 5, 13]</code>，求从后到前的累加数组，也就是<code>[20, 18, 13]</code></p><p>数组是从后向前遍历，那么二叉搜索树的累加顺序是<strong>右中左</strong>，所以我们需要<strong>反中序遍历</strong>这棵二叉树，然后顺序累加</p><h5 id="1）递归-7"><a href="#1）递归-7" class="headerlink" title="1）递归"></a>1）递归</h5><p>反中序遍历流程：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221230125801624.png" alt="image-20221230125801624"></p><p>本题依然需要一个pre指针记录当前遍历结点cur的前一个节点，这样才方便做累加</p><p>递归三部曲：</p><ol><li><p>确定递归函数的参数和返回值</p><p>此处不需要递归函数的返回值，因为要遍历整棵树</p><p>同时需要定义一个全局变量pre，用来保存cur节点的前一个节点的数值，定义为<code>int</code>类型</p><pre><code class="java">int pre; // 记录前一个节点的数值void traversal(TreeNode cur)</code></pre></li><li><p>确定终止条件</p><p>遇到空节点就返回</p><pre><code class="java">if(cur == null) return;</code></pre></li><li><p>确定单层递归的逻辑</p><p>注意要<strong>右中左</strong>的顺序来遍历二叉树，中间节点的处理逻辑就是<code>cur.val += pre</code></p><pre><code class="java">traversal(cur.right); // 右cur.val += pre; // 中pre = cur.val;traversal(cur.left); // 左</code></pre></li></ol><h5 id="2）迭代法-26"><a href="#2）迭代法-26" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><p>迭代法其实就是中序模板题</p><h4 id="实现-34"><a href="#实现-34" class="headerlink" title="实现"></a>实现</h4><h5 id="1）递归-8"><a href="#1）递归-8" class="headerlink" title="1）递归"></a>1）递归</h5><pre><code class="java">class Solution &#123;    private int pre;    public TreeNode convertBST(TreeNode root) &#123;        traversal(root);        return root;    &#125;    private void traversal(TreeNode cur) &#123;        if(cur == null) return;        traversal(cur.right);        cur.val += pre;        pre = cur.val;        traversal(cur.left);    &#125;&#125;</code></pre><h5 id="2）迭代法-27"><a href="#2）迭代法-27" class="headerlink" title="2）迭代法"></a>2）迭代法</h5><pre><code class="java">class Solution &#123;    public TreeNode convertBST(TreeNode root) &#123;        if(root == null) return root;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        TreeNode cur = root;        int pre = 0;        while(cur != null || !stack.isEmpty()) &#123;            if(cur != null) &#123;                stack.push(cur);                cur = cur.right; // 右            &#125; else &#123;                cur = stack.pop();                cur.val += pre; // 中                pre = cur.val;                cur = cur.left; // 左            &#125;        &#125;         return root;    &#125;&#125;</code></pre><h1 id="二叉树篇–总结"><a href="#二叉树篇–总结" class="headerlink" title="二叉树篇–总结"></a>二叉树篇–总结</h1><p>上述题目分类</p><ul><li>涉及到二叉树的构造，无论是普通二叉树还是二叉搜索树，一定是前序遍历，都是先构造中间结点</li><li>求普通二叉树的属性，一般是后序遍历，一般需要递归函数的返回值做处理</li><li>求二叉搜索树的属性，一定是中序遍历，利用好二叉搜索树的有序性</li></ul><blockquote><p>注意在普通二叉树的属性中，一般是后序遍历，也有例外，例如单纯求深度就使用前序遍历，**<a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径 - 力扣（LeetCode）</a>**也使用了前序，这是为了方便让父结点指向子节点，所以求普通二叉树的属性还是要具体问题具体分析</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> BinaryTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型模式</title>
      <link href="/2022/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E4%BA%8C%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F">二、结构型模式</a><ul><li><a href="#1%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">1、代理模式</a><ul><li><a href="#11-%E6%A6%82%E8%BF%B0">1.1 概述</a></li><li><a href="#12-%E7%BB%93%E6%9E%84">1.2 结构</a></li><li><a href="#13-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">1.3 静态代理</a></li><li><a href="#14-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.4 JDK动态代理</a></li><li><a href="#15-cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1.5 CGLIB动态代理</a></li><li><a href="#16-%E4%B8%89%E7%A7%8D%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94">1.6 三种代理的对比</a></li><li><a href="#17-%E4%BC%98%E7%BC%BA%E7%82%B9">1.7 优缺点</a></li><li><a href="#18-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">1.8 使用场景</a></li></ul></li><li><a href="#2%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">2、适配器模式</a><ul><li><a href="#21-%E6%A6%82%E8%BF%B0">2.1 概述</a></li><li><a href="#22-%E7%BB%93%E6%9E%84">2.2 结构</a></li><li><a href="#23-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">2.3 类适配器模式</a></li><li><a href="#24-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">2.4 对象适配器模式</a></li><li><a href="#25-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">2.5 应用场景</a></li><li><a href="#26-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">2.6 JDK源码解析</a></li></ul></li><li><a href="#3%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F">3、装饰者模式</a><ul><li><a href="#31-%E6%A6%82%E8%BF%B0">3.1 概述</a></li><li><a href="#32-%E7%BB%93%E6%9E%84">3.2 结构</a></li><li><a href="#33-%E6%A1%88%E4%BE%8B">3.3 案例</a></li><li><a href="#34-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">3.4 使用场景</a></li><li><a href="#35-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">3.5 JDK源码解析</a></li><li><a href="#36-%E4%BB%A3%E7%90%86%E5%92%8C%E8%A3%85%E9%A5%B0%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB">3.6 代理和装饰者的区别</a></li></ul></li><li><a href="#4%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">4、桥接模式</a><ul><li><a href="#41-%E6%A6%82%E8%BF%B0">4.1 概述</a></li><li><a href="#42-%E7%BB%93%E6%9E%84">4.2 结构</a></li><li><a href="#43-%E6%A1%88%E4%BE%8B">4.3 案例</a></li><li><a href="#44-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">4.4 使用场景</a></li></ul></li><li><a href="#5%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">5、外观模式</a><ul><li><a href="#51-%E6%A6%82%E8%BF%B0">5.1 概述</a></li><li><a href="#52-%E7%BB%93%E6%9E%84">5.2 结构</a></li><li><a href="#53-%E6%A1%88%E4%BE%8B">5.3 案例</a></li><li><a href="#54-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">5.4 使用场景</a></li><li><a href="#55-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">5.5 JDK源码解析</a></li></ul></li><li><a href="#6%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">6、组合模式</a><ul><li><a href="#61-%E6%A6%82%E8%BF%B0">6.1 概述</a></li><li><a href="#62-%E7%BB%93%E6%9E%84">6.2 结构</a></li><li><a href="#63-%E6%A1%88%E4%BE%8B">6.3 案例</a></li><li><a href="#64-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB">6.4 组合模式的分类</a></li><li><a href="#65-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9">6.5 组合模式的优点</a></li><li><a href="#66-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">6.6 使用场景</a></li></ul></li><li><a href="#7%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">7、享元模式</a><ul><li><a href="#71-%E6%A6%82%E8%BF%B0">7.1 概述</a></li><li><a href="#72-%E7%BB%93%E6%9E%84">7.2 结构</a></li><li><a href="#73-%E6%A1%88%E4%BE%8B">7.3 案例</a></li><li><a href="#75-%E4%BC%98%E7%BC%BA%E7%82%B9">7.5 优缺点</a></li><li><a href="#76-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">7.6 使用场景</a></li><li><a href="#77-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">7.7 JDK源码解析</a></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><blockquote><p>完整代码地址：<a href="https://gitee.com/ding-xinliang/design-pattern">DesignPattern: Java设计模式 (gitee.com)</a></p></blockquote><h1 id="二、结构型模式"><a href="#二、结构型模式" class="headerlink" title="二、结构型模式"></a>二、结构型模式</h1><p><strong>结构型模式描述了如何将类或者对象按照某种布局组成更大的结构。</strong>它分为类结构型模式和对象结构型模式，前者采用继承机制来组织类或者接口，后者采用组合或者聚合来组合对象。</p><p>由于组合关系或者聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>桥接模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="1、代理模式"><a href="#1、代理模式" class="headerlink" title="1、代理模式"></a>1、代理模式</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。此时访问对象不适合或者不能直接引用目标对象，<strong>代理对象就作为访问对象和目标对象之间的中介</strong>。</p><p>Java中的代理按照代理类生成时机不同又分为<strong>静态代理</strong>和<strong>动态代理</strong>。静态代理代理类在<strong>编译期</strong>就生成，而动态代理代理类则是在Java<strong>运行时</strong>动态生成。动态代理又有<strong>JDK代理</strong>和<strong>CGLib代理</strong>两种。</p><h3 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2 结构"></a>1.2 结构</h3><p>代理(<code>Proxy</code>)模式分为三种角色：</p><ul><li>抽象主题(<code>Subject</code>)类：通过接口或者抽象类声明真实主题和代理对象实现的业务方法</li><li>真实主题（<code>Real Subject</code>）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li><li>代理（<code>Proxy</code>）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能</li></ul><h3 id="1-3-静态代理"><a href="#1-3-静态代理" class="headerlink" title="1.3 静态代理"></a>1.3 静态代理</h3><p>【例子】火车站买票</p><p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86.png" alt="静态代理"></p><p>代码实现：</p><p><strong>SellTickets接口</strong></p><pre><code class="java">/** * 买票接口 * * @author codejuzi */public interface SellTickets &#123;    void sellTickets();&#125;</code></pre><p><strong>TrainStation类</strong></p><pre><code class="java">/** * 火车站 * * @author codejuzi */public class TrianStation implements SellTickets&#123;    @Override    public void sellTickets() &#123;        System.out.println(&quot;火车站卖票……&quot;);    &#125;&#125;</code></pre><p><strong>ProxyPoint类</strong></p><pre><code class="java">/** * 火车票代售点（代理类） * * @author codejuzi */public class ProxyPoint implements SellTickets&#123;    private final TrianStation station;    public ProxyPoint() &#123;        this.station = new TrianStation();    &#125;    @Override    public void sellTickets() &#123;        System.out.println(&quot;代售点卖票……（收取手续费）&quot;);        station.sellTickets();    &#125;&#125;</code></pre><p><strong>Client（测试类）</strong></p><pre><code class="java">class ProxyPointTest &#123;    @Test    void sellTickets() &#123;        ProxyPoint proxyPoint = new ProxyPoint();        proxyPoint.sellTickets();    &#125;&#125;</code></pre><p><strong>说明：</strong>从上面代码中可以看出测试类直接访问的是<code>ProxyPoint</code>类对象，也就是说<code>ProxyPoint</code>作为访问对象和目标对象的中介。同时也对<code>sellTickets</code>方法进行了增强（代理点收取一些服务费用）。</p><h3 id="1-4-JDK动态代理"><a href="#1-4-JDK动态代理" class="headerlink" title="1.4 JDK动态代理"></a>1.4 JDK动态代理</h3><p>Java中提供了一个动态代理类<code>Proxy</code>，<code>Proxy</code>并不是上述所说的代理对象的类，而是<strong>提供了一个创建代理对象的静态方法</strong>（<code>newProxyInstance</code>方法）来<strong>获取代理对象</strong>。</p><p><strong>SellTickets接口</strong></p><pre><code class="java">/** * 买票接口 * * @author codejuzi */public interface SellTickets &#123;    void sellTickets();&#125;</code></pre><p><strong>TrainStation类</strong></p><pre><code class="java">/** * 火车站 * * @author codejuzi */public class TrianStation implements SellTickets &#123;    @Override    public void sellTickets() &#123;        System.out.println(&quot;火车站卖票……&quot;);    &#125;&#125;</code></pre><p><strong>ProxyFactory类</strong></p><pre><code class="java">/** * 代理工厂类，创建代理对象 */public class ProxyFactory &#123;    private TrianStation station;    public ProxyFactory() &#123;        station = new TrianStation();    &#125;    /**     * 使用Proxy获取代理对象     *     * newProxyInstance()方法参数说明：     * ClassLoader loader ： 类加载器，用于加载代理类，真实使用时，使用真实对象的类加载器即可     * Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口     * InvocationHandler h ： 代理对象的调用处理程序     *     * @return     */    public SellTickets getProxyObject() &#123;        /**         * InvocationHandler中invoke方法参数说明：         *     proxy ： 代理对象         *     method ： 对应于在代理对象上调用的接口方法的 Method 实例         *     args ： 代理对象调用接口方法时传递的实际参数         */        return (SellTickets) Proxy.newProxyInstance(                station.getClass().getClassLoader(),                station.getClass().getInterfaces(),                new InvocationHandler() &#123;                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        System.out.println(&quot;代售点卖票……（收取手续费）&quot;);                        // 执行真实对象                        return method.invoke(station, args);                    &#125;                &#125;        );    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">class ProxyFactoryTest &#123;    @Test    void testSell() &#123;        SellTickets proxyObject = new ProxyFactory().getProxyObject();        proxyObject.sellTickets();    &#125;&#125;</code></pre><blockquote><p>使用了动态代理思考一下：</p><ul><li><p><code>ProxyFactory</code>是代理类吗？</p><p><strong>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。</strong></p></li></ul></blockquote><p>通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：</p><blockquote><p>使用方法 :</p><ol><li>下载对应的jar包</li><li>在终端使用<code>java -jar jar包名</code></li><li>选择JVM进程</li><li>使用<code>jad 类名</code> 查看类的结构</li></ol></blockquote><pre><code class="java">package com.sun.proxy;import com.juzi.pattern.proxy.jdkproxy.SellTickets;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy9 extends Proxy implements SellTickets &#123;    private static Method m1;    private static Method m2;    private static Method m3;    private static Method m0;    public $Proxy9(InvocationHandler invocationHandler) &#123;        super(invocationHandler);    &#125;    static &#123;        try &#123;            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);            m3 = Class.forName(&quot;com.juzi.pattern.proxy.jdkproxy.SellTickets&quot;).getMethod(&quot;sellTickets&quot;, new Class[0]);            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);            return;        &#125;        catch (NoSuchMethodException noSuchMethodException) &#123;            throw new NoSuchMethodError(noSuchMethodException.getMessage());        &#125;        catch (ClassNotFoundException classNotFoundException) &#123;            throw new NoClassDefFoundError(classNotFoundException.getMessage());        &#125;    &#125;    public final boolean equals(Object object) &#123;        try &#123;            return (Boolean)this.h.invoke(this, m1, new Object[]&#123;object&#125;);        &#125;        catch (Error | RuntimeException throwable) &#123;            throw throwable;        &#125;        catch (Throwable throwable) &#123;            throw new UndeclaredThrowableException(throwable);        &#125;    &#125;    public final String toString() &#123;        try &#123;            return (String)this.h.invoke(this, m2, null);        &#125;        catch (Error | RuntimeException throwable) &#123;            throw throwable;        &#125;        catch (Throwable throwable) &#123;            throw new UndeclaredThrowableException(throwable);        &#125;    &#125;    public final int hashCode() &#123;        try &#123;            return (Integer)this.h.invoke(this, m0, null);        &#125;        catch (Error | RuntimeException throwable) &#123;            throw throwable;        &#125;        catch (Throwable throwable) &#123;            throw new UndeclaredThrowableException(throwable);        &#125;    &#125;    public final void sellTickets() &#123;        try &#123;            this.h.invoke(this, m3, null);            return;        &#125;        catch (Error | RuntimeException throwable) &#123;            throw throwable;        &#125;        catch (Throwable throwable) &#123;            throw new UndeclaredThrowableException(throwable);        &#125;    &#125;&#125;</code></pre><p>从上面的类中，可以得出：</p><ul><li>代理类（$Proxy9）实现了<code>SellTickets</code>接口。这也就印证了真实类和代理类实现同样的接口。</li><li>代理类（$Proxy9）将我们提供了的匿名内部类对象<code>InvocationHandler</code>传递给了父类。</li></ul><p><strong>动态代理的执行流程：</strong></p><p>重点代码摘取：</p><p><strong>$Proxy9代码摘取</strong></p><pre><code class="java">public final class $Proxy9 extends Proxy implements SellTickets &#123;    private static Method m3;    public $Proxy9(InvocationHandler invocationHandler) &#123;        super(invocationHandler);    &#125;    static &#123;         m3 = Class.forName(&quot;com.juzi.pattern.proxy.jdkproxy.SellTickets&quot;).getMethod(&quot;sellTickets&quot;, new Class[0]);    &#125;    public final void sellTickets() &#123;        this.h.invoke(this, m3, null);    &#125;&#125;</code></pre><p><strong>Java提供的动态代理相关类</strong></p><pre><code class="java">public class Proxy implements java.io.Serializable &#123;    protected InvocationHandler h;         protected Proxy(InvocationHandler h) &#123;        this.h = h;    &#125;&#125;</code></pre><p><strong>ProxyFactory类</strong></p><pre><code class="java">public class ProxyFactory &#123;    private TrianStation station;    public ProxyFactory() &#123;        station = new TrianStation();    &#125;    public SellTickets getProxyObject() &#123;        return (SellTickets) Proxy.newProxyInstance(                station.getClass().getClassLoader(),                station.getClass().getInterfaces(),                new InvocationHandler() &#123;                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        System.out.println(&quot;代售点卖票……（收取手续费）&quot;);                        // 执行真实对象                        return method.invoke(station, args);                    &#125;                &#125;        );    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">class ProxyFactoryTest &#123;    @Test    void testSell() &#123;        SellTickets proxyObject = new ProxyFactory().getProxyObject();        proxyObject.sellTickets();    &#125;&#125;</code></pre><p><strong><font color=#FF0000 >执行流程</font></strong></p><ol><li>在测试类中通过代理对象调用<code>sellTickets()</code>方法</li><li>根据多态的特性，执行的是代理类(<code>$Proxy9</code>)中的<code>sellTickets()</code>方法</li><li>代理类(<code>$Proxy9</code>)中的<code>sellTickets()</code>方法又调用了<code>InvocationHandler</code>接口的子实现类对象（匿名内部类）的<code>invoke</code>方法</li><li><code>invoke()</code>方法通过反射执行了真实对象所属类<code>TrainStation</code>中的<code>sellTickets()</code>方法</li></ol><h3 id="1-5-CGLIB动态代理"><a href="#1-5-CGLIB动态代理" class="headerlink" title="1.5 CGLIB动态代理"></a>1.5 CGLIB动态代理</h3><p>依旧是上面的案例，使用<code>CGLIB</code>代理实现</p><p>如果没有定义<code>SellTickets</code>接口，只定义了<code>TrainStation</code>(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p><p><code>CGLIB</code>是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p><p><code>CGLIB</code>是第三方提供的包，所以需要引入jar包的坐标：</p><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>代码实现</p><p><strong>TrainStation类</strong></p><pre><code class="java">/** * 火车站 * * @author codejuzi */public class TrainStation&#123;    public void sellTickets() &#123;        System.out.println(&quot;火车站卖票……&quot;);    &#125;&#125;</code></pre><p><strong>ProxyFactory类</strong></p><pre><code class="java">/** * 代理工厂类 * * @author codejuzi */public class ProxyFactory implements MethodInterceptor &#123;    private TrainStation station;    public ProxyFactory() &#123;        station = new TrainStation();    &#125;    public TrainStation getProxyObject() &#123;        // 创建Enhancer对象        Enhancer enhancer = new Enhancer();        // 设置enhancer的父类字节码对象        enhancer.setSuperclass(station.getClass());        // 设置回调        enhancer.setCallback(this);        // 创建代理对象        return (TrainStation) enhancer.create();    &#125;    /**     * 回调方法     *     * @param o 代理对象     * @param method 真实对象中的方法的Method实例     * @param objects 方法实际参数     * @param methodProxy 代理对象中的method实例     * @return     * @throws Throwable     */    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;        System.out.println(&quot;代理点收取手续费（CGLIB Dynamic Proxy）&quot;);        return  methodProxy.invokeSuper(o, objects);    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">class ProxyFactoryTest &#123;    @Test    void getProxyObject() &#123;        // 获取代理对象        TrainStation proxyObject = new ProxyFactory().getProxyObject();        proxyObject.sellTickets();    &#125;&#125;</code></pre><h3 id="1-6-三种代理的对比"><a href="#1-6-三种代理的对比" class="headerlink" title="1.6 三种代理的对比"></a>1.6 三种代理的对比</h3><ul><li><p>jdk代理和CGLIB代理</p><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p><p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果<strong>有接口使用JDK动态代理，如果没有接口使用CGLIB代理</strong>。</p></li><li><p>动态代理和静态代理</p><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p><p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p></li></ul><h3 id="1-7-优缺点"><a href="#1-7-优缺点" class="headerlink" title="1.7 优缺点"></a>1.7 优缺点</h3><p><strong>优点：</strong></p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂度；</li></ul><h3 id="1-8-使用场景"><a href="#1-8-使用场景" class="headerlink" title="1.8 使用场景"></a>1.8 使用场景</h3><ul><li><p>远程（<code>Remote</code>）代理</p><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p><p>&#x3D;&gt; <a href="https://blog.csdn.net/mxb1234567/article/details/125085369">RPC思想</a></p></li><li><p>防火墙（<code>Firewall</code>）代理</p><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p></li><li><p>保护（<code>Protect or Access</code>）代理</p><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p></li></ul><h2 id="2、适配器模式"><a href="#2、适配器模式" class="headerlink" title="2、适配器模式"></a>2、适配器模式</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%BD%AC%E6%8E%A5%E5%A4%B4.png" alt="转接头"></p><p><strong>定义：</strong></p><p>​将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>​适配器模式分为<strong>类适配器模式</strong>和<strong>对象适配器模式</strong>，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h3 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2 结构"></a>2.2 结构</h3><p>适配器模式(<code>Adapter</code>)包含以下角色：</p><ul><li>目标(<code>Target</code>)接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者(<code>Adaptee</code>)类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（<code>Adapter</code>）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h3 id="2-3-类适配器模式"><a href="#2-3-类适配器模式" class="headerlink" title="2.3 类适配器模式"></a>2.3 类适配器模式</h3><p><strong>实现方式</strong>：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>【例子】读卡器</p><p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p><p>类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="适配器模式"></p><p>代码实现</p><p><strong>SDCard接口</strong></p><pre><code class="java">/** * SD卡接口 * * @author codejuzi */public interface SDCard &#123;    String readSD();    void writeSD(String msg);&#125;</code></pre><p><strong>SDCardImpl类</strong></p><pre><code class="java">/** * SD卡接口实现类 * * @author codejuzi */public class SDCardImpl implements SDCard&#123;    @Override    public String readSD() &#123;        return &quot;SD card read a word: hello world&quot;;    &#125;    @Override    public void writeSD(String msg) &#123;        System.out.println(&quot;SD card write a word: &quot; + msg);    &#125;&#125;</code></pre><p><strong>Computer类</strong></p><pre><code class="java">/** * 电脑类 * * @author codejuzi */public class Computer &#123;    public String readSD(SDCard sdCard) &#123;        if(sdCard == null) &#123;            throw new NullPointerException(&quot;sdCard is null&quot;);        &#125;        return sdCard.readSD();    &#125;    public void writeSD(SDCard sdCard,String msg) &#123;        if(sdCard == null) &#123;            throw new NullPointerException(&quot;sdCard is null&quot;);        &#125;        sdCard.writeSD(msg);    &#125;&#125;</code></pre><p><strong>TFCard接口</strong></p><pre><code class="java">/** * TF卡接口 * * @author codejuzi */public interface TFCard &#123;    String readTF();    void writeTF(String msg);&#125;</code></pre><p><strong>TFCardImpl类</strong></p><pre><code class="java">/** * TF卡接口实现类 * * @author codejuzi */public class TFCardImpl implements TFCard&#123;    @Override    public String readTF() &#123;        return &quot;TF card read a word: hello world&quot;;    &#125;    @Override    public void writeTF(String msg) &#123;        System.out.println(&quot;TF card write a word: &quot; + msg);    &#125;&#125;</code></pre><p><strong>SDAdapterTF类</strong></p><pre><code class="java">/** * 适配器类 * * @author codejuzi */public class SDAadpterTF extends TFCardImpl implements SDCard&#123;    @Override    public String readSD() &#123;        System.out.println(&quot;SDAadpterTF readSD working&quot;);        return super.readTF();    &#125;    @Override    public void writeSD(String msg) &#123;        System.out.println(&quot;SDAadpterTF writeSD working&quot;);        super.writeTF(msg);    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">class ComputerTest &#123;    @Test    void readSDWithClassAdapter() &#123;        // SDCard        Computer computer = new Computer();        String SDMsg = computer.readSD(new SDCardImpl());        System.out.println(&quot;SDMsg = &quot; + SDMsg);        System.out.println(&quot;============================&quot;);        // TFCard        String TFMsg = computer.readSD(new SDAadpterTF());        System.out.println(&quot;TFMsg = &quot; + TFMsg);    &#125;    @Test    void wirteSDWithClassAdapter() &#123;        String msg = &quot;Hello Adapter Pattern&quot;;        // SDCard        Computer computer = new Computer();        computer.writeSD(new SDCardImpl(), &quot;Hello Adapter Pattern&quot;);        System.out.println(&quot;============================&quot;);        // TFCard        computer.writeSD(new SDAadpterTF(), msg);    &#125;&#125;</code></pre><p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p><p>&#x3D;&gt; 类适配器模式不常用</p><h3 id="2-4-对象适配器模式"><a href="#2-4-对象适配器模式" class="headerlink" title="2.4 对象适配器模式"></a>2.4 对象适配器模式</h3><p><strong>实现方式</strong>：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p><p>【例】读卡器</p><p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="对象适配器模式"></p><p>代码实现：</p><p>类适配器模式的代码，我们只需要修改适配器类（<code>SDAdapterTF</code>）和测试类。</p><p><strong>SDAdapterTF类</strong></p><pre><code class="java">/** * 对象适配器类 * * @author codejuzi */public class SDAadpterTF implements SDCard &#123;    /**     * 引入TF读卡器     */    private final TFCard tfCard;    public SDAadpterTF(TFCard tfCard) &#123;        this.tfCard = tfCard;    &#125;    @Override    public String readSD() &#123;        return tfCard.readTF();    &#125;    @Override    public void writeSD(String msg) &#123;        tfCard.writeTF(msg);    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">class ComputerTest &#123;    @Test    void readSDWithObjectAdapter() &#123;        // SDCard        Computer computer = new Computer();        String SDMsg = computer.readSD(new SDCardImpl());        System.out.println(&quot;SDMsg = &quot; + SDMsg);        System.out.println(&quot;============================&quot;);        // TFCard        String TFMsg = computer.readSD(new SDAadpterTF(new TFCardImpl()));        System.out.println(&quot;TFMsg = &quot; + TFMsg);    &#125;    @Test    void writeSDWithObjectAdapter() &#123;        String msg = &quot;Hello ClassAdapeter&quot;;        // SDCard        Computer computer = new Computer();        computer.writeSD(new SDCardImpl(), msg);        System.out.println(&quot;============================&quot;);        // TFCard        computer.writeSD(new SDAadpterTF(new TFCardImpl()), msg);    &#125;&#125;</code></pre><blockquote><p><strong>注意</strong>：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。</p></blockquote><h3 id="2-5-应用场景"><a href="#2-5-应用场景" class="headerlink" title="2.5 应用场景"></a>2.5 应用场景</h3><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h3 id="2-6-JDK源码解析"><a href="#2-6-JDK源码解析" class="headerlink" title="2.6 JDK源码解析"></a>2.6 JDK源码解析</h3><p><code>Reader</code>（字符流）、<code>InputStream</code>（字节流）的适配使用的是<code>InputStreamReader</code>。</p><p><code>InputStreamReader</code>继承自<code>java.io.Reader</code>，对<code>Reader</code>中的抽象的未实现的方法给出实现。如：</p><pre><code class="java">public int read() throws IOException &#123;    return sd.read();&#125;public int read(char cbuf[], int offset, int length) throws IOException &#123;    return sd.read(cbuf, offset, length);&#125;</code></pre><p>如上述代码中的<code>sd</code>（<code>StreamDecoder</code>类对象），在Sun的JDK实现中，实际的方法实现是对<code>sun.nio.cs.StreamDecoder</code>类的同名方法的调用封装。类结构图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png" alt="适配器模式-jdk源码解析"></p><p>从上图可以看出：</p><ul><li><code>InputStreamReader</code>是对同样实现了<code>Reader</code>的<code>StreamDecoder</code>的封装。</li><li><code>StreamDecoder</code>不是<code>Java SE API</code>中的内容，是<code>Sun  JDK</code>给出的自身实现。但我们知道他们对构造方法中的字节流类（<code>InputStream</code>）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li></ul><p><strong><font color="red">结论：</font></strong></p><p>​从表层来看，<code>InputStreamReader</code>做了<code>InputStream</code>字节流类到<code>Reader</code>字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是<code>StreamDecoder</code>的设计实现在实际上采用了适配器模式。</p><h2 id="3、装饰者模式"><a href="#3、装饰者模式" class="headerlink" title="3、装饰者模式"></a>3、装饰者模式</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>【例子】快餐店</p><p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-%E4%BD%BF%E7%94%A8%E5%89%8D.png" alt="装饰者模式-使用前"></p><p>使用继承的方式存在的问题：</p><ul><li><p>扩展性不好</p><p>如果要再加一种配料（火腿肠），我们就会发现需要给<code>FriedRice</code>和<code>FriedNoodles</code>分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p></li><li><p>产生过多的子类</p></li></ul><p><strong>装饰者模式定义</strong>：指在<strong>不改变现有对象结构</strong>的情况下，<strong>动态</strong>地给该对象<strong>增加</strong>一些职责（即增加其额外<strong>功能</strong>）的模式。</p><h3 id="3-2-结构"><a href="#3-2-结构" class="headerlink" title="3.2 结构"></a>3.2 结构</h3><p>装饰者（<code>Decorator</code>）模式中的角色：</p><ul><li>抽象构件（<code>Component</code>）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（<code>Concrete  Component</code>）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（<code>Decorator</code>）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（<code>Concrete Decorator</code>）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ul><h3 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h3><p>使用装饰者模式对【快餐店】案例进行改进</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="装饰者模式"></p><p>代码实现</p><p><strong>FastFood抽象类</strong></p><pre><code class="java">//快餐接口public abstract class FastFood &#123;    private float price;    private String desc;    public FastFood() &#123;    &#125;    public FastFood(float price, String desc) &#123;        this.price = price;        this.desc = desc;    &#125;    public void setPrice(float price) &#123;        this.price = price;    &#125;    public float getPrice() &#123;        return price;    &#125;    public String getDesc() &#123;        return desc;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public abstract float cost();  //获取价格&#125;</code></pre><p><strong>FriedRice类</strong></p><pre><code class="java">//炒饭public class FriedRice extends FastFood &#123;    public FriedRice() &#123;        super(10, &quot;炒饭&quot;);    &#125;    public float cost() &#123;        return getPrice();    &#125;&#125;</code></pre><p><strong>FriedNoodles类</strong></p><pre><code class="java">//炒面public class FriedNoodles extends FastFood &#123;    public FriedNoodles() &#123;        super(12, &quot;炒面&quot;);    &#125;    public float cost() &#123;        return getPrice();    &#125;&#125;</code></pre><p><strong>Garnish抽象类</strong></p><pre><code class="java">//配料类public abstract class Garnish extends FastFood &#123;    private FastFood fastFood;    public FastFood getFastFood() &#123;        return fastFood;    &#125;    public void setFastFood(FastFood fastFood) &#123;        this.fastFood = fastFood;    &#125;    public Garnish(FastFood fastFood, float price, String desc) &#123;        super(price,desc);        this.fastFood = fastFood;    &#125;&#125;</code></pre><p><strong>Egg类</strong></p><pre><code class="java">//鸡蛋配料public class Egg extends Garnish &#123;    public Egg(FastFood fastFood) &#123;        super(fastFood,1,&quot;鸡蛋&quot;);    &#125;    public float cost() &#123;        return getPrice() + getFastFood().getPrice();    &#125;    @Override    public String getDesc() &#123;        return super.getDesc() + getFastFood().getDesc();    &#125;&#125;</code></pre><p><strong>Bacon类</strong></p><pre><code class="java">//培根配料public class Bacon extends Garnish &#123;    public Bacon(FastFood fastFood) &#123;        super(fastFood,2,&quot;培根&quot;);    &#125;    @Override    public float cost() &#123;        return getPrice() + getFastFood().getPrice();    &#125;    @Override    public String getDesc() &#123;        return super.getDesc() + getFastFood().getDesc();    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">//测试类class Client &#123;    @Test    void test &#123;        //点一份炒饭        FastFood food = new FriedRice();        //花费的价格        System.out.println(food.getDesc() + &quot; &quot; + food.cost() + &quot;元&quot;);        System.out.println(&quot;========&quot;);        //点一份加鸡蛋的炒饭        FastFood food1 = new FriedRice();        food1 = new Egg(food1);        //花费的价格        System.out.println(food1.getDesc() + &quot; &quot; + food1.cost() + &quot;元&quot;);        System.out.println(&quot;========&quot;);        //点一份加培根的炒面        FastFood food2 = new FriedNoodles();        food2 = new Bacon(food2);        //花费的价格        System.out.println(food2.getDesc() + &quot; &quot; + food2.cost() + &quot;元&quot;);    &#125;&#125;</code></pre><p><strong>好处：</strong></p><ul><li><p>装饰者模式可以带来比继承更加<strong>灵活性</strong>的<strong>扩展</strong>功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p></li><li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li></ul><h3 id="3-4-使用场景"><a href="#3-4-使用场景" class="headerlink" title="3.4 使用场景"></a>3.4 使用场景</h3><ul><li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p></li><li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p></li></ul><h3 id="3-5-JDK源码解析"><a href="#3-5-JDK源码解析" class="headerlink" title="3.5 JDK源码解析"></a>3.5 JDK源码解析</h3><p>IO流中的包装类使用到了装饰者模式。<code>BufferedInputStream</code>，<code>BufferedOutputStream</code>，<code>BufferedReader</code>，<code>BufferedWriter</code>。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-jdk%E6%BA%90%E7%A0%81.png" alt="装饰者模式-jdk源码"></p><blockquote><p><font color="red">小结：</font></p><p>​<code>BufferedWriter</code>使用装饰者模式对<code>Writer</code>子实现类进行了增强，添加了缓冲区，提高了写数据的效率。</p></blockquote><h3 id="3-6-代理和装饰者的区别"><a href="#3-6-代理和装饰者的区别" class="headerlink" title="3.6 代理和装饰者的区别"></a>3.6 代理和装饰者的区别</h3><p>静态代理和装饰者模式的区别：</p><ul><li>相同点：<ul><li>都要实现与目标类相同的业务接口</li><li>在两个类中都要声明目标对象</li><li>都可以在不修改目标类的前提下增强目标方法</li></ul></li><li>不同点：<ul><li>目的不同<br>装饰者是为了增强目标对象<br>静态代理是为了保护和隐藏目标对象</li><li>获取目标对象构建的地方不同<br>装饰者是由外界传递进来，可以通过构造方法传递<br>静态代理是在代理类内部创建，以此来隐藏目标对象</li></ul></li></ul><h2 id="4、桥接模式"><a href="#4、桥接模式" class="headerlink" title="4、桥接模式"></a>4、桥接模式</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>【需求】需要创建不同的图形，并且每个图形都有可能会有不同的颜色。</p><p>我们可以利用继承的方式来设计类的关系：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200207194617620.png" alt="image-20200207194617620"></p><p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p><p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。</p><p>为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p><p><strong>定义：</strong></p><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><h3 id="4-2-结构"><a href="#4-2-结构" class="headerlink" title="4.2 结构"></a>4.2 结构</h3><p>桥接（<code>Bridge</code>）模式包含以下主要角色：</p><ul><li>抽象化（<code>Abstraction</code>）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（<code>Refined  Abstraction</code>）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（<code>Implementor</code>）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>具体实现化（<code>Concrete Implementor</code>）角色 ：给出实现化角色接口的具体实现。</li></ul><h3 id="4-3-案例"><a href="#4-3-案例" class="headerlink" title="4.3 案例"></a>4.3 案例</h3><p>【例子】视频播放器</p><p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p><p>类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="桥接模式"></p><p>代码实现</p><p><strong>VideoFile接口</strong></p><pre><code class="java">/** * 视频文件  Implementor * * @author codejuzi */public interface VideoFile &#123;    void decode(String fileName);&#125;</code></pre><p><strong>AVIFile类</strong></p><pre><code class="java">/** * AVI 视频文件  Concrete  Implementor * * @author codejuzi */public class AVIFile implements VideoFile &#123;    @Override    public void decode(String fileName) &#123;        System.out.println(&quot;AVI fileName = &quot; + fileName);    &#125;&#125;</code></pre><p><strong>RMVBFile类</strong></p><pre><code class="java">/** * RMVB 视频文件  Concrete  Implementor * * @author codejuzi */public class RMVBFile implements VideoFile &#123;    @Override    public void decode(String fileName) &#123;        System.out.println(&quot;RMVB fileName = &quot; + fileName);    &#125;&#125;</code></pre><p><strong>OperatingSystem类</strong></p><pre><code class="java">/** * 操作系统类 Abstraction * * @author codejuzi */public abstract class OperatingSystem &#123;    protected VideoFile videoFile;    public OperatingSystem(VideoFile videoFile) &#123;        this.videoFile = videoFile;    &#125;    public abstract void play(String fileName);&#125;</code></pre><p><strong>WIndows类</strong></p><pre><code class="java">/** * Windows操作系统 Refined Abstraction * * @author codejuzi */public class Windows extends OperatingSystem&#123;    public Windows(VideoFile videoFile) &#123;        super(videoFile);    &#125;    @Override    public void play(String fileName) &#123;        videoFile.decode(&quot;Windows &quot; + fileName);    &#125;&#125;</code></pre><p><strong>MacOS类</strong></p><pre><code class="java">/** * MacOS 操作系统 Refined Abstraction * * @author codejuzi */public class MacOS extends OperatingSystem&#123;    public MacOS(VideoFile videoFile) &#123;        super(videoFile);    &#125;    @Override    public void play(String fileName) &#123;        videoFile.decode(&quot;MacOS &quot; + fileName);    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">class OperatingSystemTest &#123;    @Test    void play() &#123;        OperatingSystem operatingSystem = new Windows(new AVIFile());        operatingSystem.play(&quot;Tom And Jerry&quot;);        operatingSystem = new MacOS(new AVIFile());        operatingSystem.play(&quot;Tom And Jerry&quot;);    &#125;&#125;</code></pre><p><strong>优势</strong></p><ul><li><p>桥接模式提高了系统的<strong>可扩充性</strong>，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p><p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p></li><li><p><strong>实现细节对客户透明</strong></p></li></ul><h3 id="4-4-使用场景"><a href="#4-4-使用场景" class="headerlink" title="4.4 使用场景"></a>4.4 使用场景</h3><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li></ul><h2 id="5、外观模式"><a href="#5、外观模式" class="headerlink" title="5、外观模式"></a>5、外观模式</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。</p><p><strong>定义：</strong></p><p>​又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>外观（<code>Facade</code>）模式是“迪米特法则”的典型应用</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%BC%95%E5%85%A5.jpg" alt="外观模式引入"></p><h3 id="5-2-结构"><a href="#5-2-结构" class="headerlink" title="5.2 结构"></a>5.2 结构</h3><p>外观（<code>Facade</code>）模式包含以下主要角色：</p><ul><li>外观（<code>Facade</code>）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（<code>Sub System</code>）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li></ul><h3 id="5-3-案例"><a href="#5-3-案例" class="headerlink" title="5.3 案例"></a>5.3 案例</h3><p>【例子】智能家电控制</p><p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p><p><img src="E:/MyFile/TyporaImgs/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.png" alt="外观模式"></p><p>代码实现</p><p><strong>Light类</strong></p><pre><code class="java">/** * 电灯类 Sub System * * @author codejuzi */public class Light &#123;    public void on() &#123;        System.out.println(&quot;Light on&quot;);    &#125;    public void off() &#123;        System.out.println(&quot;Light off&quot;);    &#125;&#125;</code></pre><p><strong>TV 类</strong></p><pre><code class="java">/** * 电视类 Sub System * * @author codejuzi */public class TV &#123;    public void on() &#123;        System.out.println(&quot;TV on&quot;);    &#125;    public void off() &#123;        System.out.println(&quot;TV off&quot;);    &#125;&#125;</code></pre><p><strong>AirCondition类</strong></p><pre><code class="java">/** * 空调类 Sub System * * @author codejuzi */public class AirCondition &#123;    public void on() &#123;        System.out.println(&quot;AirCondition on&quot;);    &#125;    public void off() &#123;        System.out.println(&quot;AirCondition off&quot;);    &#125;&#125;</code></pre><p><strong>SmartAppliancesFacade类</strong></p><pre><code class="java">/** * 智能电器控制 Facade * * @author codejuzi */public class SmartApplianceFacade &#123;    private final Light light;    private final TV tv;    private final AirCondition airCondition;    public SmartApplianceFacade() &#123;        light = new Light();        tv = new TV();        airCondition = new AirCondition();    &#125;    public void say(String message) &#123;        if (message.contains(&quot;打开&quot;)) &#123;            this.on();        &#125; else if (message.contains(&quot;关闭&quot;)) &#123;            this.off();        &#125; else &#123;            System.out.println(&quot;我听不懂你在说啥&quot;);        &#125;    &#125;    private void on() &#123;        light.on();        tv.on();        airCondition.on();    &#125;    private void off() &#123;        light.off();        tv.off();        airCondition.off();    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">class SmartApplianceFacadeTest &#123;    @Test    void say() &#123;        String message = &quot;打开电器&quot;;        SmartApplianceFacade smartApplianceFacade = new SmartApplianceFacade();        smartApplianceFacade.say(message);        message = &quot;关闭电器&quot;;        smartApplianceFacade.say(message);    &#125;&#125;</code></pre><p><strong>优点：</strong></p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li></ul><p><strong>缺点：</strong></p><ul><li>不符合开闭原则，修改很麻烦</li></ul><h3 id="5-4-使用场景"><a href="#5-4-使用场景" class="headerlink" title="5.4 使用场景"></a>5.4 使用场景</h3><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ul><h3 id="5-5-JDK源码解析"><a href="#5-5-JDK源码解析" class="headerlink" title="5.5 JDK源码解析"></a>5.5 JDK源码解析</h3><p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成<code>ServletRequest</code>对象，如下图①处对象。但是大家想想<code>ServletRequest</code>是一个接口，它还有一个子接口<code>HttpServletRequest</code>，而我们知道该<code>request</code>对象肯定是一个<code>HttpServletRequest</code>对象的子实现类对象，到底是哪个类的对象呢？可以通过输出<code>request</code>对象，我们就会发现是一个名为<code>RequestFacade</code>的类的对象。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200207234545691.png" alt="image-20200207234545691"></p><p>RequestFacade类就使用了外观模式。先看结构图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png" alt="外观模式-jdk源码解析"></p><p><strong>为什么在此处使用外观模式呢？</strong></p><p>定义 <code>RequestFacade </code>类，分别实现 <code>ServletRequest </code>，同时定义私有成员变量 <code>Request </code>，并且方法的实现调用 <code>Request  </code>的实现。然后，将 <code>RequestFacade</code>向上转型为 <code>ServletRequest  </code>传给 <code>servlet </code>的<code>service()</code>方法，这样即使在 <code>servlet </code>中被向下转型为 <code>RequestFacade </code>，也不能访问私有成员变量对象中的方法。既用了 <code>Request </code>，又能防止其中方法被不合理的访问。</p><h2 id="6、组合模式"><a href="#6、组合模式" class="headerlink" title="6、组合模式"></a>6、组合模式</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200208180417291.png" alt="image-20200208180417291"></p><p>上图可以看做是一个文件系统，对于这样的结构我们称之为<strong>树形结构</strong>。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个<strong>叶子节点</strong>后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的<strong>容器</strong>，容器里面包含很多的成员对象，这些成员对象既可以是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够<strong>一致的对待</strong>容器对象和叶子对象。</p><p><strong>定义：</strong></p><p>又名<strong>部分整体模式</strong>，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><h3 id="6-2-结构"><a href="#6-2-结构" class="headerlink" title="6.2 结构"></a>6.2 结构</h3><p>组合模式主要包含三种角色：</p><ul><li>抽象根节点（<code>Component</code>）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li><li>树枝节点（<code>Composite</code>）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li><li>叶子节点（<code>Leaf</code>）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li></ul><h3 id="6-3-案例"><a href="#6-3-案例" class="headerlink" title="6.3 案例"></a>6.3 案例</h3><p>【例】软件菜单</p><p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200208182322313.png" alt="image-20200208182322313"></p><p>实现该案例的类图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.png" alt="组合模式"></p><p>代码实现：</p><p><strong>MenuComponent抽象类</strong></p><pre><code class="java">/** * 抽象根节点 * * @author codejuzi */public abstract class MenuComponent &#123;    protected String name;    protected int level;    /**     * 添加菜单     *     * @param menuComponent     */    public void add(MenuComponent menuComponent)&#123;        throw new UnsupportedOperationException();    &#125;    /**     * 移除菜单     *     * @param menuComponent     */    public void remove(MenuComponent menuComponent)&#123;        throw new UnsupportedOperationException();    &#125;    /**     * 获取指定的子菜单     *     * @param index     * @return     */    public MenuComponent getChild(int index)&#123;        throw new UnsupportedOperationException();    &#125;    /**     * 获取菜单名称     *     * @return     */    public String getName()&#123;        return name;    &#125;    /**     * 显示结构     */    public void print()&#123;        throw new UnsupportedOperationException();    &#125;&#125;</code></pre><p><code>MenuComponent</code>定义为抽象类，因为有一些共有的属性和行为要在该类中实现，<code>Menu</code>和<code>MenuItem</code>类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。</p><p><strong>Menu类</strong></p><pre><code class="java">/** * 树枝节点 * * @author codejuzi */public class Menu extends MenuComponent &#123;    private List&lt;MenuComponent&gt; menuComponentList;    public Menu(String name, int level) &#123;        this.name = name;        this.level = level;        this.menuComponentList = new ArrayList&lt;&gt;();    &#125;    @Override    public void add(MenuComponent menuComponent) &#123;        menuComponentList.add(menuComponent);    &#125;    @Override    public void remove(MenuComponent menuComponent) &#123;        menuComponentList.remove(menuComponent);    &#125;    @Override    public MenuComponent getChild(int index) &#123;        return menuComponentList.get(index);    &#125;    @Override    public void print() &#123;        for (int i = 1; i &lt; level; i++) &#123;            System.out.print(&quot;--&quot;);        &#125;        System.out.println(name);        for (MenuComponent menuComponent : menuComponentList) &#123;            menuComponent.print();        &#125;    &#125;&#125;</code></pre><p><code>Menu</code>类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p><p><strong>MenuItem类</strong></p><pre><code class="java">/** * 叶子结点 * * @author codejuzi */public class MenuItem extends MenuComponent &#123;    public MenuItem(String name, int level) &#123;        this.name = name;        this.level = level;    &#125;    @Override    public void print() &#123;        for (int i = 1; i &lt; level; i++) &#123;            System.out.print(&quot;--&quot;);        &#125;        System.out.println(name);    &#125;&#125;</code></pre><p><code>MenuItem</code>是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p><p><strong>测试类</strong></p><pre><code class="java">public class MenuComponentTest &#123;    @Test    public void print() &#123;        //创建菜单树        MenuComponent menu1 = new Menu(&quot;菜单管理&quot;,2);        menu1.add(new MenuItem(&quot;页面访问&quot;,3));        menu1.add(new MenuItem(&quot;展开菜单&quot;,3));        menu1.add(new MenuItem(&quot;编辑菜单&quot;,3));        menu1.add(new MenuItem(&quot;删除菜单&quot;,3));        menu1.add(new MenuItem(&quot;新增菜单&quot;,3));        MenuComponent menu2 = new Menu(&quot;权限管理&quot;,2);        menu2.add(new MenuItem(&quot;页面访问&quot;,3));        menu2.add(new MenuItem(&quot;提交保存&quot;,3));        MenuComponent menu3 = new Menu(&quot;角色管理&quot;,2);        menu3.add(new MenuItem(&quot;页面访问&quot;,3));        menu3.add(new MenuItem(&quot;新增角色&quot;,3));        menu3.add(new MenuItem(&quot;修改角色&quot;,3));        //创建一级菜单        MenuComponent component = new Menu(&quot;系统管理&quot;,1);        //将二级菜单添加到一级菜单中        component.add(menu1);        component.add(menu2);        component.add(menu3);        //打印菜单名称(如果有子菜单一块打印)        component.print();    &#125;&#125;</code></pre><h3 id="6-4-组合模式的分类"><a href="#6-4-组合模式的分类" class="headerlink" title="6.4 组合模式的分类"></a>6.4 组合模式的分类</h3><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为<strong>透明组合模式</strong>和<strong>安全组合模式</strong>两种形式。</p><ul><li><p>透明组合模式</p><p>透明组合模式中，<strong>抽象根节点角色中声明了所有用于管理成员对象的方法</strong>，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p><p>透明组合模式的<strong>缺点</strong>是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p></li><li><p>安全组合模式</p><p>在安全组合模式中，在<strong>抽象构件角色中没有声明任何用于管理成员对象的方法</strong>，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的<strong>缺点</strong>是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-%E5%AE%89%E5%85%A8%E6%80%A7.png" alt="组合模式-安全性"></p></li></ul><h3 id="6-5-组合模式的优点"><a href="#6-5-组合模式的优点" class="headerlink" title="6.5 组合模式的优点"></a>6.5 组合模式的优点</h3><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul><h3 id="6-6-使用场景"><a href="#6-6-使用场景" class="headerlink" title="6.6 使用场景"></a>6.6 使用场景</h3><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p><h2 id="7、享元模式"><a href="#7、享元模式" class="headerlink" title="7、享元模式"></a>7、享元模式</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p><strong>定义：</strong></p><p>​运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><h3 id="7-2-结构"><a href="#7-2-结构" class="headerlink" title="7.2 结构"></a>7.2 结构</h3><p>享元（<code>Flyweight </code>）模式中存在以下两种状态：</p><ol><li>内部状态，即不会随着环境的改变而改变的可共享部分。</li><li>外部状态，指随环境改变而改变的不可以共享的部分。</li></ol><p>享元模式的<strong>实现要领</strong>就是区分应用中的这两种状态，并将外部状态外部化。</p><p>享元模式的主要有以下角色：</p><ul><li>抽象享元角色（<code>Flyweight</code>）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>具体享元（<code>Concrete Flyweight</code>）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li>非享元（<code>Unsharable Flyweight</code>)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li>享元工厂（<code>Flyweight Factory</code>）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul><h3 id="7-3-案例"><a href="#7-3-案例" class="headerlink" title="7.3 案例"></a>7.3 案例</h3><p>【例】俄罗斯方块</p><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.jpeg" alt="俄罗斯方块"></p><p>类图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" alt="享元模式"></p><p>代码实现：</p><p><strong>AbstractBox抽象类</strong></p><p>俄罗斯方块有不同的形状，对这些形状向上抽取出<code>AbstractBox</code>，用来定义共性的属性和行为。</p><pre><code class="java">/** * 抽象享元角色 * * @author codejuzi */public abstract class AbstractBox &#123;    public abstract String getShape();    public void display(String color) &#123;        System.out.println(&quot;方块形状：&quot; + this.getShape() + &quot; 颜色：&quot; + color);    &#125;&#125;</code></pre><p><strong>LBox类</strong></p><pre><code class="java">/** * 具体享元角色 * * @author codejuzi */public class LBox extends AbstractBox&#123;    @Override    public String getShape() &#123;        return &quot;L&quot;;    &#125;&#125;</code></pre><p><strong>IBox类</strong></p><pre><code class="java">/** * 具体享元角色 * * @author codejuzi */public class IBox extends AbstractBox&#123;    @Override    public String getShape() &#123;        return &quot;I&quot;;    &#125;&#125;</code></pre><p><strong>OBox类</strong></p><pre><code class="java">/** * 具体享元角色 * * @author codejuzi */public class OBox extends AbstractBox&#123;    @Override    public String getShape() &#123;        return &quot;O&quot;;    &#125;&#125;</code></pre><p><strong>BoxFactory类</strong></p><p>提供了一个工厂类（<code>BoxFactory</code>），用来管理享元对象（也就是<code>AbstractBox</code>子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p><pre><code class="java">/** * 享元工厂角色 * * @author codejuzi */public class BoxFactory &#123;    private static final Map&lt;String, AbstractBox&gt; boxCacheMap;    static &#123;        boxCacheMap = new HashMap&lt;&gt;();    &#125;    private BoxFactory() &#123;        AbstractBox iBox = new IBox();        AbstractBox lBox = new LBox();        AbstractBox oBox = new OBox();        boxCacheMap.put(&quot;I&quot;, iBox);        boxCacheMap.put(&quot;L&quot;, lBox);        boxCacheMap.put(&quot;O&quot;, oBox);    &#125;    public static BoxFactory getInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;    private static class SingletonHolder &#123;        private static final BoxFactory INSTANCE = new BoxFactory();    &#125;    public AbstractBox getBox(String key) &#123;        return boxCacheMap.get(key);    &#125;&#125;</code></pre><p><strong>Client测试类</strong></p><pre><code class="java">public class BoxFactoryTest &#123;    @Test    public void getBox() &#123;        //获取I图形对象        AbstractBox box1 = BoxFactory.getInstance().getBox(&quot;I&quot;);        box1.display(&quot;灰色&quot;);        //获取L图形对象        AbstractBox box2 = BoxFactory.getInstance().getBox(&quot;L&quot;);        box2.display(&quot;绿色&quot;);        //获取O图形对象        AbstractBox box3 = BoxFactory.getInstance().getBox(&quot;O&quot;);        box3.display(&quot;灰色&quot;);        //获取O图形对象        AbstractBox box4 = BoxFactory.getInstance().getBox(&quot;O&quot;);        box4.display(&quot;红色&quot;);        Assertions.assertSame(box3, box4);    &#125;&#125;</code></pre><h3 id="7-5-优缺点"><a href="#7-5-优缺点" class="headerlink" title="7.5 优缺点"></a>7.5 优缺点</h3><p><strong>1、优点</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li><li>享元模式中的外部状态相对独立，且不影响内部状态</li></ul><p><strong>2、缺点：</strong></p><p>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p><h3 id="7-6-使用场景"><a href="#7-6-使用场景" class="headerlink" title="7.6 使用场景"></a>7.6 使用场景</h3><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h3 id="7-7-JDK源码解析"><a href="#7-7-JDK源码解析" class="headerlink" title="7.7 JDK源码解析"></a>7.7 JDK源码解析</h3><p><code>Integer</code>类中使用了享元模式</p><pre><code class="java">public class IntegerFlyweightTest &#123;    @Test    public void test() &#123;        Integer num1 = 127;        Integer num2 = 127;        Assertions.assertSame(num1,num2);        Integer num3 = 128;        Integer num4 = 128;        Assertions.assertNotSame(num3, num4);    &#125;&#125;</code></pre><p>运行上述代码，断言是通过的。</p><p>反编译上述代码：</p><pre><code class="java">Integer i1 = Integer.valueOf((int)127);Integer i2 Integer.valueOf((int)127);Integer i3 = Integer.valueOf((int)128);Integer i4 = Integer.valueOf((int)128);</code></pre><p>直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 <code>valueOf()</code> ，所以只需要看该方法即可</p><pre><code class="java">public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123;    // ......    public static Integer valueOf(int i) &#123;        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)            return IntegerCache.cache[i + (-IntegerCache.low)];        return new Integer(i);    &#125;        private static class IntegerCache &#123;        static final int low = -128;        static final int high;        static final Integer cache[];        static &#123;            int h = 127;            String integerCacheHighPropValue =                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);            if (integerCacheHighPropValue != null) &#123;                try &#123;                    int i = parseInt(integerCacheHighPropValue);                    i = Math.max(i, 127);                    // Maximum array size is Integer.MAX_VALUE                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);                &#125; catch( NumberFormatException nfe) &#123;                &#125;            &#125;            high = h;            cache = new Integer[(high - low) + 1];            int j = low;            for(int k = 0; k &lt; cache.length; k++)                cache[k] = new Integer(j++);            // range [-128, 127] must be interned (JLS7 5.1.7)            assert IntegerCache.high &gt;= 127;        &#125;        private IntegerCache() &#123;&#125;    &#125;        // ......&#125;</code></pre><p>&#x3D;&gt;  <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--创建者模式</title>
      <link href="/2022/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E4%B8%80-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F">一、 创建者模式</a><ul><li><a href="#1%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">1、单例设计模式</a><ul><li><a href="#11-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84">1.1 单例模式的结构</a></li><li><a href="#12-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">1.2 单例模式的实现</a><ul><li><a href="#1%E9%A5%BF%E6%B1%89%E5%BC%8F%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%96%B9%E5%BC%8F">1）饿汉式（静态变量方式）</a></li><li><a href="#2%E9%A5%BF%E6%B1%89%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%96%B9%E5%BC%8F">2）饿汉式（静态代码块方式）</a></li><li><a href="#3%E6%87%92%E6%B1%89%E5%BC%8F%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8">3）懒汉式（线程不安全）</a></li><li><a href="#4%E6%87%92%E6%B1%89%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">4）懒汉式（线程安全）</a></li><li><a href="#5%E6%87%92%E6%B1%89%E5%BC%8F%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81">5）懒汉式（双重检查锁）</a></li><li><a href="#6%E6%87%92%E6%B1%89%E5%BC%8F%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%96%B9%E5%BC%8F">6）懒汉式（静态内部类方式）</a></li><li><a href="#7%E6%9E%9A%E4%B8%BE%E6%96%B9%E5%BC%8F">7）枚举方式</a></li></ul></li><li><a href="#13-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">1.3 存在的问题</a><ul><li><a href="#1%E9%97%AE%E9%A2%98">1）问题</a></li><li><a href="#2%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98">2）解决问题</a></li></ul></li><li><a href="#14-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90--runtime%E7%B1%BB%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">1.4 JDK源码解析–Runtime类（单例模式）</a></li></ul></li><li><a href="#2%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">2、工厂模式</a><ul><li><a href="#21-%E6%A6%82%E8%BF%B0">2.1 概述</a></li><li><a href="#22-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">2.2 简单工厂模式</a><ul><li><a href="#1%E7%BB%93%E6%9E%84">1）结构</a></li><li><a href="#2%E5%AE%9E%E7%8E%B0">2）实现</a></li><li><a href="#3%E4%BC%98%E7%BC%BA%E7%82%B9">3）优缺点</a></li><li><a href="#4%E6%89%A9%E5%B1%95">4）扩展</a></li></ul></li><li><a href="#23-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">2.3 工厂方法模式</a><ul><li><a href="#1%E6%A6%82%E5%BF%B5">1）概念</a></li><li><a href="#2%E7%BB%93%E6%9E%84">2）结构</a></li><li><a href="#3%E5%AE%9E%E7%8E%B0">3）实现</a></li><li><a href="#4%E4%BC%98%E7%BC%BA%E7%82%B9">4）优缺点</a></li></ul></li><li><a href="#24-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">2.4 抽象工厂模式</a><ul><li><a href="#1%E6%A6%82%E5%BF%B5-1">1）概念</a></li><li><a href="#2%E7%BB%93%E6%9E%84-1">2）结构</a></li><li><a href="#3%E5%AE%9E%E7%8E%B0-1">3）实现</a></li><li><a href="#4-%E4%BC%98%E7%BC%BA%E7%82%B9">4） 优缺点</a></li><li><a href="#5%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">5）使用场景</a></li></ul></li><li><a href="#25-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95">2.5 模式扩展</a><ul><li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E9%99%A4%E8%80%A6%E5%90%88">简单工厂+配置文件解除耦合</a></li></ul></li><li><a href="#26-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-collectioniterator%E6%96%B9%E6%B3%95">2.6 JDK源码解析-Collection.iterator方法</a></li></ul></li><li><a href="#3%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">3、原型模式</a><ul><li><a href="#31-%E6%A6%82%E8%BF%B0">3.1 概述</a></li><li><a href="#32-%E7%BB%93%E6%9E%84">3.2 结构</a></li><li><a href="#33-%E5%AE%9E%E7%8E%B0">3.3 实现</a></li><li><a href="#34-%E6%A1%88%E4%BE%8B">3.4 案例</a></li><li><a href="#35-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">3.5 使用场景</a></li><li><a href="#36-%E6%B7%B1%E5%85%8B%E9%9A%86">3.6 深克隆</a></li></ul></li><li><a href="#4%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">4、建造者模式</a><ul><li><a href="#41-%E6%A6%82%E8%BF%B0">4.1 概述</a></li><li><a href="#42-%E7%BB%93%E6%9E%84">4.2 结构</a></li><li><a href="#43-%E5%AE%9E%E4%BE%8B">4.3 实例</a></li><li><a href="#44--%E4%BC%98%E7%BC%BA%E7%82%B9">4.4  优缺点</a></li><li><a href="#45-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">4.5 使用场景</a></li><li><a href="#46-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95">4.6 模式扩展</a></li></ul></li><li><a href="#5%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94">5、创建者模式对比</a><ul><li><a href="#51-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-vs-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">5.1 工厂方法模式 VS 建造者模式</a></li><li><a href="#52-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-vs-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">5.2 抽象工厂模式 VS 建造者模式</a></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><blockquote><p>教程资源：<a href="https://www.bilibili.com/video/BV1Np4y1z7BU">https://www.bilibili.com/video/BV1Np4y1z7BU</a></p><p>完整代码地址：<a href="https://gitee.com/ding-xinliang/design-pattern">DesignPattern: Java设计模式 (gitee.com)</a></p></blockquote><h1 id="一、-创建者模式"><a href="#一、-创建者模式" class="headerlink" title="一、 创建者模式"></a>一、 创建者模式</h1><blockquote><p>创建者模式的主要关注点是“怎样创建对象？”</p><p>主要特点：“将对象的创建和使用分离” &#x3D;&gt; 降低系统的耦合度，使用者不需要关注对象的创建细节</p></blockquote><h2 id="1、单例设计模式"><a href="#1、单例设计模式" class="headerlink" title="1、单例设计模式"></a>1、单例设计模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="1-1-单例模式的结构"><a href="#1-1-单例模式的结构" class="headerlink" title="1.1 单例模式的结构"></a>1.1 单例模式的结构</h3><p>单例模式主要有以下角色：</p><ul><li>单例类：只能创建一个实例的类</li><li>访问类：使用单例类的类</li></ul><h3 id="1-2-单例模式的实现"><a href="#1-2-单例模式的实现" class="headerlink" title="1.2 单例模式的实现"></a>1.2 单例模式的实现</h3><blockquote><p>单例设计模式分类：</p><ul><li>饿汉式：类加载就会导致该单实例对象被创建</li><li>懒汉式：类加载不会导致该单实例对象的创建，而是在首次使用该类是才会创建</li></ul></blockquote><h4 id="1）饿汉式（静态变量方式）"><a href="#1）饿汉式（静态变量方式）" class="headerlink" title="1）饿汉式（静态变量方式）"></a>1）饿汉式（静态变量方式）</h4><pre><code class="java">/** * 单例模式 -- 饿汉式（静态变量的方式） * * @author codejuzi */public class Singleton &#123;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 成员变量位置创建该类的对象     */    private static final Singleton instance = new Singleton();    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;</code></pre><p><strong>说明</strong>：该方式在成员变量位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会<strong>造成内存的浪费</strong>。</p><h4 id="2）饿汉式（静态代码块方式）"><a href="#2）饿汉式（静态代码块方式）" class="headerlink" title="2）饿汉式（静态代码块方式）"></a>2）饿汉式（静态代码块方式）</h4><pre><code class="java">/** * 单例模式 -- 饿汉式（静态代码块的方式） * * @author codejuzi */public class Singleton &#123;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 成员变量位置声明该类的对象     */    private static final Singleton instance;            static &#123;        instance = new Singleton();    &#125;    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;</code></pre><p><strong>说明</strong>：该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式静态变量方式基本上一样，当然该方式也存在<strong>内存浪费</strong>问题。</p><h4 id="3）懒汉式（线程不安全）"><a href="#3）懒汉式（线程不安全）" class="headerlink" title="3）懒汉式（线程不安全）"></a>3）懒汉式（线程不安全）</h4><pre><code class="java">/** * 单例模式 -- 懒汉式（线程不安全） * * @author codejuzi */public class Singleton &#123;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 成员变量位置声明该类的对象     */    private static Singleton instance;        /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        // 创建类对象        if(instance == null)&#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;</code></pre><p><font color='red'>说明：</font>从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是<strong>多线程环境，会出现线程安全问题</strong>。</p><h4 id="4）懒汉式（线程安全）"><a href="#4）懒汉式（线程安全）" class="headerlink" title="4）懒汉式（线程安全）"></a>4）懒汉式（线程安全）</h4><pre><code class="java">/** * 单例模式 -- 懒汉式（线程安全） * * @author codejuzi */public class Singleton &#123;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 成员变量位置声明该类的对象     */    private static Singleton instance;    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static synchronized Singleton getInstance() &#123;        // 创建类对象        if(instance == null)&#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;</code></pre><p><font color='red'>说明：</font>该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该<strong>方法的执行效果特别低</strong>。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p><h4 id="5）懒汉式（双重检查锁）"><a href="#5）懒汉式（双重检查锁）" class="headerlink" title="5）懒汉式（双重检查锁）"></a>5）懒汉式（双重检查锁）</h4><blockquote><p>讨论一下懒汉模式中加锁的问题：</p><p>对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是<strong>读</strong>操作，读操作是<strong>线程安全</strong>的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要<strong>调整加锁的时机</strong>。</p><p>诞生了一种新的实现方式：双重检查锁模式</p></blockquote><pre><code class="java">/** * 单例模式 -- 懒汉式（双重检查锁） * * @author codejuzi */public class Singleton &#123;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 成员变量位置声明该类的对象     */    private static Singleton instance;    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        // 第一次判断，如果if条件不成立，不进入抢锁阶段，直接返回实例        if(instance == null)&#123;            synchronized (Singleton.class) &#123;                // 抢到锁的线程再次判断是否为null                if(instance == null) &#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre><p><font color='red'>说明：</font>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在<strong>多线程</strong>的情况下，可能会出现<strong>空指针</strong>问题，出现问题的原因是<strong>JVM在实例化对象的时候会进行优化和指令重排序操作</strong>。</p><p><strong>解决问题</strong>：解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <strong><code>volatile</code> 关键字可以保证可见性和有序性</strong>。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/xueping_wu/article/details/124541419">(73条消息) Java基础：volatile详解_koping_wu的博客-CSDN博客_java volatile</a></p></blockquote><pre><code class="java">/** * 单例模式 -- 懒汉式（双重检查锁，使用volatile关键字解决JVM实例化对象带来的空指针问题） * * @author codejuzi */public class Singleton &#123;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 成员变量位置声明该类的对象     */    private static volatile Singleton instance;    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        // 第一次判断，如果if条件不成立，不进入抢锁阶段，直接返回实例        if(instance == null)&#123;            synchronized (Singleton.class) &#123;                // 抢到锁的线程再次判断是否为null                if(instance == null) &#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre><p><font color="red">小结：</font> 添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种<strong>比较好</strong>的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p><h4 id="6）懒汉式（静态内部类方式）"><a href="#6）懒汉式（静态内部类方式）" class="headerlink" title="6）懒汉式（静态内部类方式）"></a>6）懒汉式（静态内部类方式）</h4><p><strong>说明</strong>：静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><pre><code class="java">/** * 单例模式 -- 懒汉式（静态内部类方式） * * @author codejuzi */public class Singleton &#123;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 静态内部类创建单例对象     */    private static class SingletonHolder &#123;        public static final Singleton INSATANCE = new Singleton();    &#125;    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        return SingletonHolder.INSATANCE;    &#125;&#125;</code></pre><p><font color='red'>说明：</font>第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder并初始化INSTANCE，这样不仅能<strong>确保线程安全</strong>，也能<strong>保证 Singleton 类的唯一性</strong>。</p><p><font color="red">小结：</font>静态内部类单例模式是一种<strong>优秀</strong>的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h4 id="7）枚举方式"><a href="#7）枚举方式" class="headerlink" title="7）枚举方式"></a>7）枚举方式</h4><p><strong>说明</strong>：枚举类实现单例模式是<strong>极力推荐</strong>的单例实现模式，因为枚举类型是<strong>线程安全</strong>的，并且只会<strong>装载一次</strong>，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常<strong>简单</strong>，而且枚举类型是所用单例实现中<strong>唯一一种不会被破坏的单例实现模式</strong>。</p><pre><code class="java">/** * 单例模式 -- 懒汉式（枚举方式） * * @author codejuzi */public enum Singleton &#123;    INSTANCE;&#125;</code></pre><p><font color='red'>说明：</font>枚举方式属于恶汉式方式</p><h3 id="1-3-存在的问题"><a href="#1-3-存在的问题" class="headerlink" title="1.3 存在的问题"></a>1.3 存在的问题</h3><h4 id="1）问题"><a href="#1）问题" class="headerlink" title="1）问题"></a>1）问题</h4><p><strong>破坏单例模式</strong>：使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是<strong>序列化</strong>和<strong>反射</strong>。</p><ul><li><p>序列化反序列化</p></li><li><p><strong>Singleton类：</strong></p><pre><code class="java">/** * 单例模式问题 -- 序列化破坏单例模式 * * @author codejuzi */public class Singleton implements Serializable &#123;    private static final long serialVersionUID = 4568772871319686880L;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 静态内部类创建单例对象     */    private static class SingletonHolder &#123;        public static final Singleton INSATANCE = new Singleton();    &#125;    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        return SingletonHolder.INSATANCE;    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">/** * 测试类 */class SingletonTest &#123;    private static final String fileName = &quot;E:\\Code_Loading\\test.txt&quot;;    private static Singleton readObjectFromFile() throws Exception &#123;        //创建对象输入流对象        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));        //第一个读取Singleton对象        return (Singleton) ois.readObject();    &#125;    public static void writeObject2File() throws Exception &#123;        //获取Singleton类的对象        Singleton instance = Singleton.getInstance();        //创建对象输出流        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName));        //将instance对象写出到文件中        oos.writeObject(instance);    &#125;    @Test    void test() &#123;        //往文件中写对象//        try &#123;//            writeObject2File();//        &#125; catch (Exception e) &#123;//            e.printStackTrace();//        &#125;        try &#123;            Singleton s1 = readObjectFromFile();            Singleton s2 = readObjectFromFile();            Assertions.assertNotSame(s1, s2);         &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>上面代码运行结果是正常（针对<code>assertNotSame</code>），表明序列化和反序列化已经破坏了单例设计模式</p></blockquote></li><li><p>反射<br><strong>Singleton类：</strong></p><pre><code class="java">/** * 单例模式 -- 反射破解单例模式 * * @author codejuzi */public class Singleton &#123;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 成员变量位置声明该类的对象     */    private static volatile Singleton instance;    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        // 第一次判断，如果if条件不成立，不进入抢锁阶段，直接返回实例        if(instance == null)&#123;            synchronized (Singleton.class) &#123;                // 抢到锁的线程再次判断是否为null                if(instance == null) &#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">/** * 测试类 */class SingletonTest &#123;    @Test    void test() &#123;        // 1.获取Singleton类的字节码对象        Class&lt;Singleton&gt; clazz = Singleton.class;        try &#123;            // 2.获取Singleton类的私有无参构造方法对象            Constructor&lt;Singleton&gt; constructor = clazz.getDeclaredConstructor();            // 3.爆破            constructor.setAccessible(true);            // 4.创建Singleton对象，测试            Singleton s1 = constructor.newInstance();            Singleton s2 = constructor.newInstance();            // 断言            Assertions.assertNotSame(s1, s2);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>上面代码运行结果是正常（针对<code>assertNotSame</code>），表明序列化和反序列化已经破坏了单例设计模式</p></blockquote></li></ul><blockquote><p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p></blockquote><h4 id="2）解决问题"><a href="#2）解决问题" class="headerlink" title="2）解决问题"></a>2）解决问题</h4><ul><li><p>序列化、反序列方式破坏单例模式的解决方法<br>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。<br><strong>Singleton类</strong></p><pre><code class="java">/** * 单例模式问题 -- 序列化破坏单例模式 * * @author codejuzi */public class Singleton implements Serializable &#123;    private static final long serialVersionUID = 4568772871319686880L;    /**     * 私有的构造函数     */    private Singleton() &#123;    &#125;    /**     * 静态内部类创建单例对象     */    private static class SingletonHolder &#123;        public static final Singleton INSATANCE = new Singleton();    &#125;    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        return SingletonHolder.INSATANCE;    &#125;    /**     * 定义readResolve函数解决序列化问题     *     * @return     */    private Object readResolve() &#123;        return SingletonHolder.INSATANCE;    &#125;&#125;</code></pre><p><strong>源码解析</strong><br>ObjectInputStream类</p><pre><code class="java">public final Object readObject() throws IOException, ClassNotFoundException&#123;    ...    // if nested read, passHandle contains handle of enclosing object    int outerHandle = passHandle;    try &#123;        Object obj = readObject0(false);//重点查看readObject0方法    .....&#125;    private Object readObject0(boolean unshared) throws IOException &#123;    ...    try &#123;        switch (tc) &#123;            ...            case TC_OBJECT:                return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法            ...        &#125;    &#125; finally &#123;        depth--;        bin.setBlockDataMode(oldMode);    &#125;    &#125;    private Object readOrdinaryObject(boolean unshared) throws IOException &#123;    ...    //isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，    obj = desc.isInstantiable() ? desc.newInstance() : null;     ...    // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true    if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123;        // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量        // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。        Object rep = desc.invokeReadResolve(obj);         ...    &#125;    return obj;&#125;</code></pre></li><li><p>反射方式破解单例的解决方法<br>当通过反射方式调用构造方法进行创建对象时，直接抛异常。不执行此操作</p><pre><code class="java">/** * 单例模式 -- 反射破解单例模式 * * @author codejuzi */public class Singleton &#123;    private static boolean flag = false;    /**     * 私有的构造函数     */    private Singleton() &#123;        // 解决反射破解单例模式        if(flag) &#123;            throw new RuntimeException(&quot;不允许重复创建对象&quot;);        &#125;        flag = true;    &#125;    /**     * 成员变量位置声明该类的对象     */    private static volatile Singleton instance;    /**     * 对外提供静态方法获取该对象     *     * @return     */    public static Singleton getInstance() &#123;        // 第一次判断，如果if条件不成立，不进入抢锁阶段，直接返回实例        if(instance == null)&#123;            synchronized (Singleton.class) &#123;                // 抢到锁的线程再次判断是否为null                if(instance == null) &#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre></li></ul><h3 id="1-4-JDK源码解析–Runtime类（单例模式）"><a href="#1-4-JDK源码解析–Runtime类（单例模式）" class="headerlink" title="1.4 JDK源码解析–Runtime类（单例模式）"></a>1.4 JDK源码解析–Runtime类（单例模式）</h3><p><code>Runtime</code>类就是使用单例设计模式</p><ol><li><p>源码</p><pre><code class="java">public class Runtime &#123;    private static Runtime currentRuntime = new Runtime();    /**     * Returns the runtime object associated with the current Java application.     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance     * methods and must be invoked with respect to the current runtime object.     *     * @return  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current     *          Java application.     */    public static Runtime getRuntime() &#123;        return currentRuntime;    &#125;    /** Don&#39;t let anyone else instantiate this class */    private Runtime() &#123;&#125;    ...&#125;</code></pre><p>从上面源代码中可以看出Runtime类使用的是饿汉式（静态属性）方式来实现单例模式的。</p></li><li><p>测试</p><pre><code class="java">/** * 测试Runtime类 */class RuntimeTest &#123;    @Test    void test() &#123;        // 1.获取Runtime对象        Runtime runtime = Runtime.getRuntime();        // 2.测试        //返回 Java 虚拟机中的内存总量。        System.out.println(runtime.totalMemory());        //返回 Java 虚拟机试图使用的最大内存量。        System.out.println(runtime.maxMemory());        try &#123;            //创建一个新的进程执行指定的字符串命令，返回进程对象            Process process = runtime.exec(&quot;ipconfig&quot;);            //获取命令执行后的结果，通过输入流获取            InputStream inputStream = process.getInputStream();            byte[] arr = new byte[1024 * 1024* 100];            int b = inputStream.read(arr);            System.out.println(new String(arr,0,b,&quot;gbk&quot;));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></li></ol><h2 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>需求：设计一个咖啡店点餐系统。  </p><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p><p>具体类的设计如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%95%E5%85%A5.png" alt="工厂设计模式引入"></p><blockquote><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；</p><p>&#x3D;&gt; 工厂模式最大的优点：<strong>解耦</strong></p></blockquote><h3 id="2-2-简单工厂模式"><a href="#2-2-简单工厂模式" class="headerlink" title="2.2 简单工厂模式"></a>2.2 简单工厂模式</h3><blockquote><p> 简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p></blockquote><h4 id="1）结构"><a href="#1）结构" class="headerlink" title="1）结构"></a>1）结构</h4><p>简单工厂包含如下角色：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h4 id="2）实现"><a href="#2）实现" class="headerlink" title="2）实现"></a>2）实现</h4><p>现在使用简单工厂对上面案例进行改进，类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="简单工厂模式"></p><p>工厂类代码：</p><pre><code class="java">/** * 简单咖啡工厂 * * @author codejuzi */public class SimpleCoffeeFactory &#123;    /**     * 创建咖啡     *     * @param type     * @return     */    public Coffee createCoffee(String type) &#123;        Coffee coffee = null;        FactoryEnums factoryEnums = FactoryEnums.getFactoryEnumsByType(type);        if (AMERICAN_COFFEE.equals(factoryEnums)) &#123;            coffee = new AmericanCoffee();        &#125; else if (LATTE_COFFEE.equals(factoryEnums)) &#123;            coffee = new LatteCoffee();        &#125; else &#123;            throw new RuntimeException(&quot;当前没有该类咖啡&quot;);        &#125;        return coffee;    &#125;&#125;</code></pre><p><strong>说明</strong>：</p><p>1）工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>2）后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p><h4 id="3）优缺点"><a href="#3）优缺点" class="headerlink" title="3）优缺点"></a>3）优缺点</h4><p><strong>优点：</strong></p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p><p><strong>缺点：</strong></p><p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p><h4 id="4）扩展"><a href="#4）扩展" class="headerlink" title="4）扩展"></a>4）扩展</h4><p><strong>静态工厂</strong></p><p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p><pre><code class="java">/** * 简单咖啡工厂 * * @author codejuzi */public class SimpleCoffeeFactory &#123;    /**     * 创建咖啡     *     * @param type     * @return     */    public static Coffee createCoffee(String type) &#123;        Coffee coffee = null;        FactoryEnums factoryEnums = FactoryEnums.getFactoryEnumsByType(type);        if (AMERICAN_COFFEE.equals(factoryEnums)) &#123;            coffee = new AmericanCoffee();        &#125; else if (LATTE_COFFEE.equals(factoryEnums)) &#123;            coffee = new LatteCoffee();        &#125; else &#123;            throw new RuntimeException(&quot;当前没有该类咖啡&quot;);        &#125;        return coffee;    &#125;&#125;</code></pre><h3 id="2-3-工厂方法模式"><a href="#2-3-工厂方法模式" class="headerlink" title="2.3 工厂方法模式"></a>2.3 工厂方法模式</h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h4 id="1）概念"><a href="#1）概念" class="headerlink" title="1）概念"></a>1）概念</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><h4 id="2）结构"><a href="#2）结构" class="headerlink" title="2）结构"></a>2）结构</h4><p>工厂方法模式的主要角色：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h4 id="3）实现"><a href="#3）实现" class="headerlink" title="3）实现"></a>3）实现</h4><p>使用工厂方法模式对上例进行改进，类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="工厂方法模式"></p><p>代码如下：</p><p><strong>抽象工厂</strong></p><pre><code class="java">/** * 抽象工厂类 * * @author codejuzi */public interface CoffeeFactory &#123;    /**     * 创建咖啡     *     * @param type     * @return     */    Coffee createCoffee(String type);&#125;</code></pre><p><strong>具体工厂</strong></p><p><code>AmericanCoffeeFactory</code></p><pre><code class="java">/** * 美式咖啡工厂 * * @author codejuzi */public class AmericanCoffeeFactory implements CoffeeFactory&#123;    @Override    public Coffee createCoffee(String type) &#123;        return new AmericanCoffee();    &#125;&#125;</code></pre><p><code>LatteCoffeeFactory</code></p><pre><code class="java">/** * 拿铁咖啡工厂 * * @author codejuzi */public class LatteCoffeeFactory implements CoffeeFactory&#123;    @Override    public Coffee createCoffee(String type) &#123;        return new LatteCoffee();    &#125;&#125;</code></pre><p><strong>咖啡店类</strong></p><pre><code class="java">/** * 咖啡店 * * @author codejuzi */public class CoffeeStore &#123;    /**     * 点咖啡     *     * @param type     */    public void orderCoffee(String type) &#123;        CoffeeFactory factory;        FactoryEnums factoryEnums = FactoryEnums.getFactoryEnumsByType(type);        if(FactoryEnums.AMERICAN_COFFEE.equals(factoryEnums)) &#123;            factory = new AmericanCoffeeFactory();        &#125; else if(FactoryEnums.LATTE_COFFEE.equals(factoryEnums)) &#123;            factory = new LatteCoffeeFactory();        &#125; else &#123;            throw new RuntimeException(&quot;当前没有该类的咖啡&quot;);        &#125;        Coffee coffee = factory.createCoffee(type);        String coffeeName = coffee.getName();        System.out.println(&quot;coffeeName = &quot; + coffeeName);    &#125;&#125;</code></pre><p><strong>说明</strong>：</p><p>1）从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p><p>2）工厂方法模式是简单工厂模式的进一步抽象。由于使用了<strong>多态性</strong>，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p><h4 id="4）优缺点"><a href="#4）优缺点" class="headerlink" title="4）优缺点"></a>4）优缺点</h4><p><strong>优点：</strong></p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p><strong>缺点：</strong></p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><h3 id="2-4-抽象工厂模式"><a href="#2-4-抽象工厂模式" class="headerlink" title="2.4 抽象工厂模式"></a>2.4 抽象工厂模式</h3><p>上述介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p><p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p><strong>抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族</strong></p><p>下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200401214509176.png" alt="image-20200401214509176"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200401222951963.png" alt="image-20200401222951963"></p><h4 id="1）概念-1"><a href="#1）概念-1" class="headerlink" title="1）概念"></a>1）概念</h4><p>抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><h4 id="2）结构-1"><a href="#2）结构-1" class="headerlink" title="2）结构"></a>2）结构</h4><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（Concrete Product）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ul><h4 id="3）实现-1"><a href="#3）实现-1" class="headerlink" title="3）实现"></a>3）实现</h4><p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="抽象工厂模式"></p><p>代码如下：</p><p><strong>抽象工厂</strong></p><pre><code class="java">/** * 甜品工厂类 * * @author codejuzi */public interface DessertFactory &#123;    /**     * 生产咖啡     *     * @return     */    Coffee createCoffee();    /**     * 生产甜品     *     * @return     */    Dessert createDessert();&#125;</code></pre><p><strong>具体工厂</strong></p><p><code>AmericanDessertFactory</code></p><pre><code class="java">/** * 具体工厂类 -- 美式甜品工厂类 * * @author codejuzi */public class AmericanDessertFactory implements DessertFactory &#123;    public Coffee createCoffee() &#123;        return new AmericanCoffee();    &#125;    public Dessert createDessert() &#123;        return new MatchaMousse();    &#125;&#125;</code></pre><p><code>ItalyDessertFactory</code></p><pre><code class="java">/** * 具体工厂类 -- 意大利风格甜品工厂类 * * @author codejuzi */public class ItalyDessertFactory implements DessertFactory &#123;    public Coffee createCoffee() &#123;        return new LatteCoffee();    &#125;    public Dessert createDessert() &#123;        return new Trimisu();    &#125;&#125;</code></pre><p><strong>说明</strong>：如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p><h4 id="4）-优缺点"><a href="#4）-优缺点" class="headerlink" title="4） 优缺点"></a>4） 优缺点</h4><p><strong>优点：</strong></p><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong></p><p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h4 id="5）使用场景"><a href="#5）使用场景" class="headerlink" title="5）使用场景"></a>5）使用场景</h4><ul><li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p></li><li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p></li><li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p></li></ul><p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p><h3 id="2-5-模式扩展"><a href="#2-5-模式扩展" class="headerlink" title="2.5 模式扩展"></a>2.5 模式扩展</h3><h4 id="简单工厂-配置文件解除耦合"><a href="#简单工厂-配置文件解除耦合" class="headerlink" title="简单工厂+配置文件解除耦合"></a>简单工厂+配置文件解除耦合</h4><p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p><ol><li><p>定义配置文件<br>此处使用properties文件作为配置文件，名称为<code>simple_factory_bean.properties</code></p><pre><code class="properties">american=com.juzi.pattern.factory.config_factory.AmericanCoffeelatte=com.juzi.pattern.factory.config_factory.LatteCoffee</code></pre></li><li><p>改进工厂类<br><code>CoffeeFactory</code></p><pre><code class="java">/** * 咖啡工厂类 * * @author codejuzi */public class CoffeeFactory &#123;    private static final String SIMPLE_FACTORY_BEAN_PROPERTIES = &quot;simple_factory_bean.properties&quot;;    private static final Map&lt;String,Coffee&gt; coffeeMap = new HashMap&lt;&gt;();    static &#123;        try &#123;            Properties properties = new Properties();            InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(SIMPLE_FACTORY_BEAN_PROPERTIES);            properties.load(is);            // 遍历Properties集合对象            Set&lt;Object&gt; keySet = properties.keySet();            for (Object key : keySet) &#123;                //根据键获取值（全类名）                String className = properties.getProperty((String) key);                //获取字节码对象                Class clazz = Class.forName(className);                Coffee obj = (Coffee) clazz.newInstance();                coffeeMap.put((String)key,obj);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public static Coffee createCoffee(String type) &#123;        return coffeeMap.get(type);    &#125;&#125;</code></pre><p><strong>说明：</strong>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p></li></ol><h3 id="2-6-JDK源码解析-Collection-iterator方法"><a href="#2-6-JDK源码解析-Collection-iterator方法" class="headerlink" title="2.6 JDK源码解析-Collection.iterator方法"></a>2.6 JDK源码解析-Collection.iterator方法</h3><p><strong>List接口</strong></p><pre><code class="java">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; // ......    /**     * Returns an iterator over the elements in this list in proper sequence.     *     * @return an iterator over the elements in this list in proper sequence     */    Iterator&lt;E&gt; iterator();        // .......&#125;</code></pre><p><strong>ArrayList类</strong></p><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;    // ......    /**     * Returns an iterator over the elements in this list in proper sequence.     *     * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.     *     * @return an iterator over the elements in this list in proper sequence     */    public Iterator&lt;E&gt; iterator() &#123;        return new Itr();    &#125;    /**     * An optimized version of AbstractList.Itr     */    private class Itr implements Iterator&lt;E&gt; &#123;        // .......    &#125;    &#125;</code></pre><p><strong>单列集合获取迭代器的方法就使用到了工厂方法模式。</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png" alt="jdk源码解析"></p><p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。</p><blockquote><p>另：</p><p>​1,DateForamt类中的getInstance()方法使用的是工厂模式；</p><p>​2,Calendar类中的getInstance()方法使用的是工厂模式；</p></blockquote><h2 id="3、原型模式"><a href="#3、原型模式" class="headerlink" title="3、原型模式"></a>3、原型模式</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><h3 id="3-2-结构"><a href="#3-2-结构" class="headerlink" title="3.2 结构"></a>3.2 结构</h3><p>原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>接口类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" alt="原型模式"></p><h3 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h3><p>原型克隆的克隆分为浅克隆和深克隆</p><ul><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址</li><li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li></ul><p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：</p><p><strong>Realizetype（具体的原型类）：</strong></p><pre><code class="java">/** * 具体的原型类 * * @author codejuzi */public class RealizeType implements Cloneable&#123;    public RealizeType() &#123;        System.out.println(&quot;RealizeType创建完成（无参构造）&quot;);    &#125;    @Override    protected RealizeType clone() throws CloneNotSupportedException &#123;        System.out.println(&quot;RealizeType对象克隆完成&quot;);        return (RealizeType) super.clone();    &#125;&#125;</code></pre><p><strong>RealizeTypeTest（测试类）</strong></p><pre><code class="java">class RealizeTypeTest &#123;    @Test    void testClone() &#123;        try &#123;            RealizeType originRealizeType = new RealizeType();            RealizeType cloneRealizeType = originRealizeType.clone();            System.out.println(originRealizeType == cloneRealizeType);            Assertions.assertSame(originRealizeType, cloneRealizeType);        &#125; catch (CloneNotSupportedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="3-4-案例"><a href="#3-4-案例" class="headerlink" title="3.4 案例"></a>3.4 案例</h3><p><strong>用原型模式生成“三好学生”奖状</strong></p><p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p><p>类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F1.png" alt="原型模式1"></p><p><strong>Citation类</strong></p><pre><code class="java">/** * 奖状类 * * @author codejuzi */@Datapublic class Citation implements Cloneable&#123;    private String stuName;    public void show() &#123;        System.out.println(stuName + &quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;);    &#125;    @Override    protected Citation clone() throws CloneNotSupportedException &#123;        return (Citation) super.clone();    &#125;&#125;</code></pre><p><strong>CitationTest测试类</strong></p><pre><code class="java">class CitationTest &#123;    @Test    void testClone() throws CloneNotSupportedException &#123;        Citation originCitation = new Citation();        originCitation.setStuName(&quot;张三&quot;);        originCitation.show();        Citation cloneCitation = originCitation.clone();        cloneCitation.setStuName(&quot;李四&quot;);        cloneCitation.show();        Assertions.assertNotSame(originCitation, cloneCitation);    &#125;&#125;</code></pre><h3 id="3-5-使用场景"><a href="#3-5-使用场景" class="headerlink" title="3.5 使用场景"></a>3.5 使用场景</h3><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul><h3 id="3-6-深克隆"><a href="#3-6-深克隆" class="headerlink" title="3.6 深克隆"></a>3.6 深克隆</h3><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p><p><strong>Student类</strong></p><pre><code class="java">/** * 学生类 * * @author codejuzi */@Datapublic class Student &#123;    private String name;&#125;</code></pre><p><strong>Citation类</strong></p><pre><code class="java">/** * 奖状类 * * @author codejuzi */@Datapublic class Citation implements Cloneable&#123;    private Student student;    public void show() &#123;        System.out.println(student.getName() + &quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;);    &#125;    @Override    protected Citation clone() throws CloneNotSupportedException &#123;        return (Citation) super.clone();    &#125;&#125;</code></pre><p><strong>CitationTest类</strong></p><pre><code class="java">class CitationTest &#123;    @Test    void testClone() throws CloneNotSupportedException &#123;        Student student1 = new Student();        student1.setName(&quot;张三&quot;);        Citation origincitation = new Citation();        origincitation.setStudent(student1);        Citation cloneCitation = origincitation.clone();        Student student2 = cloneCitation.getStudent();        student2.setName(&quot;李四&quot;);        origincitation.show();        cloneCitation.show();        Assertions.assertSame(student1, student2);    &#125;&#125;</code></pre><blockquote><p>上述代码运行结果：</p><pre><code>李四同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！李四同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！</code></pre><p>断言运行正常，说明两个Student对象属于一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。</p></blockquote><p>这种情况需要使用<strong>深克隆</strong></p><p>实现深克隆的方式：</p><ol><li>在<code>clone()</code>函数中加入逻辑使之成为深克隆</li><li>使用对象流的形式实现（<strong>注意</strong>：序列化的对象需要实现序列化接口）</li></ol><blockquote><p> Java深克隆参考文章：<a href="https://blog.csdn.net/qq_45321888/article/details/122194112">https://blog.csdn.net/qq_45321888/article/details/122194112</a></p></blockquote><pre><code class="java">class CitationTest &#123;    @Test    void testCloneWithObjectStream() throws CloneNotSupportedException, IOException, ClassNotFoundException &#123;        String fileName = &quot;x&quot;;        Student student1 = new Student();        student1.setName(&quot;张三&quot;);        Citation originCitation = new Citation();        originCitation.setStudent(student1);        // 创建对象输出流对象        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName));        // 将 originCitation 写入文件        oos.writeObject(originCitation);        oos.close();        // 创建对象输入流对象        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));        // 读对象        Citation cloneCitation = (Citation) ois.readObject();        // 获取学生对象        Student student2 = cloneCitation.getStudent();        student2.setName(&quot;李四&quot;);        originCitation.show();        cloneCitation.show();        Assertions.assertNotSame(student1, student2);    &#125;&#125;</code></pre><h2 id="4、建造者模式"><a href="#4、建造者模式" class="headerlink" title="4、建造者模式"></a>4、建造者模式</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20200413225341516.png" alt="image-20200413225341516"></p><ul><li>分离了部件的构造(由<code>Builder</code>来负责)和装配(由<code>Director</code>负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li><li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li><li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li></ul><h3 id="4-2-结构"><a href="#4-2-结构" class="headerlink" title="4.2 结构"></a>4.2 结构</h3><p>建造者（<code>Builder</code>）模式包含如下角色：</p><ul><li><p>抽象建造者类（<code>Builder</code>）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </p></li><li><p>具体建造者类（<code>ConcreteBuilder</code>）：实现 <code>Builder </code>接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </p></li><li><p>产品类（<code>Product</code>）：要创建的复杂对象。</p></li><li><p>指挥者类（<code>Director</code>）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p></li></ul><p>类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="建造者模式"></p><h3 id="4-3-实例"><a href="#4-3-实例" class="headerlink" title="4.3 实例"></a>4.3 实例</h3><p><strong>创建共享单车</strong></p><p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p><p>这里<code>Bike</code>是产品，包含车架，车座等组件；<code>Builder</code>是抽象建造者，<code>MobikeBuilder</code>和<code>OfoBuilder</code>是具体的建造者；<code>Director</code>是指挥者。类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F1.png" alt="建造者模式1"></p><p>代码实现</p><p><strong>Bike类</strong></p><pre><code class="java">/** * 自行车类 * * @author codejuzi */@Datapublic class Bike &#123;    private String frame;    private String seat;&#125;</code></pre><p><strong>抽象Builder类</strong></p><pre><code class="java">/** * 抽象构造者类 * * @author codejuzi */public abstract class Builder &#123;    protected Bike mBike = new Bike();    public abstract void buildFrame();    public abstract void buildSeat();    public abstract Bike createBike();&#125;</code></pre><p><strong>MobileBuilder类</strong></p><pre><code class="java">/** * 摩拜单车类 * * @author codejuzi */public class MobileBuilder extends Builder&#123;    @Override    public void buildFrame() &#123;        super.mBike.setFrame(&quot;碳纤维框架&quot;);    &#125;    @Override    public void buildSeat() &#123;        super.mBike.setSeat(&quot;真皮座椅&quot;);    &#125;    @Override    public Bike createBike() &#123;        return super.mBike;    &#125;&#125;</code></pre><p><strong>OfoBuilder类</strong></p><pre><code class="java">/** * Ofo单车类 * * @author codejuzi */public class OfoBuilder extends Builder&#123;    @Override    public void buildFrame() &#123;        super.mBike.setFrame(&quot;铝合金框架&quot;);    &#125;    @Override    public void buildSeat() &#123;        super.mBike.setSeat(&quot;纤维座椅&quot;);    &#125;    @Override    public Bike createBike() &#123;        return super.mBike;    &#125;&#125;</code></pre><p><strong>Director类</strong></p><pre><code class="java">/** * 指挥类 * * @author codejuzi */public class Director &#123;    private Builder builder;    public Director(Builder builder) &#123;        this.builder = builder;    &#125;    public Bike construct() &#123;        builder.buildFrame();        builder.buildSeat();        return builder.createBike();    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">class DirectorTest &#123;    @Test    void construct() &#123;        showBike(new MobileBuilder());        showBike(new OfoBuilder());    &#125;    public void showBike(Builder builder) &#123;        Director director = new Director(builder);        Bike bike = director.construct();        System.out.println(&quot;bike = &quot; + bike);    &#125;&#125;</code></pre><p><strong>注意：</strong></p><p>上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合</p><p><strong>抽象Builder类</strong></p><pre><code class="java">/** * 抽象构造者类 * * @author codejuzi */public abstract class Builder &#123;    protected Bike mBike = new Bike();    public abstract void buildFrame();    public abstract void buildSeat();    public abstract Bike createBike();        public Bike construct() &#123;        builder.buildFrame();        builder.buildSeat();        return builder.createBike();    &#125;&#125;</code></pre><p><strong>说明：</strong></p><p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。</p><h3 id="4-4-优缺点"><a href="#4-4-优缺点" class="headerlink" title="4.4  优缺点"></a>4.4  优缺点</h3><p><strong>优点：</strong></p><ul><li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li></ul><p><strong>缺点：</strong></p><p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><h3 id="4-5-使用场景"><a href="#4-5-使用场景" class="headerlink" title="4.5 使用场景"></a>4.5 使用场景</h3><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul><h3 id="4-6-模式扩展"><a href="#4-6-模式扩展" class="headerlink" title="4.6 模式扩展"></a>4.6 模式扩展</h3><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p><p>重构前代码：</p><p><strong>Phone类</strong></p><pre><code class="java">/** * 手机类 *  * @author codejuzi */@Data@AllArgsConstructorpublic class Phone &#123;    private String cpu;    private String memory;    private String screen;    private String mainBoard;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">class PhoneTest &#123;    @Test    void originTest() &#123;        //构建Phone对象        Phone phone = new Phone(&quot;intel&quot;,&quot;三星屏幕&quot;,&quot;金士顿&quot;,&quot;华硕&quot;);        System.out.println(phone);    &#125;&#125;</code></pre><p>重构后代码</p><p><strong>Phone类</strong></p><pre><code class="java">/** * 手机类 * * @author codejuzi */public class Phone &#123;    private final String cpu;    private final String memory;    private final String screen;    private final String mainBoard;    public Phone(Builder builder) &#123;        this.cpu = builder.cpu;        this.memory = builder.memory;        this.screen = builder.screen;        this.mainBoard = builder.mainBoard;    &#125;    @Override    public String toString() &#123;        return &quot;Phone&#123;&quot; +                &quot;cpu=&#39;&quot; + cpu + &#39;\&#39;&#39; +                &quot;, memory=&#39;&quot; + memory + &#39;\&#39;&#39; +                &quot;, screen=&#39;&quot; + screen + &#39;\&#39;&#39; +                &quot;, mainBoard=&#39;&quot; + mainBoard + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    /**     * 静态内部类 Builder     */    public static final class Builder &#123;        private String cpu;        private String memory;        private String screen;        private String mainBoard;        public Builder cpu(String cpu) &#123;            this.cpu = cpu;            return this;        &#125;        public Builder memory(String memory) &#123;            this.memory = memory;            return this;        &#125;        public Builder screen(String screen) &#123;            this.screen = screen;            return this;        &#125;        public Builder mainBoard(String mainBoard) &#123;            this.mainBoard = mainBoard;            return this;        &#125;        public Phone build() &#123;            return new Phone(this);        &#125;    &#125;&#125;</code></pre><p><strong>测试类</strong></p><pre><code class="java">class PhoneTest &#123;    @Test    void optimizePhone() &#123;        Phone phone = new Phone.Builder()                .cpu(&quot;intel&quot;)                .mainBoard(&quot;华硕&quot;)                .memory(&quot;金士顿&quot;)                .screen(&quot;三星&quot;)                .build();        System.out.println(phone);    &#125;&#125;</code></pre><p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。</p><h2 id="5、创建者模式对比"><a href="#5、创建者模式对比" class="headerlink" title="5、创建者模式对比"></a>5、创建者模式对比</h2><h3 id="5-1-工厂方法模式-VS-建造者模式"><a href="#5-1-工厂方法模式-VS-建造者模式" class="headerlink" title="5.1 工厂方法模式 VS 建造者模式"></a>5.1 工厂方法模式 VS 建造者模式</h3><p><strong>工厂方法模式</strong>注重的是整体对象的<strong>创建方式</strong>；而<strong>建造者模式</strong>注重的是部件构建的<strong>过程</strong>，意在通过一步一步地精确构造创建出一个复杂的对象。</p><blockquote><p>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p></blockquote><h3 id="5-2-抽象工厂模式-VS-建造者模式"><a href="#5-2-抽象工厂模式-VS-建造者模式" class="headerlink" title="5.2 抽象工厂模式 VS 建造者模式"></a>5.2 抽象工厂模式 VS 建造者模式</h3><p><strong>抽象工厂模式</strong>实现对<strong>产品家族</strong>的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p><strong>建造者模式</strong>则是要求按照指定的<strong>蓝图</strong>建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p><blockquote><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--概述</title>
      <link href="/2022/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/12/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E4%B8%80%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E4%BD%93%E6%8A%8A%E6%8F%A1">一、设计模式总体把握</a><ul><li><a href="#11-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%BF%B5">1.1 软件设计模式概念</a></li><li><a href="#12-%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7">1.2 学习设计模式的必要性</a></li><li><a href="#13-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB">1.3 设计模式分类</a></li></ul></li><li><a href="#%E4%BA%8Cuml%E5%9B%BE">二、UML图</a><ul><li><a href="#21-%E7%B1%BB%E5%9B%BE%E6%A6%82%E8%BF%B0">2.1 类图概述</a></li><li><a href="#22-%E7%B1%BB%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8">2.2 类图的作用</a></li><li><a href="#23-%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95">2.3 类图表示法</a><ul><li><a href="#231-%E7%B1%BB%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95">2.3.1 类的表示方法</a></li><li><a href="#232-%E7%B1%BB%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F">2.3.2 类和类之间关系的表示方式</a><ul><li><a href="#1%E4%B8%80%E8%88%AC%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB">1、一般关联关系</a></li><li><a href="#2%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB">2、聚合关系</a></li><li><a href="#3%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB">3、组合关系</a></li><li><a href="#4%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB">4、依赖关系</a></li><li><a href="#5%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB">5、继承关系</a></li><li><a href="#6%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB">6、实现关系</a></li></ul></li></ul></li></ul></li><li><a href="#%E4%B8%89%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">三、软件设计原则</a><ul><li><a href="#31-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99">3.1 开闭原则</a></li><li><a href="#32-%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99">3.2 里氏代换原则</a></li><li><a href="#33-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99">3.3 依赖倒转原则</a></li><li><a href="#34-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">3.4 接口隔离原则</a></li><li><a href="#35-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99">3.5 迪米特法则</a></li><li><a href="#36-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99">3.6 合成复用原则</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><blockquote><p>教程资源：<a href="https://www.bilibili.com/video/BV1Np4y1z7BU">https://www.bilibili.com/video/BV1Np4y1z7BU</a></p></blockquote><h1 id="一、设计模式总体把握"><a href="#一、设计模式总体把握" class="headerlink" title="一、设计模式总体把握"></a>一、设计模式总体把握</h1><h2 id="1-1-软件设计模式概念"><a href="#1-1-软件设计模式概念" class="headerlink" title="1.1 软件设计模式概念"></a>1.1 软件设计模式概念</h2><p>1）软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的<strong>总结</strong></p><p>2）它描述了在软件设计过程中的一些不断重复发生的<strong>问题</strong>，以及该问题的<strong>解决方案</strong></p><h2 id="1-2-学习设计模式的必要性"><a href="#1-2-学习设计模式的必要性" class="headerlink" title="1.2 学习设计模式的必要性"></a>1.2 学习设计模式的必要性</h2><p>1）设计模式的本质：</p><ul><li><strong>面向对象</strong>设计原则的实际运用</li><li>对类的<strong>封装</strong>性、<strong>继承</strong>性和<strong>多态</strong>性以及类的<strong>关联关系</strong>和<strong>组合关系</strong>的充分理解</li></ul><p>2）正确使用设计模式的优点</p><ul><li>提高开发人员的思维能力、编程能力和设计能力</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强</li></ul><h2 id="1-3-设计模式分类"><a href="#1-3-设计模式分类" class="headerlink" title="1.3 设计模式分类"></a>1.3 设计模式分类</h2><p>1）<strong>创建型模式</strong></p><ul><li>用于描述“怎样创建对象”</li><li>主要特点：将对象的创建与使用分离</li><li>种类：单例、原型、工厂方法、抽象工厂、建造者</li></ul><p>2）<strong>结构型模式</strong></p><ul><li>用于描述如何将类或者对象按某种布局组成更大的结构</li><li>种类：代理、适配器、桥接、装饰、外观、享元、组合</li></ul><p>3）<strong>行为型模式</strong></p><ul><li>用于描述类或者对象之间怎么相互写作共同完成单个对象无法单独完成的任务，以及怎样分配职责</li><li>类别：模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器</li></ul><h1 id="二、UML图"><a href="#二、UML图" class="headerlink" title="二、UML图"></a>二、UML图</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息</p><p>UML 从目标系统的不同角度出发，定义了用例图、<strong>类图</strong>、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图</p><h2 id="2-1-类图概述"><a href="#2-1-类图概述" class="headerlink" title="2.1 类图概述"></a>2.1 类图概述</h2><p>类图(Class diagram)是显示了<strong>模型的静态结构</strong>，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。<strong>类图是面向对象建模的主要组成部分</strong>。</p><h2 id="2-2-类图的作用"><a href="#2-2-类图的作用" class="headerlink" title="2.2 类图的作用"></a>2.2 类图的作用</h2><p>1）在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解</p><p>2）类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型</p><p>&#x3D;&gt; <strong>以可视化的方式展示分析设计结果</strong></p><h2 id="2-3-类图表示法"><a href="#2-3-类图表示法" class="headerlink" title="2.3 类图表示法"></a>2.3 类图表示法</h2><h3 id="2-3-1-类的表示方法"><a href="#2-3-1-类的表示方法" class="headerlink" title="2.3.1 类的表示方法"></a>2.3.1 类的表示方法</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的<strong>矩形</strong>来表示</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Employee.jpg" alt="Employee"></p><p>比如上图表示一个<code>Employee</code>类，它包含<code>name</code>,<code>age</code>和<code>address</code>这3个属性，以及<code>work()</code>方法</p><p>1）<strong>属性&#x2F;方法</strong>名称前加的<strong>加号</strong>和<strong>减号</strong>表示了这个属性&#x2F;方法的<strong>可见性</strong>，UML类图中表示可见性的符号有三种：</p><ul><li><code>+</code>  &#x3D;&gt; <code>public</code></li><li><code>-</code> &#x3D;&gt; <code>private</code></li><li><code>#</code> &#x3D;&gt; <code>protected</code></li></ul><p>2）属性的完整表示方法：<strong>可见性 名称: 类型[&#x3D; 缺省值]</strong></p><p>3）方法的完整表示方法：<strong>可见性 名称(参数列表)[: 返回类型]</strong></p><blockquote><p>注意：</p><ul><li>中括号中的内容表示是可选的</li><li>也有将类型放在变量名前面，返回值类型放在方法名前面</li></ul></blockquote><blockquote><p>举个栗子：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/demo.png" alt="demo"></p><p>上图Demo类定义了三个方法：</p><ul><li><code>method()</code>方法：修饰符为<code>public</code>，没有参数，没有返回值</li><li><code>method1()</code>方法：修饰符为<code>private</code>，没有参数，返回值类型为<code>String</code></li><li><code>method2()</code>方法：修饰符为<code>protected</code>，接收两个参数，第一个参数类型为<code>int</code>，第二个参数类型为<code>String</code>，返回值类型是<code>int</code></li></ul></blockquote><h3 id="2-3-2-类和类之间关系的表示方式"><a href="#2-3-2-类和类之间关系的表示方式" class="headerlink" title="2.3.2 类和类之间关系的表示方式"></a>2.3.2 类和类之间关系的表示方式</h3><p><strong>关联关系</strong>是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，<em>比如老师和学生、师傅和徒弟、丈夫和妻子等。</em></p><p>关联关系是类和类之间最常用的一种关系，分为：</p><ul><li>一般关联关系<ul><li>单向关联</li><li>双线关联</li><li>自关联</li></ul></li><li>聚合关系</li><li>组合关系</li><li>依赖关系</li><li>继承关系</li><li>实现关系</li></ul><h4 id="1、一般关联关系"><a href="#1、一般关联关系" class="headerlink" title="1、一般关联关系"></a>1、一般关联关系</h4><p>1）<strong>单向关联</strong></p><p>在UML类图中单向关联用一个<strong>带箭头的实线</strong>表示。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/customer_address.png" alt="customer_address"></p><p>上图表示每个顾客都有一个地址，这通过让<code>Customer</code>类持有一个类型为<code>Address</code>的成员变量类实现。</p><p>2）<strong>双向关联</strong></p><p>在UML类图中，双向关联用一个<strong>不带箭头的直线</strong>表示。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/customer_product.png" alt="customer_product"></p><blockquote><p>从上图中很容易看出，所谓的双向关联就是<strong>双方各自持有对方类型的成员变量</strong></p></blockquote><p>上图中在<code>Customer</code>类中维护一个<code>List\&lt;Product&gt;</code>，表示一个顾客可以购买多个商品；在<code>Product</code>类中维护一个<code>Customer</code>类型的成员变量表示这个产品被哪个顾客所购买。</p><p>3）<strong>自关联</strong></p><p>自关联在UML类图中用一个<strong>带有箭头且指向自身的线</strong>表示。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/node.png" alt="node"></p><p>上图的意思就是<code>Node</code>类包含类型为<code>Node</code>的成员变量，也就是“自己包含自己”。</p><h4 id="2、聚合关系"><a href="#2、聚合关系" class="headerlink" title="2、聚合关系"></a>2、聚合关系</h4><p>聚合关系是关联关系的一种，是<strong>强关联关系</strong>，是整体和部分之间的关系</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。<em>例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</em></p><p>在 UML 类图中，聚合关系可以用<strong>带空心菱形的实线</strong>来表示，<strong>菱形指向整体</strong>。</p><p>下图所示是大学和教师的关系图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20191229173422328.png" alt="image-20191229173422328"></p><h4 id="3、组合关系"><a href="#3、组合关系" class="headerlink" title="3、组合关系"></a>3、组合关系</h4><p>组合关系表示类之间的整体和部分的关系，但它是一种<strong>更强烈的聚合关系</strong></p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。<em>例如，头和嘴的关系，没有了头，嘴也就不存在了。</em></p><p>在 UML 类图中，组合关系用<strong>带实心菱形的实线</strong>来表示，<strong>菱形指向整体</strong>。</p><p>下图所示是头和嘴的关系图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20191229173455149.png" alt="image-20191229173455149"></p><h4 id="4、依赖关系"><a href="#4、依赖关系" class="headerlink" title="4、依赖关系"></a>4、依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间<strong>耦合度最弱</strong>的一种关联方式，是<strong>临时性的关联</strong>。</p><p>在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用<strong>带箭头的虚线</strong>来表示，<strong>箭头从使用类指向被依赖的类</strong>。</p><p>下图所示是司机和汽车的关系图，司机驾驶汽车：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20191229173518926.png" alt="image-20191229173518926"></p><h4 id="5、继承关系"><a href="#5、继承关系" class="headerlink" title="5、继承关系"></a>5、继承关系</h4><p>继承关系是对象之间<strong>耦合度最大</strong>的一种关系，表示一般与特殊的关系，<em>比如父类与子类之间的关系，是一种继承关系。</em></p><p>在 UML 类图中，泛化关系用<strong>带空心三角箭头的实线</strong>来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。</p><p>例如，<code>Student </code>类和 <code>Teacher </code>类都是 <code>Person </code>类的子类，其类图如下图所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20191229173539838.png" alt="image-20191229173539838"></p><h4 id="6、实现关系"><a href="#6、实现关系" class="headerlink" title="6、实现关系"></a>6、实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用<strong>带空心三角箭头的虚线</strong>来表示，<strong>箭头从实现类指向接口</strong>。</p><p>例如，汽车和船实现了交通工具，其类图下图所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20191229173554296.png" alt="image-20191229173554296"></p><h1 id="三、软件设计原则"><a href="#三、软件设计原则" class="headerlink" title="三、软件设计原则"></a>三、软件设计原则</h1><p>在软件开发中，为了提高软件系统的<strong>可维护性</strong>和<strong>可复用性</strong>，增加软件的可扩展性和灵活性，开发人员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1 开闭原则"></a>3.1 开闭原则</h2><p><strong>开闭原则：对扩展开放，对修改关闭</strong></p><p>在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用<strong>接口</strong>和<strong>抽象类</strong>。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>【例子】：<code>搜狗输入法</code>的皮肤设计</p><p>【分析】<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（<code>AbstractSkin</code>），而每个具体的皮肤（<code>DefaultSpecificSkin</code>和<code>HeimaSpecificSkin</code>）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/open-close.png" alt="open-close"></p><h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2 里氏代换原则"></a>3.2 里氏代换原则</h2><p><strong>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。</strong></p><p>通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>【例子】正方形不是长方形</p><p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2.png" alt="正方形不是长方形"></p><p>【代码】</p><p><strong>长方形类（Rectangle）：</strong></p><pre><code class="java">public class Rectangle &#123;    private double length;    private double width;    public double getLength() &#123;        return length;    &#125;    public void setLength(double length) &#123;        this.length = length;    &#125;    public double getWidth() &#123;        return width;    &#125;    public void setWidth(double width) &#123;        this.width = width;    &#125;&#125;</code></pre><p><strong>正方形（Square）：</strong></p><p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p><pre><code class="java">public class Square extends Rectangle &#123;        public void setWidth(double width) &#123;        super.setLength(width);        super.setWidth(width);    &#125;    public void setLength(double length) &#123;        super.setLength(length);        super.setWidth(length);    &#125;&#125;</code></pre><p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p><pre><code class="java">public class RectangleDemo &#123;        public static void resize(Rectangle rectangle) &#123;        while (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;            rectangle.setWidth(rectangle.getWidth() + 1);        &#125;    &#125;    //打印长方形的长和宽    public static void printLengthAndWidth(Rectangle rectangle) &#123;        System.out.println(rectangle.getLength());        System.out.println(rectangle.getWidth());    &#125;    public static void main(String[] args) &#123;        Rectangle rectangle = new Rectangle();        rectangle.setLength(20);        rectangle.setWidth(10);        resize(rectangle);        printLengthAndWidth(rectangle);        System.out.println(&quot;============&quot;);        Rectangle rectangle1 = new Square();        rectangle1.setLength(10);        resize(rectangle1);        printLengthAndWidth(rectangle1);    &#125;&#125;</code></pre><p>运行代码发现：</p><ul><li>假如我们把一个普通长方形作为参数传入<code>resize()</code>方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；</li><li>假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。</li></ul><p>&#x3D;&gt; 在<code>resize()</code>方法中，<code>Rectangle</code>类型的参数是不能被<code>Square</code>类型的参数所代替，如果进行了替换就得不到预期结果。因此，<code>Square</code>类和<code>Rectangle</code>类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p><p>【改进】重新设计它们的关系：抽象出来一个四边形接口(<code>Quadrilateral</code>)，让<code>Rectangle</code>类和<code>Square</code>类实现<code>Quadrilateral</code>接口</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2%E6%94%B9%E8%BF%9B.png" alt="正方形不是长方形改进"></p><h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h2><p><strong>依赖倒转原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该以来抽象</strong></p><p>简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>【例子】组装电脑<br>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99.png" alt="依赖倒转原则"></p><p>【代码】</p><p><strong>希捷硬盘类（XiJieHardDisk）:</strong></p><pre><code class="java">public class XiJieHardDisk implements HardDisk &#123;    public void save(String data) &#123;        System.out.println(&quot;使用希捷硬盘存储数据&quot; + data);    &#125;    public String get() &#123;        System.out.println(&quot;使用希捷希捷硬盘取数据&quot;);        return &quot;数据&quot;;    &#125;&#125;</code></pre><p><strong>Intel处理器（IntelCpu）：</strong></p><pre><code class="java">public class IntelCpu implements Cpu &#123;    public void run() &#123;        System.out.println(&quot;使用Intel处理器&quot;);    &#125;&#125;</code></pre><p><strong>金士顿内存条（KingstonMemory）：</strong></p><pre><code class="java">public class KingstonMemory implements Memory &#123;    public void save() &#123;        System.out.println(&quot;使用金士顿作为内存条&quot;);    &#125;&#125;</code></pre><p><strong>电脑（Computer）：</strong></p><pre><code class="java">public class Computer &#123;    private XiJieHardDisk hardDisk;    private IntelCpu cpu;    private KingstonMemory memory;    public IntelCpu getCpu() &#123;        return cpu;    &#125;    public void setCpu(IntelCpu cpu) &#123;        this.cpu = cpu;    &#125;    public KingstonMemory getMemory() &#123;        return memory;    &#125;    public void setMemory(KingstonMemory memory) &#123;        this.memory = memory;    &#125;    public XiJieHardDisk getHardDisk() &#123;        return hardDisk;    &#125;    public void setHardDisk(XiJieHardDisk hardDisk) &#123;        this.hardDisk = hardDisk;    &#125;    public void run() &#123;        System.out.println(&quot;计算机工作&quot;);        cpu.run();        memory.save();        String data = hardDisk.get();        System.out.println(&quot;从硬盘中获取的数据为：&quot; + data);    &#125;&#125;</code></pre><p><strong>测试类（TestComputer）：</strong></p><p>测试类用来组装电脑。</p><pre><code class="java">public class TestComputer &#123;    public static void main(String[] args) &#123;        Computer computer = new Computer();        computer.setHardDisk(new XiJieHardDisk());        computer.setCpu(new IntelCpu());        computer.setMemory(new KingstonMemory());        computer.run();    &#125;&#125;</code></pre><p>【问题】上述代码已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。</p><p>【改进】修改<code>Computer</code>类，让<code>Computer</code>类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B.png" alt="依赖倒转原则改进"></p><p><strong>电脑（Computer）：</strong></p><pre><code class="java">public class Computer &#123;    private HardDisk hardDisk;    private Cpu cpu;    private Memory memory;    public HardDisk getHardDisk() &#123;        return hardDisk;    &#125;    public void setHardDisk(HardDisk hardDisk) &#123;        this.hardDisk = hardDisk;    &#125;    public Cpu getCpu() &#123;        return cpu;    &#125;    public void setCpu(Cpu cpu) &#123;        this.cpu = cpu;    &#125;    public Memory getMemory() &#123;        return memory;    &#125;    public void setMemory(Memory memory) &#123;        this.memory = memory;    &#125;    public void run() &#123;        System.out.println(&quot;计算机工作&quot;);    &#125;&#125;</code></pre><p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大<strong>降低</strong>了客户程序与实现细节的<strong>耦合度</strong>。</p><h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h2><p><strong>接口隔离原则：客户端不应该被迫依赖它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上</strong></p><p>【例子】安全门案例</p><p>我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.png" alt="接口隔离原则"></p><p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则。</p><p>【修改】最小抽象类</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png" alt="接口隔离原则1"></p><p>【代码】</p><p><strong>AntiTheft（接口）：</strong></p><pre><code class="java">public interface AntiTheft &#123;    void antiTheft();&#125;</code></pre><p><strong>Fireproof（接口）：</strong></p><pre><code class="java">public interface Fireproof &#123;    void fireproof();&#125;</code></pre><p><strong>Waterproof（接口）：</strong></p><pre><code class="java">public interface Waterproof &#123;    void waterproof();&#125;</code></pre><p><strong>HeiMaSafetyDoor（类）：</strong></p><pre><code class="java">public class HeiMaSafetyDoor implements AntiTheft,Fireproof,Waterproof &#123;    public void antiTheft() &#123;        System.out.println(&quot;防盗&quot;);    &#125;    public void fireproof() &#123;        System.out.println(&quot;防火&quot;);    &#125;    public void waterproof() &#123;        System.out.println(&quot;防水&quot;);    &#125;&#125;</code></pre><p><strong>ItcastSafetyDoor（类）：</strong></p><pre><code class="java">public class ItcastSafetyDoor implements AntiTheft,Fireproof &#123;    public void antiTheft() &#123;        System.out.println(&quot;防盗&quot;);    &#125;    public void fireproof() &#123;        System.out.println(&quot;防火&quot;);    &#125;&#125;</code></pre><h2 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h2><p><strong>最小知识原则</strong></p><p><em>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</em></p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以<strong>通过第三方转发该调用</strong>。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>【例子】明星和经纪人的关系实例</p><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99.png" alt="迪米特法则"></p><p>【代码】</p><p><strong>明星类（Star）</strong></p><pre><code class="java">public class Star &#123;    private String name;    public Star(String name) &#123;        this.name=name;    &#125;    public String getName() &#123;        return name;    &#125;&#125;</code></pre><p><strong>粉丝类（Fans）</strong></p><pre><code class="java">public class Fans &#123;    private String name;    public Fans(String name) &#123;        this.name=name;    &#125;    public String getName() &#123;        return name;    &#125;&#125;</code></pre><p><strong>媒体公司类（Company）</strong></p><pre><code class="java">public class Company &#123;    private String name;    public Company(String name) &#123;        this.name=name;    &#125;    public String getName() &#123;        return name;    &#125;&#125;</code></pre><p><strong>经纪人类（Agent）</strong></p><pre><code class="java">public class Agent &#123;    private Star star;    private Fans fans;    private Company company;    public void setStar(Star star) &#123;        this.star = star;    &#125;    public void setFans(Fans fans) &#123;        this.fans = fans;    &#125;    public void setCompany(Company company) &#123;        this.company = company;    &#125;    public void meeting() &#123;        System.out.println(fans.getName() + &quot;与明星&quot; + star.getName() + &quot;见面了。&quot;);    &#125;    public void business() &#123;        System.out.println(company.getName() + &quot;与明星&quot; + star.getName() + &quot;洽淡业务。&quot;);    &#125;&#125;</code></pre><h2 id="3-6-合成复用原则"><a href="#3-6-合成复用原则" class="headerlink" title="3.6 合成复用原则"></a>3.6 合成复用原则</h2><p><strong>合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑继承关系来实现</strong></p><p>通常类的复用分为继承复用和合成复用两种。</p><p>1）继承复用虽然有<strong>简单</strong>和<strong>易实现</strong>的优点，但它也存在以下缺点：</p><ol><li>继承复用<strong>破坏了类的封装性</strong>。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li><strong>子类与父类的耦合度高</strong>。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它<strong>限制了复用的灵活性</strong>。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>2）采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它<strong>维持了类的封装性</strong>。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li><strong>对象间的耦合度低</strong>。可以在类的成员位置声明抽象。</li><li><strong>复用的灵活性高</strong>。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>【例子】汽车分类管理程序</p><p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：</p><p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99.png" alt="合成复用原则"></p><p>【改进】</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%991.png" alt="合成复用原则1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之路 -- 动态规划篇之专项练习</title>
      <link href="/2022/12/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/"/>
      <url>/2022/12/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0">算法学习之路–动态规划篇之专项练习</a><ul><li><a href="#%E4%B8%80leetcode%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">一、LeetCode经典题目解析</a><ul><li><a href="#198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">198、打家劫舍</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li></ul></li><li><a href="#213%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii">213、打家劫舍II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-1">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-1">实现</a></li></ul></li><li><a href="#337%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Diii">337、打家劫舍III</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-2">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-2">实现</a></li></ul></li><li><a href="#121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">121、买卖股票的最佳时机</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-3">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-3">实现</a></li></ul></li><li><a href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii">122 买卖股票的最佳时机II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-4">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-4">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-4">实现</a></li></ul></li><li><a href="#123%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiii">123、买卖股票的最佳时机III</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-5">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-5">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-5">实现</a></li></ul></li><li><a href="#188%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiv">188、买卖股票的最佳时机IV</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-6">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-6">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-6">实现</a></li></ul></li><li><a href="#309%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F">309、最佳买卖股票时机含冷冻期</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-7">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-7">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-7">实现</a></li></ul></li><li><a href="#714%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9">714、最佳买卖股票时机含手续费</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-8">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-8">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-8">实现</a></li></ul></li><li><a href="#300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">300、最长递增子序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-9">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-9">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-9">实现</a></li></ul></li><li><a href="#674%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97">674、最长连续递增序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-10">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-10">思路</a><ul><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li><li><a href="#%E8%B4%AA%E5%BF%83">贪心</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-10">实现</a><ul><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1">动态规划</a></li><li><a href="#%E8%B4%AA%E5%BF%83-1">贪心</a></li></ul></li></ul></li><li><a href="#718%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84">718、最长重复子数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-11">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-11">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-11">实现</a></li></ul></li><li><a href="#1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">1143、最长公共子序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-12">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-12">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-12">实现</a></li></ul></li><li><a href="#1035%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF">1035、不相交的线</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-13">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-13">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-13">实现</a></li></ul></li><li><a href="#53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C">53、最大子序和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-14">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-14">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-14">实现</a></li></ul></li><li><a href="#392%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97">392、判断子序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-15">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-15">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-15">实现</a></li></ul></li><li><a href="#115%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97">115、不同的子序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-16">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-16">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-16">实现</a></li></ul></li><li><a href="#583%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">583、两个字符串的删除操作</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-17">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-17">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-17">实现</a></li></ul></li><li><a href="#72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">72、编辑距离</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-18">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-18">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-18">实现</a></li></ul></li><li><a href="#647%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">647、回文子串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-19">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-19">思路</a><ul><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2">动态规划</a></li><li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88">双指针</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-19">实现</a><ul><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3">动态规划</a></li><li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88-1">双指针</a></li></ul></li></ul></li><li><a href="#516%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97">516、最长回文子序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-20">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-20">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-20">实现</a></li></ul></li></ul></li><li><a href="#%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87">二、动态规划总结篇</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h1 id="算法学习之路–动态规划篇之专项练习"><a href="#算法学习之路–动态规划篇之专项练习" class="headerlink" title="算法学习之路–动态规划篇之专项练习"></a>算法学习之路–动态规划篇之专项练习</h1><h2 id="一、LeetCode经典题目解析"><a href="#一、LeetCode经典题目解析" class="headerlink" title="一、LeetCode经典题目解析"></a>一、LeetCode经典题目解析</h2><h3 id="198、打家劫舍"><a href="#198、打家劫舍" class="headerlink" title="198、打家劫舍"></a>198、打家劫舍</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode）</a>**</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><pre><code>输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>打家劫舍是dp解决的经典问题。动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i]</code>：表示下标<code>i</code>（包含 i ）以内的房屋，最多可以偷窃的金额为<code>dp[i]</code></p></li><li><p>确定递推公式<br>决定<code>dp[i]</code>的因素是第 i 间房间偷还是不偷。如果偷第 i 间房间，那么<code>dp[i] = dp[i - 2] + nums[i]</code>，即第 i-1 间房一定是不考虑的，找出下标 i-2 （包含 i-2）以内的房屋，最多可以偷窃的金额为<code>dp[i - 2]</code>加上第 i 间房间偷到的钱；如果不偷第 i 间房间，那么<code>dp[i] = dp[i - 1]</code>，即考虑第 i - 1 间房（注意这里是考虑，并不是一定要偷第 i-1 间房）。然后<code>dp[i]</code>取最大值<br>&#x3D;&gt;  递推公式：<code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code> </p></li><li><p>dp数组初始化<br>从递推公式：<code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code> 可以看出递推基础是<code>dp[0]</code>和<code>dp[1]</code><br>从<code>dp[i]</code>的定义上来讲，<code>dp[0] = nums[0]</code>，<code>dp[1] = Math.max(nums[0], nums[1])</code></p><pre><code class="java">int[] dp = new int[nums.length];dp[0] = nums[0];dp[1] = Math.max(nums[0],nums[1]);</code></pre></li><li><p>确定遍历顺序<br><code>dp[i]</code> 是根据<code>dp[i - 2] </code>和 <code>dp[i - 1]</code> 推导出来的，那么⼀定是从前到后遍历！</p><pre><code class="java">for (int i = 2; i &lt; nums.length; i++) &#123; dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);&#125;</code></pre></li><li><p>举例推导dp数组<br>以示例二输入为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221218155329209.png" alt="image-20221218155329209"></p></li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public int rob(int[] nums) &#123;        int len = nums.length;        if(len == 1) return nums[0];        int[] dp = new int[len];        dp[0] = nums[0];        dp[1] = Math.max(nums[0], nums[1]);        for(int i = 2; i &lt; len; i++) &#123;            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);        &#125;        return dp[len - 1];    &#125;&#125;</code></pre><h3 id="213、打家劫舍II"><a href="#213、打家劫舍II" class="headerlink" title="213、打家劫舍II"></a>213、打家劫舍II</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode）</a>**</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p> <strong>示例 1：</strong></p><pre><code>输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,2,3]输出：3</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这道题目和**<a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode）</a>**是大差不差的，唯一的区别就是成环了</p><p>对于一个数组，成环主要是如下三种情况</p><ul><li>情况一：考虑不包含首尾元素<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221218160126.png"></li><li>情况二：考虑包含首元素，不包含尾元素<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221218160213.png"></li><li>情况三：考虑包含尾元素，不包含首元素<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221218160259.png"></li></ul><blockquote><p>注意这里是<strong>考虑</strong>，例如情况三：虽然是考虑包含尾元素，但不一定要选尾元素！对于情况三，取nums[1] 和 nums[3]就是最⼤的</p><p><strong>而情况二和情况三 都包含了情况一了，所以只需要考虑情况二和情况三就可以了</strong></p></blockquote><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public int rob(int[] nums) &#123;        if(nums.length == 1) return nums[0];        // 考虑首元素，不考虑尾元素        int[] nums1 = Arrays.copyOfRange(nums,0,nums.length - 1);        // 考虑尾元素，不考虑首元素        int[] nums2 = Arrays.copyOfRange(nums,1,nums.length);        return Math.max(robRange(nums1),robRange(nums2));    &#125;    // 198.打家劫舍的逻辑    public int robRange(int[] nums) &#123;        if(nums.length == 1) return nums[0];        int[] dp = new int[nums.length];        dp[0] = nums[0];        dp[1] = Math.max(nums[0],nums[1]);        for(int i = 2; i &lt; nums.length; i++) &#123;            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);        &#125;        return dp[nums.length - 1];    &#125;&#125;</code></pre><pre><code class="java">class Solution &#123;    public int rob(int[] nums) &#123;        if(nums.length == 1) return nums[0];        // 考虑首元素，不考虑尾元素        int res1 = robRange(nums, 0, nums.length - 1);        // 考虑尾元素，不考虑首元素        int res2 = robRange(nums, 1, nums.length);        return Math.max(res1, res2);    &#125;    public int robRange(int[] nums, int startIndex, int endIndex) &#123;        if(endIndex - startIndex == 1) return nums[startIndex];        int[] dp = new int[nums.length];        dp[startIndex] = nums[startIndex];        dp[startIndex + 1] = Math.max(nums[startIndex],nums[startIndex + 1]);        for(int i = startIndex + 2; i &lt; endIndex; i++) &#123;            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);        &#125;        return dp[endIndex - 1];    &#125;&#125;</code></pre><h3 id="337、打家劫舍III"><a href="#337、打家劫舍III" class="headerlink" title="337、打家劫舍III"></a>337、打家劫舍III</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III - 力扣（LeetCode）</a>**</p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/rob1-tree.jpg" alt="img"></p><pre><code>输入: root = [3,2,3,null,3,null,1]输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</code></pre><p><strong>示例 2:</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/rob2-tree.jpg" alt="img"></p><pre><code>输入: root = [3,4,5,1,3,null,1]输出: 9解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</code></pre><p><strong>提示：</strong></p><ul><li>树的节点数在 [1, 10<sup>4</sup>]范围内</li><li>0 &lt;&#x3D; Node.val &lt;&#x3D; 10<sup>4</sup></li></ul><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>本题和**<a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode）</a><strong>、</strong><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode）</a>**如出一辙，只不过本题换成了树（树形dp的入门题目）</p><p>对于树的话，首先就要想到遍历方式，前中后序（深度优先搜索）还是层序遍历（广度优先搜索）</p><p><strong>本题一定是要后序遍历，因为通过递归函数的返回值来做下一步的计算</strong></p><p>和之前两题一样，关键是要讨论当前节点偷还是不偷</p><p>如果偷了当前节点，两个子节点就不偷，如果没偷当前节点，就可以<strong>考虑</strong>左右节点</p><p>递归三部曲 + 动归五部曲：</p><ol><li><p>确定递归函数的参数和返回值<br>此处我们要求一个节点偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组，参数为当前节点</p><pre><code class="java">int[] robTree(TreeNode curNode) &#123;    // action&#125;</code></pre><p>其实这里的返回数组就是dp数组<br>所以dp数组以及下标的含义：<code>dp[0]</code>记录不偷该节点所得到的的最大金钱，<code>dp[1]</code>记录偷该节点所得到的最大金钱 &#x3D;&gt; 本题dp数组是一个长度为2的数组</p><blockquote><p>长度为2的数组怎么标记树中每个节点的状态？</p><p><strong>递归的过程中，系统栈会保存每一层递归的参数</strong></p></blockquote></li><li><p>确定终止条件<br>在遍历的过程中，如果遇到空节点，此时偷与不偷都是0，直接返回</p><pre><code class="java">if(curNode == null) return new int[]&#123;0, 0&#125;;</code></pre><p>这也相当于dp数组的初始化</p></li><li><p>确定遍历顺序<br>首先明确的是使用后序遍历，因为要通过递归函数的返回值来做下一步计算</p><ul><li>通过递归左节点，得到左节点偷与不偷的金钱</li><li>通过递归右节点，得到右节点偷与不偷的金钱</li></ul><pre><code class="java">// 下标0 =&gt; 不偷，下标1 =&gt; 偷int[] left = robTree(curNode.left); // 左节点int[] right = robTree(curNode.right); // 右节点// 父结点</code></pre></li><li><p>确定单层递归的逻辑</p><ul><li>如果是偷当前节点，那么左右节点就不能偷，<code>val1 = vurNode.val + left[0] + right[0]</code></li><li>如果不偷当前节点，那么左右节点就可以偸，至于到底偷不偷一定是选一个最大的，<code>val2 = Math.max(left[0], left[1]) + Math.max(right[0], right[1])</code></li></ul><p>最后当前节点的状态就是<code>&#123;val2,val1&#125;</code>，即{不偷当前节点得到的最大金钱， 偷当前节点得到的最大金钱}</p><pre><code class="java">// 下标0 =&gt; 不偷，下标1 =&gt; 偷int[] left = robTree(curNode.left); // 左节点int[] right = robTree(curNode.right); // 右节点// 偷当前节点int val1 = curNode.val + left[0] + right[0];// 不偷当前节点int val2 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);return new int[] &#123;val2, val1&#125;;</code></pre></li><li><p>举例推导dp数组<br>以示例1为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221218164144.png"><br>最后头节点就是取下标0 和 下标1的最大值就是偷得的最大金钱</p></li></ol><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n) 每个节点只遍历了⼀次// 空间复杂度：O(logn) 算上递推系统栈的空间class Solution &#123;    public int rob(TreeNode root) &#123;        // res[0]: 不偷当前节点得到的最大金钱        // res[1]: 偷当前节点得到的最大金钱        int[] res = robTree(root);        return Math.max(res[0], res[1]);    &#125;    private int[] robTree(TreeNode curNode) &#123;        if(curNode == null) return new int[]&#123;0, 0&#125;;        // 递归左节点        int[] left = robTree(curNode.left);         // 递归右节点        int[] right = robTree(curNode.right);// 空间复杂度：O(logn) 算上递推系统栈的空间        // 偷当前节点        int val1 = curNode.val + left[0] + right[0];        // 不偷当前节点        int val2 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);        return new int[]&#123;val2, val1&#125;;    &#125;&#125;</code></pre><hr><h3 id="121、买卖股票的最佳时机"><a href="#121、买卖股票的最佳时机" class="headerlink" title="121、买卖股票的最佳时机"></a>121、买卖股票的最佳时机</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a>**</p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =5。    注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 10<sup>5</sup></li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10<sup>4</sup></li></ul><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>动归五部曲</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][0]</code>：表示第 i 天持有股票所得的最多现金</p><blockquote><p>一开始现金是0，加入第 i 天买入股票现金就是 -price[i]</p></blockquote><p><code>dp[i][1]</code>：表示第 i 天不持有股票所得最多现金</p><blockquote><p><strong>持有</strong>不代表当天“买入”，也有可能是昨天就买入了，保持持有的状态</p></blockquote></li><li><p>确定递推公式<br>如果第 i 天持有股票，即<code>dp[i][0]</code>，那么可以由两个状态推出：</p><ul><li>第 i - 1 天就持有股票，保持现状，所得现金就是昨天持有股票的所得现金，即<code>dp[i - 1][0]</code></li><li>第 i 天买入股票，所得现金就是买入今天的股票后所得现金，即<code>-prices[i]</code></li></ul><p>&#x3D;&gt; <code>dp[i][0] = Math.max(dp[i - 1][0], -prices[i])</code></p><p>如果第 i 天不持有股票，即<code>dp[i][1]</code>，那么可以由两个状态推出：</p><ul><li>第 i - 1 天就不持有股票，保持现状，所得现金就是昨天不持有股票的所得现金，即<code>dp[i - 1][1]</code></li><li>第 i 天卖出股票，所得现金就是按照今天股票的价格卖出后所得现金，即<code>prices[i] + dp[i - 1][0]</code></li></ul><p>&#x3D;&gt; <code>dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0])</code></p></li><li><p>dp数组初始化<br>由递推公式<code> dp[i][0] = max(dp[i - 1][0], -prices[i]);</code> 和<code> dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</code>可以看出其基础都是要从<code>dp[0][0]</code>和<code>dp[0][1]</code>推导出来<br>那么<code>dp[0][0]</code>表⽰第0天持有股票，此时的持有股票就⼀定是买⼊股票了，因为不可能有前⼀ 天推出来，所以<code>dp[0][0] -= prices[0];</code> <code>dp[0][1]</code>表⽰第0天不持有股票，不持有股票那么现⾦就是0，所以<code>dp[0][1] = 0</code></p><pre><code class="java">int[][] dp = new int[prices.length][2];dp[0][0] = - prices[0];dp[0][1] = 0;</code></pre></li><li><p>确定遍历顺序<br>从递推公式可以看出<code>dp[i]</code>都是有<code>dp[i - 1]</code>推导出来的，那么⼀定是从前向后遍历</p></li><li><p>举例推导dp数组<br>以示例1输入[7,1,5,3,6,4]为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219095905.png"><br><strong>本题不持有股票状态所得金钱一定比持有股票状态得到的多</strong></p></li></ol><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int maxProfit(int[] prices) &#123;        int[][] dp = new int[prices.length][2];        // dp[i][0]：表示持有股票        // dp[i][1]：表示不持有股票        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i = 1; i &lt; prices.length; i++) &#123;            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);            dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);        &#125;        return dp[prices.length - 1][1];    &#125;&#125;</code></pre><p>从递推公式可以看出，<code>dp[i</code>]只是依赖于<code>dp[i - 1]</code>的状态 &#x3D;&gt; 那么我们只需要记录 当前这天的dp状态和前一天的dp状态就可以了，可以使用滚动数组节省空间</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int maxProfit(int[] prices) &#123;        int[][] dp = new int[2][2];        // dp[i][0]：表示持有股票        // dp[i][1]：表示不持有股票        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i = 1; i &lt; prices.length; i++) &#123;            dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], -prices[i]);            dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);        &#125;        return dp[(prices.length - 1) % 2][1];    &#125;&#125;</code></pre><h3 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122 买卖股票的最佳时机II"></a>122 买卖股票的最佳时机II</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a>**</p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。     总利润为 4 + 3 = 7 </code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。     总利润为 4 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 10<sup>4</sup></li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10<sup>4</sup></li></ul><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>本题的动规五部曲分析和**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a>**的唯一区别体现在递推公式上</p><p><strong>递推公式</strong></p><p>回顾下dp数组的含义</p><ul><li><code>dp[i][1]</code>：表示第 i 天不持有股票所得最多现金</li><li><code>dp[i][0]</code>：表示第 i 天持有股票所得的最多现金</li></ul><p>如果第 i 天持有股票即<code>dp[i][0]</code>，那么可以由两个状态推出：</p><ul><li>第 i - 1 天就持有股票，保持现状，所得现金就是昨天持有股票的所得现金，即<code>dp[i - 1][0]</code></li><li>第 i 天买入股票，所得现金就是昨天不持有股票所得的现金减去今天的股票价格，即<code>dp[i - 1][1]-prices[i]</code></li></ul><p>&#x3D;&gt; <code>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</code></p><blockquote><p>注意这里和**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a><strong>唯一不同的地方，就是推导<code>dp[i][0]</code>的时候，第天买入股票的情况。<br>在</strong><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a>**中，因为股票全程只能买卖一次，所以如果买入股票，那么第 i 天持有股票即<code>dp[i][O]</code>一定就是<code>-prices[i]</code>。<br>而本题，因为一只股票可以买卖多次，所以当第 i 天买入股票的时候，所持有的现金可能有之前买卖过的利润。</p><p>&#x3D;&gt;  第 i 天持有股票即<code>dp[i][0]</code>，如果是第i天买⼊股票，所得现⾦就是昨天不持有股票的所得现⾦减去今天的股票价格 即：<code>dp[i - 1][1] - prices[i]</code></p></blockquote><p>如果第 i 天不持有股票即<code>dp[i][1]</code>的情况，可以由两个状态推出：</p><ul><li>第 i - 1 天就不持有股票，保持现状，所得现金就是昨天不持有股票的所得现金，即<code>dp[i - 1][1]</code></li><li>第 i 天卖出股票，所得现金就是按照今天股票的价格卖出后所得现金，即<code>prices[i] + dp[i - 1][0]</code></li></ul><p>&#x3D;&gt; <code>dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);</code></p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int maxProfit(int[] prices) &#123;        int[][] dp = new int[prices.length][2];        // dp[i][0]：表示持有股票        // dp[i][1]：表示不持有股票        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i = 1; i &lt; prices.length; i++) &#123;            // 这里是唯一与121、买卖股票的最佳时机不同的地方            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);            dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);        &#125;        return dp[prices.length - 1][1];    &#125;&#125;</code></pre><p>滚动数组实现</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int maxProfit(int[] prices) &#123;        int[][] dp = new int[2][2];        // dp[i][0]：表示持有股票        // dp[i][1]：表示不持有股票        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i = 1; i &lt; prices.length; i++) &#123;            dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i]);            dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);        &#125;        return dp[(prices.length - 1) % 2][1];    &#125;&#125;</code></pre><h3 id="123、买卖股票的最佳时机III"><a href="#123、买卖股票的最佳时机III" class="headerlink" title="123、买卖股票的最佳时机III"></a>123、买卖股票的最佳时机III</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a>**</p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><pre><code>输入：prices = [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：prices = [1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 10<sup>5</sup></li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10<sup>5</sup></li></ul><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题关键：<strong>至多买卖两次</strong>，这意味着可以买卖一次，可以买卖两次，也可以不买卖</p></blockquote><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br>一天一共就有五个状态</p><ul><li>0 &#x3D;&gt; 没有操作</li><li>1 &#x3D;&gt; 第一次买入</li><li>2 &#x3D;&gt; 第一次卖出</li><li>3 &#x3D;&gt; 第二次买入</li><li>4 &#x3D;&gt; 第二次卖出</li></ul><p><code>dp[i][j]</code>中的  i 表示第 i 天，j 为 以上五个状态（取值[0 - 4]），<code>do[i][j]</code>表示第 i 天状态 j 所剩的最大现金</p></li><li><p>确定递推公式</p><blockquote><p>注意：<code>dp[i][1]</code>，表⽰的是第i天，买⼊股票的<strong>状态</strong>，并不是说⼀定要第i天买⼊股票</p></blockquote><p>1）达到<code>dp[i][1]</code>状态，有两个具体操作</p><ul><li>操作一：第 i 天买入股票，那么<code>dp[i][1] = dp[i - 1][0] - prices[i]</code></li><li>操作二：第 i 天没有操作，而是保持前一天买入的状态，即<code>dp[i][1] = dp[i - 1][1]</code></li></ul><p>&#x3D;&gt; <code>dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);</code></p><p>2）同理<code>dp[i][2]</code>也有两个操作</p><ul><li>操作一：第 i 天卖出股票，那么<code>dp[i][2] = dp[i - 1][1] + prices[i]</code></li><li>操作二：第 i 天没有操作，而是保持前一天卖出的状态，即<code>dp[i][2] = dp[i - 1][2]</code></li></ul><p>&#x3D;&gt; <code>dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2]);</code></p><p>3）同理推出剩下的状态</p><p>&#x3D;&gt;  <code>dp[i][3] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][3]);</code></p><p>&#x3D;&gt;  <code>dp[i][4] = Marh.max(dp[i - 1][3] + prices[i], dp[i - 1][4]);</code></p></li><li><p>dp数组初始化</p><ul><li><p>第 0 天没有操作，<code>dp[0][0] = 0</code></p></li><li><p>第 0 天做第一次买入的状态，<code>dp[0][1] = -prices[0]</code></p></li><li><p>第 0 天做第一次卖出的操作，<code>dp[0][2] = 0</code></p><blockquote><p>卖出操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作，现金为0</p><p>从递推公式中可以看出每次都是取最大值，那么既然是收获利润，如果比0还小就没有必要了</p><p>&#x3D;&gt; <code>dp[0][2] = 0</code></p></blockquote></li><li><p>第 0 天做第二次买入操作，<code>dp[0][3] = -prices[0]</code></p><blockquote><p>不⽤管第⼏次，现在⼿头上没有现⾦，只要买⼊，现⾦就做相应的减少。</p></blockquote></li><li><p>第 0 天做第二次卖出操作，<code>dp[0][4] = 0</code></p></li></ul></li><li><p>确定遍历顺序<br>从递推公式其实已经可以看出，⼀定是从前向后遍历，因为<code>dp[i]</code>，依靠<code>dp[i - 1]</code>的数值</p></li><li><p>举例推导dp数组<br>以输入[1,2,3,4,5]为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219104835.png"><br><strong>利润最大的时候一定是卖出的状态，而两次卖出的状态利润最大一定是最后一次卖出的状态</strong></p></li></ol><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n * 5)class Solution &#123;    public int maxProfit(int[] prices) &#123;        int[][] dp = new int[prices.length][5];        dp[0][1] = -prices[0];        dp[0][3] = -prices[0];        for(int i = 1; i &lt; prices.length; i++) &#123;            dp[i][0] = dp[i - 1][0];            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);        &#125;        return dp[prices.length - 1][4];    &#125;&#125;</code></pre><p>LeetCode官方题解：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int maxProfit(int[] prices) &#123;        int n = prices.length;        int buy1 = -prices[0], sell1 = 0;        int buy2 = -prices[0], sell2 = 0;        for (int i = 1; i &lt; n; ++i) &#123;            buy1 = Math.max(buy1, -prices[i]);            sell1 = Math.max(sell1, buy1 + prices[i]);            buy2 = Math.max(buy2, sell1 - prices[i]);            sell2 = Math.max(sell2, buy2 + prices[i]);        &#125;        return sell2;    &#125;&#125;</code></pre><blockquote><p><code>sell1</code> 利用的就是当天的 <code>buy1</code></p><p><code>buy1 = Math.max(buy1, -prices[i]);</code>，</p><p>如果<code>buy1</code>取<code>buy1</code>，即保持第一次买入股票的状态，那么<code>sell1 = Math.max(sell1, buy1 + prices[i]);</code>中的<code>buy1 +  prices[i]</code>就是今天第一次卖出</p><p>如果<code>buy1</code>取<code>0 - prices[i]</code>，即今天第一次买入股票，那么<code>sell1 = Math.max(sell1, buy1 + prices[i]);</code>中的<code>buy1 +  prices[i]</code>就相当于是今天再卖出股票，一买一卖收益为0.对所得现金没有影响，相当于今天买入股票又卖出股票，等于没有操作，保持昨天卖出股票的状态</p></blockquote><h3 id="188、买卖股票的最佳时机IV"><a href="#188、买卖股票的最佳时机IV" class="headerlink" title="188、买卖股票的最佳时机IV"></a>188、买卖股票的最佳时机IV</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a>**</p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><pre><code>输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 100</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br>使⽤⼆维数组 <code>dp[i][j] </code>：第 i 天的状态为 j，所剩下的最⼤现⾦是<code>dp[i][j]</code><br>j 的状态表示：</p><ul><li>0表示不操作</li><li>1第一次买入</li><li>2第一次卖出</li><li>3第二次买入</li><li>4第二次卖出</li><li>……</li></ul><blockquote><p>规律：除了 0 以外，偶数就是卖出，奇数就是买入</p><p>题目要求是至多有K笔交易，那么 j 的范围就定义为 2 * k + 1</p></blockquote><pre><code class="java">int[][] dp = new int[prices.length][2 * k + 1];</code></pre></li><li><p>确定递推公式</p><blockquote><p>注意：<code>dp[i][1]</code>，表⽰的是第i天，买⼊股票的<strong>状态</strong>，并不是说⼀定要第i天买⼊股票</p></blockquote><p>1）达到<code>dp[i][1]</code>状态，有两个具体操作</p><ul><li>操作一：第 i 天买入股票，那么<code>dp[i][1] = dp[i - 1][0] - prices[i]</code></li><li>操作二：第 i 天没有操作，而是保持前一天买入的状态，即<code>dp[i][1] = dp[i - 1][1]</code></li></ul><p>&#x3D;&gt; <code>dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);</code></p><p>2）同理<code>dp[i][2]</code>也有两个操作</p><ul><li>操作一：第 i 天卖出股票，那么<code>dp[i][2] = dp[i - 1][1] + prices[i]</code></li><li>操作二：第 i 天没有操作，而是保持前一天卖出的状态，即<code>dp[i][2] = dp[i - 1][2]</code></li></ul><p>&#x3D;&gt; <code>dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2]);</code></p><p>3）同理类比剩下的状态</p><pre><code class="java">for (int j = 0; j &lt; 2 * k - 1; j += 2) &#123;     dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);     dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);&#125;</code></pre><blockquote><p>本题与**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a>**最大区别就是这里要类比 j 为奇数是买入，偶数是卖出的状态</p></blockquote></li><li><p>dp数组初始化</p><ul><li><p>第 0 天没有操作，<code>dp[0][0] = 0</code></p></li><li><p>第 0 天做第一次买入的状态，<code>dp[0][1] = -prices[0]</code></p></li><li><p>第 0 天做第一次卖出的操作，<code>dp[0][2] = 0</code></p><blockquote><p>卖出操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作，现金为0</p><p>从递推公式中可以看出每次都是取最大值，那么既然是收获利润，如果比0还小就没有必要了</p><p>&#x3D;&gt; <code>dp[0][2] = 0</code></p></blockquote></li><li><p>第 0 天做第二次买入操作，<code>dp[0][3] = -prices[0]</code></p><blockquote><p>不⽤管第⼏次，现在⼿头上没有现⾦，只要买⼊，现⾦就做相应的减少。</p></blockquote></li><li><p>同理推出**<code>dp[0][j]</code>当 j 为奇数时都初始化为<code>-prices[0]</code>**</p><pre><code class="java">for (int j = 1; j &lt; 2 * k; j += 2) &#123;     dp[0][j] = -prices[0];&#125;</code></pre><p><strong>在初始化的地⽅同样要类⽐ j 为偶数是卖出、奇数是买入的状态。</strong></p></li></ul></li><li><p>确定遍历顺序<br>从递推公式其实已经可以看出，⼀定是从前向后遍历，因为<code>dp[i]</code>，依靠<code>dp[i - 1]</code>的数值</p></li><li><p>举例推导dp数组<br>以输入[1,2,3,4,5]，k&#x3D;2为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219104835.png"><br><strong>最后⼀次卖出，⼀定是利润最⼤的，<code>dp[prices.length - 1][2 * k]</code>即红⾊部分就是最后求解</strong></p></li></ol><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public int maxProfit(int k, int[] prices) &#123;        if(prices.length == 0) return 0;        int[][] dp = new int[prices.length][k * 2 + 1];        for(int j = 1;j &lt; k * 2; j += 2) &#123;            dp[0][j] = -prices[0];        &#125;        for(int i = 1; i &lt; prices.length; i++) &#123;            for(int j = 0; j &lt; k * 2 - 1; j += 2) &#123;                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);            &#125;        &#125;        return dp[prices.length - 1][k * 2];    &#125;&#125;</code></pre><h3 id="309、最佳买卖股票时机含冷冻期"><a href="#309、最佳买卖股票时机含冷冻期" class="headerlink" title="309、最佳买卖股票时机含冷冻期"></a>309、最佳买卖股票时机含冷冻期</h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期 - 力扣（LeetCode）</a>**</p><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><pre><code>输入: prices = [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: prices = [1]输出: 0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题相当于在**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a>**的基础杀昂加了一个冷冻期</p><p>在**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a>**中有两个状态：</p><ul><li>持有股票后得到的最多现金</li><li>不持有股票后得到的最多现金</li></ul></blockquote><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>：表示第 i 天 状态为 j，所得的最多现金为<code>dp[i][j]</code><br>具体可以区分出如下四个状态（<code>j</code>的取值）</p><ul><li>状态一(<code>0</code>)：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</li><li>卖出股票状态<ul><li>状态二(<code>1</code>)：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</li><li>状态三(<code>2</code>)：今天卖出了股票</li></ul></li><li>状态四(<code>3</code>)：今天为冷冻期状态，但冷冻期状态不可持续，只有一天</li></ul></li><li><p>确定递推公式<br>1）达到买入股票的状态（状态一）即：<code>dp[i][0]</code>，有两个具体操作：</p><ul><li><p>操作一：前一天就是持有股票状态（状态一）<code>dp[i][0] = dp[i - 1][0]</code></p></li><li><p>操作二：今天买入股票，有两种情况</p><ul><li>前一天是冷冻期（状态四），<code>dp[i - 1][3] - prices[i]</code></li><li>前一天是保持卖出股票状态（状态二），<code>dp[i - 1][1] - prices[i]</code></li></ul><p>&#x3D;&gt; 操作二取最大值，<code>Math.max(dp[i - 1][3], dp[i - 1][1]) - prices[i]</code></p></li></ul><p>&#x3D;&gt; <code>dp[i][0] = Math.max(dp[i - 1][0],Math.max(dp[i - 1][3], dp[i - 1][1])  - prices[i])</code></p><p>2）达到保持卖出股票状态（状态二）即<code>dp[i][1]</code>，有两个具体操作：</p><ul><li>操作一：前一天就是状态二</li><li>操作二：前一天是冷冻期（状态四）</li></ul><p>&#x3D;&gt; <code>dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3])</code></p><p>3）达到今天就卖出股票状态（状态三），即<code>dp[i][2]</code>，只有一个操作</p><ul><li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li></ul><p>&#x3D;&gt; <code>dp[i][2] = dp[i - 1][0] + prices[i]</code></p><p>4）达到今天为冷冻期状态（状态四），即<code>dp[i][3]</code>，只有一个操作</p><ul><li>操作一：昨天就卖出了股票（状态三）</li></ul><p>&#x3D;&gt; <code>dp[i][3] = dp[i - 1][2]</code></p><pre><code class="java">// 递推代码dp[i][0] = Math.max(dp[i - 1][0],Math.max(dp[i - 1][3], dp[i - 1][1])  - prices[i]);dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);dp[i][2] = dp[i - 1][0] + prices[i];dp[i][3] = dp[i - 1][2];</code></pre></li><li><p>dp数组初始化<br>主要讨论第 0 天的初始化情况</p><ul><li>如果是持有股票状态（状态一），<code>dp[i][0] = -prices[0]</code></li><li>如果是卖出股票状态（状态二），第 0 天没有卖出，<code>dp[0][1] = 0</code></li><li>如果是今天卖出股票状态（状态三），<code>dp[0][2] = 0</code>，最少收益为0，绝对不会是负数</li><li>如果是冷冻期状态，说明前一天是卖出股票状态，前一天收益为0，<code>dp[0][3] = 0</code></li></ul></li><li><p>确定遍历顺序<br>从递推公式其实已经可以看出，⼀定是从前向后遍历，因为<code>dp[i]</code>，依靠<code>dp[i - 1]</code>的数值</p></li><li><p>举例推导dp数组<br>以[1,2,3,0,2]为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219144628.png"></p><blockquote><p>最后结果是取<strong>状态⼆</strong>，<strong>状态三</strong>，和<strong>状态四</strong>的最⼤值</p><p>状态四是 冷冻期，最后⼀天如果是冷冻期也可能是最⼤值</p></blockquote></li></ol><h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int maxProfit(int[] prices) &#123;        int pLen = prices.length;        int[][] dp = new int[pLen][4];        dp[0][0] = -prices[0];        for(int i = 1; i &lt; pLen; i++) &#123;            dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);            dp[i][2] = dp[i - 1][0] + prices[i];            dp[i][3] = dp[i - 1][2];        &#125;        return Math.max(dp[pLen - 1][1], Math.max(dp[pLen - 1][2], dp[pLen - 1][3]));    &#125;&#125;</code></pre><h3 id="714、最佳买卖股票时机含手续费"><a href="#714、最佳买卖股票时机含手续费" class="headerlink" title="714、最佳买卖股票时机含手续费"></a>714、最佳买卖股票时机含手续费</h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）</a>**</p><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1：</strong></p><pre><code>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2输出：8解释：能够达到的最大利润:在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [1,3,7,5,10,3], fee = 3输出：6</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 5 * 10<sup>4</sup></li><li>1 &lt;&#x3D; prices[i] &lt; 5 * 10<sup>4</sup></li><li>0 &lt;&#x3D; fee &lt; 5 * 10<sup>4</sup></li></ul><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题相较于**<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a>**只需要在计算卖出的操作时减去手续费就可以了</p><p>唯一的差别在于递推公式部分，下面着重分析递推公式部分</p></blockquote><p>回顾下dp数组的含义：</p><ul><li><code>dp[i][1]</code>：表示第 i 天不持有股票所得最多现金</li><li><code>dp[i][0]</code>：表示第 i 天持有股票所得的最多现金</li></ul><p>如果第 i 天持有股票即<code>dp[i][0]</code>，那么可以由两个状态推出：</p><ul><li>第 i - 1 天就持有股票，保持现状，所得现金就是昨天持有股票的所得现金，即<code>dp[i - 1][0]</code></li><li>第 i 天买入股票，所得现金就是昨天不持有股票所得的现金减去今天的股票价格，即<code>dp[i - 1][1]-prices[i]</code></li></ul><p>&#x3D;&gt; <code>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</code></p><p>如果第 i 天不持有股票即<code>dp[i][1]</code>的情况，可以由两个状态推出：</p><ul><li>第 i - 1 天就不持有股票，保持现状，所得现金就是昨天不持有股票的所得现金，即<code>dp[i - 1][1]</code></li><li>第 i 天卖出股票，所得现金就是按照今天股票的价格卖出后所得现金，<strong>注意这里需要减去手续费</strong>，即<code>prices[i] + dp[i - 1][0] - fee</code></li></ul><p>&#x3D;&gt; <code>dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);</code></p><h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        int[][] dp = new int[prices.length][2];        // `dp[i][1]`：表示第 i 天不持有股票所得最多现金        // `dp[i][0]`：表示第 i 天持有股票所得的最多现金        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i = 1; i &lt; prices.length; i++) &#123;            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);        &#125;        return dp[prices.length - 1][1];    &#125;&#125;</code></pre><p>滚动数组实现</p><pre><code class="java">class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        int[] dp = new int[2];        // `dp[i][1]`：表示第 i 天不持有股票所得最多现金        // `dp[i][0]`：表示第 i 天持有股票所得的最多现金        dp[0] = -prices[0];        dp[1] = 0;        for(int i = 1; i &lt; prices.length; i++) &#123;            dp[0] = Math.max(dp[0], dp[1] - prices[i]);            dp[1] = Math.max(dp[1], dp[0] + prices[i] - fee);        &#125;        return dp[1];    &#125;&#125;</code></pre><hr><h3 id="300、最长递增子序列"><a href="#300、最长递增子序列" class="headerlink" title="300、最长递增子序列"></a>300、最长递增子序列</h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣（LeetCode）</a>**</p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500</li><li>-10<sup>4</sup> &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>4</sup></li></ul><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>动归五部曲：</p><ol><li><p>dp数组以及下标的含义<br><code>dp[i]</code>表示 i 之前包括 i 的最长上升序列</p></li><li><p>确定递推公式（状态转移方程）<br>位置 i 的最长升序⼦序列等于 j 从 0 到 i - 1 各个位置的最长升序⼦序列 + 1 的最⼤值<br>&#x3D;&gt; <code>dp[i] = Math.max(dp[i], dp[j] + 1)</code></p></li><li><p>dp数组的初始化<br>对于每一个 i ，对应的<code>dp[i]</code>（即最长上升子序列）起始大小至少都是1</p></li><li><p>确定遍历顺序<br><code>dp[i]</code>是由 0 到 i - 1 各个位置的最长升序⼦序列推导⽽来 &#x3D;&gt; i 一定是从前往后遍历<br> j 其实就是从 0 到 i - 1，遍历 i 的循环在外循环，遍历 j 的循环在内循环</p><pre><code class="java">for (int i = 1; i &lt; nums.length; i++) &#123;     for (int j = 0; j &lt; i; j++) &#123;         if (nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);     &#125;     if (dp[i] &gt; result) result = dp[i]; // 取⻓的⼦序列&#125;</code></pre></li><li><p>举例推导dp数组<br>输入[0,1,0,3,2]为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221219234510.png"></p></li></ol><h4 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public int lengthOfLIS(int[] nums) &#123;        if(nums.length == 1) return 1;        int[] dp = new int[nums.length];        Arrays.fill(dp,1);        int res = 0;        for(int i = 1; i &lt; nums.length; i++) &#123;            for(int j = 0; j &lt; i; j++) &#123;                if(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);            &#125;            if(res &lt; dp[i]) res = dp[i];        &#125;        return res;    &#125;&#125;</code></pre><h3 id="674、最长连续递增序列"><a href="#674、最长连续递增序列" class="headerlink" title="674、最长连续递增序列"></a>674、最长连续递增序列</h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列 - 力扣（LeetCode）</a>**</p><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2], 长度为1。</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<sup>4</sup></li><li>-10<sup>9</sup> &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>9</sup></li></ul><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><blockquote><p>本题相较于**<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣（LeetCode）</a><strong>最大区别在于</strong>连续**</p></blockquote><p>动规五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i]</code>：表示以下标 i 为结尾的数组的连续递增子序列的长度为 <code>dp[i]</code></p><blockquote><p>注意这里的定义：一定是以下标 i 为结尾。并没有说以下标 0 为起始位置</p></blockquote></li><li><p>确定递推公式<br>如果<code>nums[i + 1] &gt; nums[i]</code>，那么以 i + 1 为结尾的数组的连续递增的子序列长度一定等于以 i 结尾的数组连续递增子序列的长度＋1<br>&#x3D;&gt; <code>dp[i + 1] = dp[i] + 1</code></p><blockquote><p>因为本题要求连续递增⼦序列，所以就必然要⽐较<code>nums[i + 1]</code>与<code>nums[i]</code>，⽽不⽤去⽐较 <code>nums[j]</code>与<code>nums[i] </code>（ j 是在 0 到 i 之间遍历）。</p><p>既然不⽤ j 了，那么也不⽤两层for循环，本题⼀层for循环就⾏，⽐较<code>nums[i + 1]</code> 和 <code>nums[i]</code>。</p></blockquote></li><li><p>dp数组初始化<br>以下标 i 为结尾的数组的连续递增子序列长度最少也应该是1，即就是<code>nums[i]</code>这一个元素</p><pre><code class="java">int[] dp = new int[nums.length];Arrays.fill(dp, 1);</code></pre></li><li><p>确定遍历顺序<br>从递推公式上可以看出， <code>dp[i + 1]</code>依赖<code>dp[i]</code>，所以⼀定是从前向后遍历。</p><pre><code class="java">for (int i = 0; i &lt; nums.length - 1; i++) &#123;     if (nums[i + 1] &gt; nums[i]) &#123; // 连续记录         dp[i + 1] = dp[i] + 1; // 递推公式     &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>以输入nums &#x3D; [1,3,5,4,7]为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220093659.png"><br><code>dp[i]</code>要取最大值</p></li></ol><h5 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h5><p>遇到nums[i + 1] &gt; nums[i]的情况，count就++，否则 count为1，记录count的最⼤值就可以了</p><h4 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h4><h5 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h5><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int findLengthOfLCIS(int[] nums) &#123;        if(nums.length == 1) return 1;        int[] dp = new int[nums.length];        Arrays.fill(dp, 1);        int res = 0;        for(int i = 0; i &lt; nums.length - 1; i++) &#123;            if(nums[i + 1] &gt; nums[i]) &#123;                dp[i + 1] = dp[i] + 1;            &#125;            if(res &lt; dp[i + 1]) res = dp[i + 1];        &#125;        return res;    &#125;&#125;</code></pre><h5 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h5><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int findLengthOfLCIS(int[] nums) &#123;        if(nums.length == 1) return 1;        int res = 0;        int count = 1;        for(int i = 0; i &lt; nums.length - 1; i++) &#123;            if(nums[i + 1] &gt; nums[i]) &#123;                count++;            &#125; else count = 1;            if(res &lt; count) res = count;        &#125;        return res;    &#125;&#125;</code></pre><h3 id="718、最长重复子数组"><a href="#718、最长重复子数组" class="headerlink" title="718、最长重复子数组"></a>718、最长重复子数组</h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组 - 力扣（LeetCode）</a>**</p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]输出：3解释：长度最长的公共子数组是 [3,2,1] </code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]输出：5</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li></ul><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><blockquote><p>题目中说的子数组，其实就是连续子序列，果断动态规划</p></blockquote><p>动规五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>：表示以下标为 i - 1 为结尾的A，和以下标 j - 1 为结尾B，最长重复子数组的长度为<code>dp[i][j]</code></p><blockquote><p><code>dp[i][j]</code>的定义也就决定着，我们在遍历<code>dp[i][j]</code>的时候 i  和 j 都要<strong>从1开始</strong></p><p>定义<code>dp[i][j]</code>为 以下标  i为结尾的A，和以下标 j 为结尾的B，最长重复⼦数组长度，实现起来稍稍麻烦一些</p></blockquote></li><li><p>确定递推公式<br>根据<code>dp[i][j]</code>的定义，<code>dp[i][j]</code>的状态只能由<code>dp[i - 1][j - 1]</code>推导出来。 即当<code>A[i - 1]</code> 和<code>B[j - 1]</code>相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>; 根据递推公式可以看出，遍历i 和 j 要从1开始</p></li><li><p>dp数组初始化<br>根据<code>dp[i][j]</code>的定义，<code>dp[i][0] </code>和<code>dp[0][j]</code>其实都是没有意义的！ 但<code>dp[i][0] </code>和<code>dp[0][j]</code>要初始值，因为 为了⽅便递归公式<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>; 所以<code>dp[i][0] </code>和<code>dp[0][j]</code>初始化为0。 </p><blockquote><p>举个例⼦A[0]如果和B[0]相同的话，<code>dp[1][1] = dp[0][0] + 1</code>，只有<code>dp[0][0]</code>初始为0，正好符合递推公式逐步累加起来</p></blockquote></li><li><p>确定遍历顺序<br>两层for循环，A数组和B数组顺序不用关心。这里采用外层遍历A数组，内层遍历B数组</p><pre><code class="java">for (int i = 1; i &lt;= A.length; i++) &#123;     for (int j = 1; j &lt;= B.length; j++) &#123;         if (A[i - 1] == B[j - 1]) &#123;             dp[i][j] = dp[i - 1][j - 1] + 1;         &#125;         if (dp[i][j] &gt; result) result = dp[i][j];     &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>以示例一:A &#x3D; [1,2,3,2,1], B&#x3D; [3,2,1,4,7]为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220100426.png"><br>最大长度为3</p></li></ol><h4 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度O(n * m) n 为A长度，m为B长度// 空间复杂度O(n * m)class Solution &#123;    public int findLength(int[] A, int[] B) &#123;        int[][] dp = new int[A.length + 1][B.length + 1];        int res = 0;        for(int i = 1; i &lt;= A.length; i++) &#123;            for(int j = 1; j &lt;= B.length; j++) &#123;                if(A[i - 1] == B[j - 1]) &#123;                    dp[i][j] = dp[i - 1][j - 1] + 1;                &#125;                if(dp[i][j] &gt; res) res = dp[i][j];            &#125;        &#125;        return res;    &#125;&#125;</code></pre><p>滚动数组实现</p><blockquote><p>由状态图可以看出：<code>dp[i][j]</code>都是由<code>dp[i - 1][j - 1]</code>推出。那么压缩为⼀维数组，也就是<code>dp[j]</code>都是由 <code>dp[j - 1]</code>推出，也就是相当于可以把上一层<code>dp[i-1][j]</code>拷贝到下一层<code>dp[i][j]</code>继续使用</p><p>此时在遍历内层循环时，就需要从后往前遍历了，这样可以避免重复覆盖（<strong>跟一维滚动数组实现01背包同理</strong>）</p></blockquote><p>Java代码</p><pre><code class="java">// 时间复杂度O(n * m) n 为A长度，m为B长度// 空间复杂度O(m)class Solution &#123;    public int findLength(int[] A, int[] B) &#123;        int[] dp = new int[B.length + 1];        int res = 0;        for(int i = 1; i &lt;= A.length; i++) &#123;            for(int j = B.length; j &gt; 0; j--) &#123;                if(A[i - 1] == B[j - 1]) &#123;                    dp[j] = dp[j - 1] + 1;                &#125; else dp[j] = 0; // 注意此处不相等时要赋值为0的操作                if(dp[j] &gt; res) res = dp[j];            &#125;        &#125;        return res;    &#125;&#125;</code></pre><h3 id="1143、最长公共子序列"><a href="#1143、最长公共子序列" class="headerlink" title="1143、最长公共子序列"></a>1143、最长公共子序列</h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列 - 力扣（LeetCode）</a>**</p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 </code></pre><p><strong>示例 3：</strong></p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成</li></ul><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题和**<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组 - 力扣（LeetCode）</a><strong>的区别在于本题不要求是连续的了，但要有</strong>相对顺序**</p></blockquote><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为<code>dp[i][j]</code></p><blockquote><p>此处不定义为长度为[0, i]的字符串text1主要为了实现方便</p></blockquote></li><li><p>确定递推公式<br>主要分为两种情况</p><ul><li><code>text1[i - 1]</code> 与 <code>text2[j - 1]</code>相同：找到了一个共同元素 &#x3D;&gt; <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li><li><code>text1[i - 1]</code> 与 <code>text2[j - 1]</code>不同：去tex1t[0, i - 2]和text2[0, j - 1]的最长公共子序列和tex1t[0, i - 1]和text2[0, j - 2] 的最长子序列的较大值&#x3D;&gt; <code>dp[i][j] = Math.max(dp[i][j - 2], dp[i - 1][j])</code></li></ul><pre><code class="java">if (text1.charAt(i - 1) == text2charAt(j - 1)) &#123;     dp[i][j] = dp[i - 1][j - 1] + 1;&#125; else &#123;     dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);&#125;</code></pre></li><li><p>dp数组初始化<br>text1[0, i  - 1]和空串的最长公共子序列自然是0 &#x3D;&gt; <code>dp[i][0] = 0</code><br>同理 <code>dp[0][j] = 0</code><br>其他下标都是随着递推公式逐步覆盖，所以初始化多少都可以，那就统一初始化为0</p></li><li><p>确定遍历顺序<br>从递推公式可以看出，有三个方向可以推出<code>dp[i][j]</code><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220104624.png"><br>&#x3D;&gt; 那么为了在递推的过程中，这三个⽅向都是经过计算的数值，所以要<strong>从前向后，从上到下</strong>来 遍历这个矩阵</p></li><li><p>举例推导dp数组<br>以示例一输入text1 &#x3D; “abcde”, text2 &#x3D; “ace” 为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220104734.png"></p></li></ol><h4 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h4><p>java代码</p><pre><code class="java">class Solution &#123;    public int longestCommonSubsequence(String text1, String text2) &#123;        int text1Len = text1.length();        int text2Len = text2.length();        int[][] dp = new int[text1Len + 1][text2Len + 1];        for(int i = 1; i &lt;= text1Len; i++) &#123;            for(int j = 1; j &lt;= text2Len; j++) &#123;                if(text1.charAt(i - 1) == text2.charAt(j - 1)) &#123;                    dp[i][j] = dp[i - 1][j - 1] + 1;                &#125; else &#123;                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);                &#125;            &#125;        &#125;        return dp[text1Len][text2Len];    &#125;&#125;</code></pre><h3 id="1035、不相交的线"><a href="#1035、不相交的线" class="headerlink" title="1035、不相交的线"></a>1035、不相交的线</h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线 - 力扣（LeetCode）</a>**</p><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交</li></ul><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img"></p><pre><code>输入：nums1 = [1,4,2], nums2 = [1,2,4]输出：2解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]输出：3</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]输出：2</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li><li><code>1 &lt;= nums1[i], nums2[j] &lt;= 2000</code></li></ul><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>绘制一些连接两个数字<code>A[i]</code>和<code>B[j]</code>的直线，只要<code>A[i] == B[j]</code>，且直线不相交！</p><p>直线不能相交，就说明在字符串A中找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，连接相同数字的直线就不会相交</p><p>拿⽰例⼀<code>A = [1,4,2], B = [1,2,4]</code>为例，相交情况如图</p><p><img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img"></p><p>其实也就是说A和B的<strong>最长公共⼦序列</strong>是[1,4]，长度为2。 这个公共⼦序列指的是相对顺序 不变（即数字4在字符串A中数字1的后⾯，那么数字4也应该在字符串B数字1的后⾯）</p><p>&#x3D;&gt; 本题说是求绘制的最大连线数，其实就是<strong>求两个字符串的最长公共子序列的长度</strong></p><p>直接复制**<a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列 - 力扣（LeetCode）</a>**的代码即可</p><h4 id="实现-13"><a href="#实现-13" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">class Solution &#123;    public int maxUncrossedLines(int[] nums1, int[] nums2) &#123;        int nums1Len = nums1.length;        int nums2Len = nums2.length;        int[][] dp = new int[nums1Len + 1][nums2Len + 1];        for(int i = 1; i &lt;= nums1Len; i++) &#123;            for(int j = 1; j &lt;= nums2Len; j++) &#123;                if(nums1[i - 1] == nums2[j - 1]) &#123;                    dp[i][j] = dp[i - 1][j - 1] + 1;                &#125; else &#123;                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);                &#125;            &#125;        &#125;        return dp[nums1Len][nums2Len];    &#125;&#125;</code></pre><h3 id="53、最大子序和"><a href="#53、最大子序和" class="headerlink" title="53、最大子序和"></a>53、最大子序和</h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和 - 力扣（LeetCode）</a>**</p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1]输出：1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [5,4,-1,7,8]输出：23</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<sup>5</sup></li><li>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>4</sup></li></ul><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>动归五部曲：</p><ol><li><p>确定dp数值以及下标的含义<br><code>dp[i]</code>：表示下标 i 之前的最大连续子序列和为<code>dp[i]</code></p></li><li><p>确定递推公式<br><code>dp[i]</code>可以由两个方向推出</p><ul><li><code>dp[i - 1] + nums[i]</code>，即：nums[i]加入当前连续子序列和</li><li><code>nums[i]</code>，即：从头开始计算当前连续子序列和</li></ul><p>取较大的 &#x3D;&gt; <code>dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])</code></p></li><li><p>dp数组初始化<br>从递推公式可以看出来<code>dp[i]</code>是依赖于<code>dp[i - 1]</code>的状态，<code>dp[0]</code>就是递推公式的基础<br>根据<code>dp[i]</code>的定义，很明显<code>dp[0] = nums[0]</code></p></li><li><p>确定遍历顺序<br>递推公式中&#96;&#96;dp[i]<code>依赖于</code>dp[i - 1]&#96;的状态，需要从前往后遍历</p></li><li><p>举例推导dp数组<br>以示例一为例，输入nums &#x3D; [-1,1,-3,4,-1,2,1,-5,4]<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220153334.png"><br>遍历过程中需要保存当前遍历过程中最大的连续子序和</p></li></ol><h4 id="实现-14"><a href="#实现-14" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int maxSubArray(int[] nums) &#123;        if(nums.length == 1) return nums[0];        int[] dp = new int[nums.length];        dp[0] = nums[0];        int res = nums[0];        for(int i = 1; i &lt; nums.length; i++) &#123;            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);            res = Math.max(res, dp[i]);        &#125;        return res;    &#125;&#125;</code></pre><p>迭代实现</p><pre><code class="java">class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int pre = 0;        int res = nums[0];        for(int num : nums)&#123;            pre = Math.max(pre + num,num);            res = Math.max(pre,res);        &#125;        return res;    &#125;&#125;</code></pre><hr><h3 id="392、判断子序列"><a href="#392、判断子序列" class="headerlink" title="392、判断子序列"></a>392、判断子序列</h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列 - 力扣（LeetCode）</a>**</p><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 100</code></li><li><code>0 &lt;= t.length &lt;= 10^4</code></li><li>两个字符串都只由小写字符组成</li></ul><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><blockquote><p>（这道题可以⽤双指针的思路来实现，时间复杂度就是O(n)） </p><p>这道题应该算是编辑距离的⼊门题⽬，因为从题意中可以发现，只需要计算删除的情况，不⽤考虑增加和替换的情况</p></blockquote><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>：表示以下标 i - 1 为结尾的字符串s，和以下标 j - 1为结尾的字符串t，相同子序列的长度为<code>dp[i][j]</code></p><blockquote><p>注意这⾥是判断s是否为t的⼦序列。即t的长度是⼤于等于s的</p><p>以下标i-1为结尾的字符串来计算，这样在下⾯的递归公式中会容易理解⼀些</p></blockquote></li><li><p>确定递推公式<br>在确定递推公式的时候，首先要考虑如下两种操作：</p><ul><li><code>if(s[i - 1] == t[j - 1])</code> &#x3D;&gt;  t 中找到了一个字符在 s 中也出现了 &#x3D;&gt; <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>，因为找到了一个相同的字符，相同子序列长度自然要在<code>dp[i - 1][j - 1]</code>的基础上加1</li><li><code>if(s[i - 1] != t[j - 1])</code> &#x3D;&gt; 相当于 t 要删除元素，继续匹配，t如果把当前元素 t[j - 1] 删除，那么<code>dp[i][j]</code>的数值就是看<code>s[i - 1]</code>与<code>t[j - 2]</code>的比较结果了 &#x3D;&gt;  <code>dp[i][j] = dp[i][j - 1]</code></li></ul></li><li><p>dp数组初始化<br>从递推公式可以看出<code>dp[i][j]</code>都是依赖于<code>dp[i - 1][j - 1] </code>和 <code>dp[i][j - 1]</code>，所以<code>dp[0][0]</code>和<code>dp[i][0] </code>是⼀定要初始化的</p><blockquote><p>在定义<code>dp[i][j]</code>含义的时候为什么要表⽰以下标i-1为结尾的字符串 s，和以下标j-1为结尾的字符串t，相同⼦序列的长度为<code>dp[i][j]</code></p><p>因为这样的定义在dp二维矩阵中可以留出初始化的空间：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220155303.png"><br>如果要是定义的<code>dp[i][j]</code>是以下标i为结尾的字符串s和以下标j为结尾的字符串t，初始化就⽐较⿇烦了</p></blockquote><p>这⾥<code>dp[i][0]</code>和<code>dp[0][j]</code>是没有含义的，仅仅是为了给递推公式做前期铺垫，所以初始化为0</p></li><li><p>确定遍历顺序<br>同理从从递推公式可以看出dp[i][j]都是依赖<code>于dp[i - 1][j - 1] </code>和 <code>dp[i][j - 1]</code>，那么遍历顺序也 应该是<strong>从上到下，从左到右</strong><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220155442.png"></p></li><li><p>举例推导dp数组<br>以示例一为例，输入：s &#x3D; “abc”，t&#x3D;”ahbgdc”<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220155543.png"><br><code>dp[i][j]</code>表⽰以下标i-1为结尾的字符串s和以下标j-1为结尾的字符串t 相同⼦序列的长度，所 以如果<code>dp[s.length()][t.length()] </code>与 字符串s的长度相同说明：s与t的最长相同⼦序列就是s，那么 s 就是 t 的⼦序列<br>图中<code>dp[s.length()][t.length()] == 3; s.length() =3</code> &#x3D;&gt; s是t的子序列，返回true</p></li></ol><h4 id="实现-15"><a href="#实现-15" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n * m)/空间复杂度：O(n * m)class Solution &#123;    public boolean isSubsequence(String s, String t) &#123;        int sLen = s.length();        int tLen = t.length();        int[][] dp = new int[sLen + 1][tLen + 1];        for(int i = 1; i &lt;= sLen; i++) &#123;            for(int j = 1; j &lt;= tLen; j++) &#123;                if(s.charAt(i - 1) == t.charAt(j - 1)) &#123;                    dp[i][j] = dp[i - 1][j - 1] + 1;                &#125; else &#123;                    dp[i][j] = dp[i][j - 1];                &#125;            &#125;        &#125;        return dp[sLen][tLen] == sLen;    &#125;&#125;</code></pre><h3 id="115、不同的子序列"><a href="#115、不同的子序列" class="headerlink" title="115、不同的子序列"></a>115、不同的子序列</h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列 - 力扣（LeetCode）</a>**</p><p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p><p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220184641.png"></p><p><strong>示例 2：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220184659.png"></p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><blockquote><p>1）本题如果不是子序列，而是求连续序列的，可以考虑KMP算法</p><p>2）本题相较于**<a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离 - 力扣（LeetCode）</a>**简单不少，因为本题相当于只涉及删除操作，不用考虑替换、增加之类的</p><p>3）本题相较于**<a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列 - 力扣（LeetCode）</a>**，本题无法使用双指针AC</p></blockquote><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>：表示以 i - 1 结尾的s子序列中出现以 j - 1 为结尾的 t 的个数为<code>dp[i][j]</code></p></li><li><p>确定递推公式</p><blockquote><p>这一类问题，基本是要分析两种情况</p><ul><li><code>s[t - 1] == t[j - 1]</code></li><li><code>s[t - 1] != t[j - 1]</code></li></ul></blockquote><p> 1）当<code>s[t - 1] == t[j - 1]</code>时，<code>dp[i][j]</code>可以由两部分组成</p><ul><li>一部分使用<code>s[i - 1]</code>来匹配，此时个数为<code>dp[i - 1][j - 1]</code></li><li>一部分不使用<code>s[i - 1]</code>来匹配，此时个数为<code>dp[i - 1][j]</code></li></ul><blockquote><p>此处为什么还要考虑不使用<code>s[i - 1]</code>来匹配，按理说字符都想通了，指定要匹配</p><p>举个例子： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不⽤s[3]来匹配，即 ⽤s[0]s[1]s[2]组成的bag。 当然也可以⽤s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p></blockquote><p>&#x3D;&gt; <code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code></p><p>2）当<code>s[t - 1] != t[j - 1]</code>时，<code>dp[i][j]</code>只由一部份组成，不适用<code>s[i - 1]</code>匹配，即<code>dp[i - 1][j]</code></p><p>&#x3D;&gt; <code>dp[i][j] = dp[i - 1][j]</code></p></li><li><p>dp数组初始化<br>从递推公式： <code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>和<code>dp[i][j] = dp[i - 1][j]</code>可以看出<code>dp[i][0]</code>和<code>dp[0][j]</code>是一定要初始化的</p><blockquote><p>每当初始化时，都需要回顾下<code>dp[i][j]</code>的定义</p><ul><li><code>dp[i][0]</code>表示以 i - 1 为结尾的 s 子序列可以随便删除元素后出现空字符串的个数 &#x3D;&gt; <code>dp[i][0] = 1</code></li><li><code>dp[0][j]</code>表示空字符串s可以随便删除元素后出现以 j - 1为结尾的字符串 t 的个数 &#x3D;&gt; <code>dp[0][j] = 0</code></li></ul><p>最后看一个特殊位置，<code>dp[0][0]</code></p><ul><li><code>dp[0][0] = 1</code>，因为空字符串 s 可以删除0个元素后出现空字符串t</li></ul></blockquote><pre><code class="java">// 初始化代码int[][] dp = new int[s.length() + 1][t.length() + 1];for (int i = 0; i &lt;= s.length(); i++) dp[i][0] = 1;// 这行代码可以不写，因为dp数组创建的时候就默认赋值全0了，这里只是为了凸显初始化的逻辑，下面代码实现的时候不会再出现for (int j = 1; j &lt;= t.length(); j++) dp[0][j] = 0; </code></pre></li><li><p>确定遍历顺序<br>从递推公式<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>; 和 <code>dp[i][j] = dp[i - 1][j]</code>; 中可以看出<code>dp[i][j]</code>都是根据左上⽅和正上⽅推出来的<br>&#x3D;&gt; 遍历顺序：从上到下，从左到右</p><pre><code class="java">for(int i = 1; i &lt;= sLen; i++) &#123;    for(int j = 1; j &lt;= tLen; j++) &#123;        if(s.charAt(i - 1) == t.charAt(j - 1)) &#123;            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];        &#125; else &#123;            dp[i][j] = dp[i - 1][j];        &#125;    &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>以 s: “baegg”，t: “bag”为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221075459.png"></p></li></ol><h4 id="实现-16"><a href="#实现-16" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">class Solution &#123;    public int numDistinct(String s, String t) &#123;        int sLen = s.length();        int tLen = t.length();        int[][] dp = new int[sLen + 1][tLen + 1];        for(int i = 0; i &lt;= sLen; i++) &#123;            dp[i][0] = 1;        &#125;        for(int i = 1; i &lt;= sLen; i++) &#123;            for(int j = 1; j &lt;= tLen; j++) &#123;                if(s.charAt(i - 1) == t.charAt(j - 1)) &#123;                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];                &#125; else &#123;                    dp[i][j] = dp[i - 1][j];                &#125;            &#125;        &#125;        return dp[sLen][tLen];    &#125;&#125;</code></pre><h3 id="583、两个字符串的删除操作"><a href="#583、两个字符串的删除操作" class="headerlink" title="583、两个字符串的删除操作"></a>583、两个字符串的删除操作</h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作 - 力扣（LeetCode）</a>**</p><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1：</strong></p><pre><code>输入: word1 = &quot;sea&quot;, word2 = &quot;eat&quot;输出: 2解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot;</code></pre><p><strong>示例  2:</strong></p><pre><code>输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;输出：4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 只包含小写英文字母</li></ul><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题和**<a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列 - 力扣（LeetCode）</a>**相比，其实就是两个字符串都可以删除了，情况复杂点，但是整体思路不变</p></blockquote><p>动规五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>：以 i - 1 为结尾的字符串 word1，和以 j - 1为结尾的字符串 word2，想要达到相等，所需要删除元素的最少次数</p></li><li><p>确定递推公式</p><blockquote><p>分析两种情况</p><ul><li><code>word1[t - 1] == word2[j - 1]</code></li><li><code>word1[t - 1] != word2[j - 1]</code></li></ul></blockquote><p>1）当<code>word1[t - 1] == word2[j - 1]</code>时，<code>dp[i][j] = dp[i - 1][j - 1]</code></p><p>2）当<code>word1[t - 1] != word2[j - 1]</code>时，有三种情况</p><ul><li>情况一：删除<code>word1[i - 1]</code>，最少操作次数为<code>dp[i - 1][j] + 1</code></li><li>情况二：删除<code>word2[i - 1]</code>，最少操作次数为<code>dp[i][j - 1] + 1</code></li><li>情况三：同时删除<code>word1[i - 1]</code>和<code>word2[i - 1]</code>，最少操作次数为<code>dp[i - 1][j - 1] + 2</code></li></ul><p>三者取较小值 &#x3D;&gt; <code>dp[i][j] = Math.max(dp[i - 1][j - 1] + 2, Math.max(dp[i][j - 1] + 1, dp[i - 1][j] + 1));</code></p></li><li><p>dp数组初始化<br>从递推公式可以看出，<code>dp[i][0] </code>和<code> dp[0][j]</code>是⼀定要初始化的<br>1）<code>dp[i][0]</code>：word2为空字符串，以 i - 1为结尾的字符串word2要删除 i 个元素才能和word1相同 &#x3D;&gt; <code>dp[i][0] = i</code><br>2）<code>dp[0][j] = j</code></p><pre><code class="java">int[][] dp = new int[word1.length() + 1][word2.length() + 1];for (int i = 0; i &lt;= word1.length(); i++) dp[i][0] = i;for (int j = 0; j &lt;= word2.length(); j++) dp[0][j] = j;</code></pre></li><li><p>确定遍历顺序<br>从递推公式 <code>dp[i][j] = Math.max(dp[i - 1][j - 1] + 2, Math.max(dp[i][j - 1] + 1, dp[i - 1][j] + 1));</code> 和<code>dp[i][j] = dp[i - 1][j - 1]</code>可以看出<code>dp[i][j]</code>都是根据左上⽅、正上⽅、正左⽅推出来的。 所以遍历的时候⼀定是<strong>从上到下，从左到右</strong>，这样保证<code>dp[i][j]</code>可以根据之前计算出来的数值进⾏计算</p></li><li><p>举例推导dp数组<br>以word1:”sea”，word2:”eat”为例</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221100639.png"></p></li></ol><h4 id="实现-17"><a href="#实现-17" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public int minDistance(String word1, String word2) &#123;        int word1Len = word1.length();        int word2Len = word2.length();        int[][] dp = new int[word1Len + 1][word2Len + 1];        for(int i = 0; i &lt;= word1Len; i++) dp[i][0] = i;        for(int j = 0; j &lt;= word2Len; j++) dp[0][j] = j;        for(int i = 1; i &lt;= word1Len; i++) &#123;            for(int j = 1; j &lt;= word2Len; j++) &#123;                if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;                    dp[i][j] = dp[i - 1][j - 1];                &#125; else &#123;                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 2, Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));                &#125;            &#125;        &#125;        return dp[word1Len][word2Len];    &#125;&#125;</code></pre><h3 id="72、编辑距离"><a href="#72、编辑距离" class="headerlink" title="72、编辑距离"></a>72、编辑距离</h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离 - 力扣（LeetCode）</a>**</p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>动规五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>表示以下标 i - 1 为结尾的字符串word1，和以下标为 j - 1 为结尾的字符串word2，最近的编辑距离为<code>dp[i][j]</code></p></li><li><p>确定递推公式</p><blockquote><p>确定递推公式之前，先考虑清楚编辑距离的几种操作：</p><pre><code class="java">if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; // 不操作&#125; else &#123; // 对字符串进行 增删换 的操作&#125;</code></pre></blockquote><p>1）当<code>word1[i - 1] == word2[j - 1]</code>时，此时不需要任何的编辑，<code>dp[i][j] = dp[i - 1][j - 1]</code></p><blockquote><p>回顾<code>dp[i][j]</code>的定义，word1[i - 1] 与 word2[j - 1]相等了，那么就不⽤编辑了，以下标 i - 2为结尾的字符串word1和以下标 j - 2 为结尾的字符串word2的最近编辑距离<code>dp[i - 1][j - 1]</code>就是 <code>dp[i][j]</code>了</p></blockquote><p>2）当<code>word1[i - 1] != word2[j - 1]</code>时，此时需要对字符串进行编辑</p><ul><li>操作一：word1删除一个元素，那么就是以下标为 i  - 2 为结尾的字符串word1 与 以下标为 j - 1 为结尾的字符串word2的最近编辑距离 再 加上一个操作 &#x3D;&gt; <code>dp[i][j] = dp[i - 1][j] + 1</code></li><li>操作二：word2删除一个元素，那么就是以下标为 i  - 1 为结尾的字符串word1 与 以下标为 j - 2 为结尾的字符串word2的最近编辑距离 再 加上一个操作 &#x3D;&gt; <code>dp[i][j] = dp[i][j - 1] + 1</code></li></ul><blockquote><p>简单分析下<strong>添加元素的操作</strong></p><p>word2添加⼀个元素，相当于word1删除⼀个元素，例如 word1 &#x3D; “ad” ，word2 &#x3D; “a”，word1删除元素’d’ 和 word2添加⼀个元素’d’，变成word1&#x3D;”a”, word2&#x3D;”ad”， 最终的操作数是⼀样！ dp数组如下图所⽰意的：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221102757.png"></p><p>&#x3D;&gt; <strong>删除元素操作包含了添加元素操作</strong></p></blockquote><ul><li>操作三：替换元素，字符串word1 替换 字符<code>word1[i - 1]</code>使之与<code>word2[j - 1]</code>相同，此时不用再增加元素，那么以下标 i - 2为结尾的word1 与 j - 2为结尾的word2的最近编辑距离 再加上⼀个替换元素的操作 &#x3D;&gt; <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li></ul><p>&#x3D;&gt; <code>dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1</code></p><pre><code class="java">if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;    // 不操作    dp[i][j] = dp[i - 1][j - 1];&#125; else &#123;    // 对字符串进行 增删换 的操作    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;&#125;</code></pre></li><li><p>dp数组初始化</p><blockquote><p>回顾下<code>dp[i][j]</code>的定义：</p><p><code>dp[i][j]</code>表示以下标 i - 1 为结尾的字符串word1，和以下标为 j - 1 为结尾的字符串word2，最近的编辑距离为<code>dp[i][j]</code></p></blockquote><p>1）<code>dp[i][0]</code>：以下标为 i - 1 为结尾的字符串word1和空字符串word2，最近的编辑距离为<code>dp[i][0]</code>，那么<code>dp[i][0] = i</code>，对word1 里的元素全部做删除操作使之和字符串word2相同</p><p>2）<code>dp[0][j] = j</code></p><pre><code class="java">for (int i = 0; i &lt;= word1.length(); i++) dp[i][0] = i;for (int j = 0; j &lt;= word2.length(); j++) dp[0][j] = j;</code></pre></li><li><p>确定遍历顺序<br>从如下四个递推公式：</p><ul><li><code>dp[i][j] = dp[i - 1][j - 1] </code></li><li><code>dp[i][j] = dp[i - 1][j - 1] + 1 </code></li><li><code>dp[i][j] = dp[i][j - 1] + 1 </code></li><li>&#96;&#96;dp[i][j] &#x3D; dp[i - 1][j] + 1&#96;</li></ul><p>可以看出<code>dp[i][j]</code>是依赖左⽅，上⽅和左上⽅元素的<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221220104624.png"><br>&#x3D;&gt; dp矩阵中一定是<strong>从上到下，从左到右</strong>遍历的</p><pre><code class="java">for(int i = 1; i &lt;= word1Len; i++) &#123;            for(int j = 1; j &lt;= word2Len; j++) &#123;                if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;                    dp[i][j] = dp[i - 1][j - 1];                &#125; else &#123;                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;                &#125;            &#125;        &#125;</code></pre></li><li><p>举例推导dp数组<br>以⽰例1，输⼊：word1 &#x3D; “horse”, word2 &#x3D; “ros”为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221103915.png"></p></li></ol><h4 id="实现-18"><a href="#实现-18" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public int minDistance(String word1, String word2) &#123;        int word1Len = word1.length();        int word2Len = word2.length();        int[][] dp = new int[word1Len + 1][word2Len + 1];        for(int i = 0; i &lt;= word1Len; i++) dp[i][0] = i;        for(int j = 0; j &lt;= word2Len; j++) dp[0][j] = j;        for(int i = 1; i &lt;= word1Len; i++) &#123;            for(int j = 1; j &lt;= word2Len; j++) &#123;                if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;                    dp[i][j] = dp[i - 1][j - 1];                &#125; else &#123;                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;                &#125;            &#125;        &#125;        return dp[word1Len][word2Len];    &#125;&#125;</code></pre><h3 id="647、回文子串"><a href="#647、回文子串" class="headerlink" title="647、回文子串"></a>647、回文子串</h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><p>题目链接：**<a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串 - 力扣（LeetCode）</a>**</p><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><h5 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h5><p>动规五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>：表示区间范围 [i, j ] （注意这里是左闭右闭）的字串是否是回文子串，如果是，<code>dp[i][j] = true</code>，否则为<code>false</code></p></li><li><p>确定递推公式</p><blockquote><p>分析以下两种情况</p><ul><li><code>s[i] != s[j]</code></li><li><code>s[i] == s[j]</code></li></ul></blockquote><p>1）<code>s[i] != s[j]</code> &#x3D;&gt; <code>dp[i][j] = false</code></p><p>2）<code>s[i] == s[j]</code>，此时有以下三种情况</p><ul><li>情况一：<code>i == j</code>，此时为同一个字符，为回文子串</li><li>情况二：i 和 j 相差为1，比如<code>aa</code>，也为回文子串</li><li>情况三：i 和 j 相差大于1的时候，例如<code>cabac</code>，此时<code>s[i] == s[j]</code>，判断区间 [i, j] 是否是回文子串就判断 <code>aba</code>是否是回文子串就可以了，<code>aba</code>所在区间为[i + 1, j - 1]，这个区间是否是回文子串就判断<code>dp[i + 1][j - 1] ?== true</code></li></ul><pre><code class="java">// result 统计回文子串的数量if (s.charAt(i) == s.charAt(j)) &#123;     if (j - i &lt;= 1) &#123; // 情况⼀ 和 情况⼆         result++;         dp[i][j] = true;     &#125; else if (dp[i + 1][j - 1]) &#123; // 情况三         result++;         dp[i][j] = true;     &#125;&#125;</code></pre><blockquote><p>此时没有列出<code>s[i] != s[j]</code>的情况，原因是Java初始化boolean数组时默认值为false</p></blockquote></li><li><p>dp数组初始化<br>一开始不可能全部都匹配上，所以<code>dp[i][j]</code>初始化为false</p></li><li><p>确定遍历顺序<br>从递推公式中可以看出，情况三是根据<code>dp[i + 1][j - 1]</code>是否为true，再对<code>dp[i][j]</code>进⾏赋值 true的<br><code>dp[i + 1][j - 1] </code>在<code> dp[i</code>][j]的左下⾓，如图：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221110044.png"><br>如果这矩阵是从上到下，从左到右遍历，那么会⽤到没有计算过的<code>dp[i + 1][j - 1]</code>，也就是根据不确定是不是回⽂的区间[i+1,j-1]，来判断了[i,j]是不是回⽂，那结果⼀定是不对的。 所以⼀定要<strong>从下到上，从左到右</strong>遍历，这样保证<code>dp[i + 1][j - 1]</code>都是经过计算的</p><blockquote><p>有的代码实现是优先遍历列，然后遍历⾏，其实也是⼀个道理，都是为了保证过程中用到的值是经过计算的，保证结果的<strong>可把握性</strong>和<strong>准确性</strong></p></blockquote><pre><code class="java">for(int i = sLen - 1; i &gt;= 0; i--) &#123; // 注意遍历顺序    for(int j = i; j &lt; sLen; j++) &#123;        if(s.charAt(i) == s.charAt(j)) &#123;             if(j - i &lt;= 1) &#123; // 情况一和情况二                dp[i][j] = true;                res++;            &#125; else if(dp[i + 1][j - 1]) &#123; // 情况三                dp[i][j] = true;                res++;            &#125;        &#125;    &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>以输入”aaa”为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221110335.png"><br>图中有6个true，也就是6个回文子串</p><blockquote><p>注意：因为<code>dp[i][j]</code>的定义，所以 <code>j &gt;= i</code>，那么在填充<code>dp[i][j]</code>的时候就一定是只填充右上半部分</p></blockquote></li></ol><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><blockquote><p>动态规划的空间复杂度偏高</p></blockquote><p>首先去欸的那个回文串，就是<strong>找中心，然后向两边扩散判断是否对称即可</strong></p><p><strong>在遍历中⼼点的时候，要注意中⼼点有两种情况</strong>：</p><ul><li>一个元素可以作为中心点</li><li>两个元素可以作为中心点</li></ul><blockquote><p>因为三个元素可以由一个元素左右添加元素得到，四个元素可以由两个元素左右添加元素得到</p><p>&#x3D;&gt; 在计算的时候，注意一个元素为中心点和两个元素为中心点的情况</p></blockquote><p>其实这两种情况可以放在一起运算，但分别计算思路更清晰</p><h4 id="实现-19"><a href="#实现-19" class="headerlink" title="实现"></a>实现</h4><h5 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h5><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n^2)// 空间复杂度：O(n^2)class Solution &#123;    public int countSubstrings(String s) &#123;        int sLen = s.length();        boolean[][] dp = new boolean[sLen][sLen];        int res = 0;        for(int i = sLen - 1; i &gt;= 0; i--) &#123; // 注意遍历顺序            for(int j = i; j &lt; sLen; j++) &#123;                if(s.charAt(i) == s.charAt(j)) &#123;                     if(j - i &lt;= 1) &#123; // 情况一和情况二                        dp[i][j] = true;                        res++;                    &#125; else if(dp[i + 1][j - 1]) &#123; // 情况三                        dp[i][j] = true;                        res++;                    &#125;                &#125;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><p>以上代码是为了凸显情况一二三，其实是可以简洁一点的</p><pre><code class="java">// 时间复杂度：O(n^2)// 空间复杂度：O(n^2)class Solution &#123;    public int countSubstrings(String s) &#123;        int sLen = s.length();        boolean[][] dp = new boolean[sLen][sLen];        int res = 0;        for(int i = sLen - 1; i &gt;= 0; i--) &#123;            for(int j = i; j &lt; sLen; j++) &#123;                if(s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) &#123;                     dp[i][j] = true;                    res++;                &#125;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><h5 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h5><pre><code class="java">// 时间复杂度：O(n^2)// 空间复杂度：O(1)class Solution &#123;    public int countSubstrings(String s) &#123;        int res = 0;        int sLen = s.length();        for(int i = 0; i &lt; sLen; i++) &#123;            res += extend(s, i, i, sLen); // 一个元素作为中心点            res += extend(s, i, i + 1, sLen); // 两个元素作为中心点        &#125;        return res;    &#125;   private int extend(String s, int toLeft, int toRight, int rangeLen) &#123;       int res = 0;       while(toLeft &gt;= 0 &amp;&amp; toRight &lt; rangeLen &amp;&amp; s.charAt(toLeft) == s.charAt(toRight)) &#123;           toLeft--;           toRight++;           res++;       &#125;       return res;   &#125;&#125;</code></pre><h3 id="516、最长回文子序列"><a href="#516、最长回文子序列" class="headerlink" title="516、最长回文子序列"></a>516、最长回文子序列</h3><h5 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h5><p>题目链接：**<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列 - 力扣（LeetCode）</a>**</p><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题求的是<strong>回文子序列</strong>，而**<a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串 - 力扣（LeetCode）</a><strong>求的是</strong>回文子串**，首先要搞清楚二者的区别</p><ul><li>回文子串是要连续的<ul><li><strong><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串 - 力扣（LeetCode）</a></strong></li><li><strong><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串 - 力扣（LeetCode）</a></strong></li></ul></li><li>回文子序列不一定要连续</li></ul><p>二者思路差不多，但本题要求的回文子序列比回文子串要简单一点，因为情况少了一点</p></blockquote><p>动规五部曲</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>：表示字符串s在区间[i, j ]范围内最长回文子序列的长度为<code>dp[i][j]</code></p></li><li><p>确定递推公式</p><blockquote><p>在判断回文子序列的题目中，关键逻辑就是看<code>s[i] ?== s[j]</code></p></blockquote><p>1）<code>s[i] == s[j]</code> &#x3D;&gt; <code>dp[i][j] = dp[i + 1][j - 1] + 2</code><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221141520.png"></p><p>2）<code>s[i] != s[j]</code>，那么说明<code>s[i] </code>和<code>s[j]</code>的同时加入并不能增加区间[i, j]回文子序列的长度，那么分别加入<code>s[i] </code>、<code>s[j]</code>，看哪一个可以组成较长回文子序列</p><ul><li>加入<code>s[j]</code>的回文子序列长度为<code>dp[i + 1][j]</code></li><li>加入<code>s[i]</code>的回文子序列长度为<code>dp[i][j - 1]</code></li></ul><p>&#x3D;&gt; <code>dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);</code></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221142002.png"></p><pre><code class="java">if (s.charAt(i) == s.charAt(j)) &#123;     dp[i][j] = dp[i + 1][j - 1] + 2;&#125; else &#123;     dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);&#125;</code></pre></li><li><p>dp数组初始化<br>1）首先考虑<code>i == j</code>的情况，从递推公式：<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code>可以看出递推公式是计算不到<code>i == j</code>的情况的 ，手动初始化，此时<code>dp[i][j] = 1</code>，即：一个字符的回文子序列长度为1<br>2）其他情况<code>dp[i][j] == 0</code>即可，这样<code>dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);</code>中<code>dp[i][j]</code>才不会被初始值覆盖</p><pre><code class="java">int[][] dp = new int[s.length()][s.length()];for(int i = 0; i &lt; s.length(); i++) dp[i][i] = 1;</code></pre></li><li><p>确定遍历顺序<br>从递推公式<code>dp[i][j] = dp[i + 1][j - 1] + 2 </code>和 <code>dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]) </code>可以看出， <code>dp[i][j]</code>是依赖于<code>dp[i + 1][j - 1] </code>和<code> dp[i + 1][j]</code>，从矩阵的角度看，也就是<code>dp[i][j]</code>下一行的数据 &#x3D;&gt;  <strong>所以遍历 i 的时候⼀定要从下到上遍历， 这样才能保证，下⼀⾏的数据是经过计算的。</strong></p><p>递推公式：<code>dp[i][j] = dp[i + 1][j - 1] + 2</code>，<code>dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])</code> 分别对应着下 图中的红⾊箭头⽅向<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221142902.png"></p><pre><code class="java">for(int i = sLen - 1; i &gt;= 0; i--) &#123;    for(int j = i + 1; j &lt; sLen; j++) &#123;        if(s.charAt(i) == s.charAt(j)) &#123;            dp[i][j] = dp[i + 1][j - 1] + 2;         &#125; else &#123;            dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);        &#125;    &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>输⼊s:”cbbd” 为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221221143002.png"><br>红色框<code>dp[0][s.length() - 1]</code>为最终结果</p></li></ol><h4 id="实现-20"><a href="#实现-20" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public int longestPalindromeSubseq(String s) &#123;        int sLen = s.length();        int[][] dp = new int[sLen][sLen];        for(int i = 0; i &lt; sLen; i++) dp[i][i] = 1;        for(int i = sLen - 1; i &gt;= 0; i--) &#123;            for(int j = i + 1; j &lt; sLen; j++) &#123;                if(s.charAt(i) == s.charAt(j)) &#123;                    dp[i][j] = dp[i + 1][j - 1] + 2;                 &#125; else &#123;                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);                &#125;            &#125;        &#125;        return dp[0][sLen - 1];    &#125;&#125;</code></pre><h2 id="二、动态规划总结篇"><a href="#二、动态规划总结篇" class="headerlink" title="二、动态规划总结篇"></a>二、动态规划总结篇</h2><p>动规五部曲：</p><ol><li>确定dp数组(dp table)以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>一个理念：<strong>简单题是用来巩固方法论的</strong></p><hr><p>总的内容：</p><ul><li>动规基础</li><li>背包问题</li><li>打家劫舍系列</li><li>股票系列</li><li>子序列系列</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之路--动态规划篇之背包问题</title>
      <link href="/2022/12/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2022/12/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF---%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">算法学习之路 –动态规划篇之背包问题</a><ul><li><a href="#%E4%B8%8001%E8%83%8C%E5%8C%85">一、01背包</a><ul><li><a href="#01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">01背包理论基础</a><ul><li><a href="#01%E8%83%8C%E5%8C%85">01背包</a></li></ul></li><li><a href="#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85">二维dp数组01背包</a><ul><li><a href="#%E7%90%86%E8%A7%A3%E8%BF%87%E7%A8%8B">理解过程：</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li></ul></li><li><a href="#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84">一维dp数组（滚动数组）</a><ul><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li></ul></li><li><a href="#leetcode--01%E8%83%8C%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">LeetCode–01背包面试题目解析</a><ul><li><a href="#416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86">416、分割等和子集</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-1">实现</a></li></ul></li><li><a href="#1049%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8Fii">1049、最后一块石头的重量II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-1">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-2">实现</a></li></ul></li><li><a href="#494%E7%9B%AE%E6%A0%87%E5%92%8C">494、目标和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-2">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-3">实现</a></li></ul></li><li><a href="#474%E4%B8%80%E5%92%8C%E9%9B%B6">474、一和零</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-3">题目</a></li></ul></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a><ul><li><a href="#%E5%AE%9E%E7%8E%B0-4">实现</a></li></ul></li></ul></li></ul></li><li><a href="#%E4%BA%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">二、完全背包</a><ul><li><a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">完全背包理论基础</a><ul><li><a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">完全背包</a></li><li><a href="#%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3">过程理解</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1">代码实现</a></li></ul></li><li><a href="#leetcode-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">LeetCode-完全背包面试题目解析</a><ul><li><a href="#518%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii">518、零钱兑换II</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-4">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-4">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-5">实现</a></li></ul></li><li><a href="#377%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Civ">377、组合总和IV</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-5">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-5">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-6">实现</a></li></ul></li><li><a href="#70%E7%88%AC%E6%A5%BC%E6%A2%AF">70、爬楼梯</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-6">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-6">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-7">实现</a></li></ul></li><li><a href="#322%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">322、零钱兑换</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-7">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-7">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-8">实现</a></li></ul></li><li><a href="#279%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0">279、完全平方数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-8">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-8">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-9">实现</a></li></ul></li><li><a href="#139%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">139、单词拆分</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-9">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-9">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-10">实现</a></li></ul></li></ul></li></ul></li><li><a href="#%E4%B8%89%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85">三、多重背包</a><ul><li><a href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">多重背包理论基础</a><ul><li><a href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85">多重背包</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li></ul></li></ul></li><li><a href="#%E5%9B%9B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87">四、背包问题总结篇</a><ul><li><a href="#%E8%83%8C%E5%8C%85%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F">背包递推公式</a></li><li><a href="#%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F">遍历顺序</a><ul><li><a href="#01%E8%83%8C%E5%8C%85-1">01背包</a></li><li><a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-1">完全背包</a></li></ul></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h1 id="算法学习之路-–动态规划篇之背包问题"><a href="#算法学习之路-–动态规划篇之背包问题" class="headerlink" title="算法学习之路 –动态规划篇之背包问题"></a>算法学习之路 –动态规划篇之背包问题</h1><h2 id="一、01背包"><a href="#一、01背包" class="headerlink" title="一、01背包"></a>一、01背包</h2><h3 id="01背包理论基础"><a href="#01背包理论基础" class="headerlink" title="01背包理论基础"></a>01背包理论基础</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213134144.png"></p><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><pre><code class="markdown">有N件物品和一个最多能背重量W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大</code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213134601.png"></p><p>这是标准的背包问题，以⾄于很多刷题的小伙伴看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。 </p><p>这样其实是没有从底向上去思考，⽽是习惯性想到了背包，那么暴力的解法应该是怎么样的 呢？</p><p><strong>每⼀件物品其实只有两个状态，取或者不取</strong>，所以可以使用<strong>回溯法</strong>搜索出所有的情况，那么时间复杂度就是O(2^n)，这⾥的n表⽰物品数量。</p><p>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</p><hr><p>例子：背包的最大重量为4</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><hr><h3 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h3><h4 id="理解过程："><a href="#理解过程：" class="headerlink" title="理解过程："></a>理解过程：</h4><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的得含义<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213135346.png"><br><code>dp[i][j]</code>表示从下标为<code>[0-i]</code>的物品里任意取，放进容量为<code>j</code>的背包，最大的价值总和</p></li><li><p>确定递推公式<br>根据<code>dp[i][j]</code>的含义，有两个方向可以推出<code>dp[i][j]</code>：</p><ul><li>由<code>dp[i - 1][j]</code>推出，即背包容量为<code>j</code>，里面不放物品<code>i</code>的最大价值，此时<code>dp[i][j] = dp[i - 1][j]</code></li><li>由<code>dp[i - 1][j - weight[i]]</code>推出，<code>dp[i - 1][j - weight[i]]</code>为背包容量为<code>j - weight[i]</code>的时候不放物品<code>i</code>的最大价值，那么<code>dp[i - 1][j - weight[i]] + value[i]（物品 i 的价值）</code>，就是背包放物品<code>i</code>得到的最大价值</li></ul><p>&#x3D;&gt; 递推公式：<code>dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i])</code></p></li><li><p>dp数组初始化<br><strong>关于初始化，⼀定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</strong></p><ul><li><p>首先从<code>dp[i][j]</code>的定义出发，如果背包容量<code>j</code>为0的话，即<code>dp[i][0]</code>，⽆论是选取哪些物品，背包价值总和⼀定为0<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213140354.png"></p></li><li><p>其他情况<br>状态转移方程：<code>dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i])</code>，可以看出 i 是由 i - 1 推导出来，那么 i 为 0 的时候就一定要初始化<br><code>dp[0][j]</code>，即 i 为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值<br>那么很显然当<code>j &lt; weight[0]</code>的时候，<code>dp[0][j] = 0</code>，因为背包容量比编号0的物品重量还小<br>当<code>j &gt;= weight[0]</code>的时候，<code>dp[0]j] = value[0]</code>，因为背包容量足够放编号0的物品</p><pre><code class="java">// 初始化代码for (int j = 0 ; j &lt; weight[0]; j++) &#123;     // 当然这⼀步，如果把dp数组预先初始化为0了，这⼀步就可以省略     dp[0][j] = 0;&#125;// 正序遍历for (int j = weight[0]; j &lt;= bagWeight; j++) &#123;     dp[0][j] = value[0];&#125;</code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213140950.png"><br><code>dp[0][j] </code>和 <code>dp[i][0] </code>都已经初始化了，那么其他下标应该初始化多少呢？<br>其实从递推公式：<code> dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code> ；可以看出<code>dp[i][j] </code>是由左上方数值推导出来的，那么 其他下标初始为什么数值都可以，因为都会被覆盖。<br>初始-1，初始-2，初始100，都可以！<br>但只不过⼀开始就统⼀把dp数组统⼀初始为0，更方便⼀些<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213141208.png"><br>最后初始化代码：</p><pre><code class="java">int[][] dp = new int[weight.length][bagweight + 1]for (int j = weight[0]; j &lt;= bagWeight; j++) &#123;     dp[0][j] = value[0];&#125;</code></pre></li></ul></li><li><p>确定遍历顺序<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213141455.png"><br>从图中可以看出，有两个遍历的维度：物品与背包重量<br>&#x3D;&gt; 先遍历物品或者先遍历背包重量都可以，但是<strong>先遍历物品更好理解</strong></p><ul><li><p>先遍历物品，然后遍历背包重量</p><pre><code class="java">// weight数组的大小就是物品个数for(int i = 1; i &lt; weight.length; i++) &#123; // 遍历物品     for(int j = 0; j &lt;= bagWeight; j++) &#123; // 遍历背包容量         if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; // 这个是为了展现dp数组⾥元素的变化         else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);     &#125;&#125;</code></pre></li><li><p>先遍历背包重量，再遍历物品</p><pre><code class="java">// weight数组的大小就是物品个数for(int j = 0; j &lt;= bagWeight; j++) &#123; // 遍历背包容量     for(int i = 1; i &lt; weight.length; i++) &#123; // 遍历物品         if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j];         else dp[i][j] =Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);     &#125;&#125;</code></pre></li></ul><blockquote><p>二者都可以的原因：</p><p>要理解递推的本质和递推的方向<br><code> dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code> </p><p>从递推公式中可以看出<code>dp[i][j]</code>是靠<code>dp[i - 1][j]</code>和<code>dp[i - 1][j - weight[i]]</code>推导出来的<br><code>dp[i - 1][j]</code>和<code>dp[i - 1][j - weight[i]]</code>都在<code>dp[i][j]</code>的左上角方向（包括正左和正上两个方向）</p><ul><li>先遍历物品再遍历背包重量的过程如图所示<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213142328.png"></li><li>先遍历背包，再遍历物品的过程如图<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213142431.png"></li></ul><p>&#x3D;&gt; 虽然两个for循环遍历的次序不同，但是<code>dp[i][j]</code>所需要的数据就是左上角，不影响<code>dp[i][j]</code>公式的推导，但是先遍历物品再遍历背包这个顺序更好理解</p></blockquote></li><li><p>举例推导dp数组</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213142705.png"></p></li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Java测试代码</p><pre><code class="java">public class TwoWeiBaoProblem &#123;    /**     * 物品重量     */    private static final int[] weight;    /**     * 价值     */    private static final int[] value;    /**     * 背包重量     */    private static final int bagWeight;    static &#123;        weight = new int[]&#123;1,3,4&#125;;        value = new int[]&#123;15,20,30&#125;;        bagWeight = 4;    &#125;    public static int twoWeiBaoProblem() &#123;        int[][] dp = new int[weight.length][bagWeight + 1];        // 初始化        for(int j = bagWeight;j &gt;= weight[0];j--) &#123;            dp[0][j] = dp[0][j - weight[0]] + value[0];        &#125;        // weight数组的大小就是物品个数        // 先遍历物品再遍历背包容量        for(int i = 1;i &lt; weight.length;i++) &#123;            for(int j = 0;j &lt;= bagWeight;j++) &#123;                if(j &lt; weight[i]) dp[i][j] = dp[i - 1][j];                else dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i]);            &#125;        &#125;        System.out.println(Arrays.deepToString(dp));        return dp[weight.length - 1][bagWeight];    &#125;    public static void main(String[] args) &#123;        System.out.println(twoWeiBaoProblem());    &#125;&#125;</code></pre><p>dp数据</p><p>[<br>    [0, 15, 15, 15, 15],<br>    [0, 15, 15, 20, 35],<br>    [0, 15, 15, 20, <strong>35</strong>]<br>]</p><p>上述遍历的过程也可以这么写：</p><pre><code class="java">// 遍历过程for(int i = 1; i &lt; weight.length; i++) &#123; // 遍历物品     for(int j = 0; j &lt;= bagWeight; j++) &#123; // 遍历背包容量         if (j - weight[i] &gt;= 0) &#123;             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);         &#125;     &#125;&#125;</code></pre><p>这么写打印出来的dp数据：</p><p>[<br>    [0, 15, 15, 15, 15],<br>    [0, 0, 0, 20, 35],<br>    [0, 0, 0, 0, <strong>35</strong>]<br>]</p><h3 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h3><h4 id="过程理解"><a href="#过程理解" class="headerlink" title="过程理解"></a>过程理解</h4><p>对于背包问题，其实状态问题都是可以压缩的</p><p>在使用二维数组时，递推公式：<code>dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i]);</code>，<br>可以发现如果把<code>dp[i - 1]</code>那一层拷贝到<code>dp[i]</code>上，递推公式是：<code>dp[i][j] = Math.max(dp[i][j],dp[i][j - weight[i]] + value[i]);</code><br>与其把<code>dp[i - 1]</code>这一层拷贝到<code>dp[i]</code>上，不如只用一个一维数组，只用<code>dp[j]</code>（一维数组，也可以理解成是一个滚动数组）</p><p>&#x3D;&gt; 滚动数组需要满足：上一层可以重复利用，直接拷贝到当前层</p><blockquote><p>回顾：</p><p><code>dp[i][j]</code>中 <code>i</code> &#x3D;&gt; 物品，<code>j</code> &#x3D;&gt; 背包容量</p><p><code>dp[i][j]</code> &#x3D;&gt; 表示从下标为<code>[0 - i]</code>的物品内任意取，放进容量为<code>j</code>的背包，最大的价值总和</p></blockquote><p>动规五部曲：</p><ol><li><p>确定dp数组的定义</p><p>在一维dp数组中，<code>dp[j]</code> &#x3D;&gt; 容量为<code>j</code>的背包，所背的最大物品价值总和</p></li><li><p>一维dp数组的递推公式</p><p><code>dp[j]</code>可以通过<code>dp[j - weight[j]]</code>推导出来，<code>dp[j - weight[j]]</code>表示容量为<code>j - weight[i]</code>的背包所背的最大价值，<code>dp[j - weight[j]] + value[i]</code>表示容量为<code>j - 物品 i 的重量的背包加上物品 i 的价值</code>（也就是容量为 j 的背包，放入物品 i 了之后的价值即<code>dp[j]</code></p><p>此时<code>dp[j]</code>有两个选择，一个是取自己的<code>dp[j]</code>，一个是取<code>dp[j - weight[i]] + value[i]</code>，二者取最大即可</p><p>&#x3D;&gt; 递推公式：<code>dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i])</code></p><p>可以看出，相较于二维dp数组的写法，就是把<code>dp[i][j]</code>中 <code>i</code> 的维度去掉了</p></li><li><p>一维dp数组的初始化</p><p><strong>关于初始化，⼀定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong></p><p><code>dp[j]</code>表示容量为<code>j</code>的背包，所背的最大物品价值总和</p><p>&#x3D;&gt; <code>dp[0] = 0</code>，因为背包容量为0所背的物品的最大价值就是0</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ </p><p>观察递归公式：<code>dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])</code>; </p><p>dp数组在推导的时候⼀定是取价值最大的数，</p><ul><li>如果题⽬给的价值都是正整数那么非0下标都初始化为0就可以了</li><li>如果题⽬给的价值有负数，那么非0下标就要初始化为负无穷</li></ul><p>这样才能让dp数组在递归公式的过程中取的最⼤的价值，而不是被初始值覆盖了。 这里假设物品价值都是⼤于0的，所以dp数组初始化的时候，都初始为0就可以了</p></li><li><p>一维dp数组遍历顺序</p><pre><code class="java">for(int i = 0; i &lt; weight.length; i++) &#123; // 遍历物品     for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量         dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);     &#125;&#125;</code></pre><p><strong>这里遍历顺序与二维dp的写法顺序是不一样的</strong></p><p>二维dp遍历的时候，背包容量是从小到大的，而一维dp数组遍历的时候，背包是从大到小</p><p>原因：</p><p><strong>倒序遍历是为了保证物品 i 只被放入一次</strong></p><blockquote><p>二维数组初始化<code>dp[0][j]</code>时的代码</p><pre><code class="java">// 倒叙遍历for (int j = bagWeight; j &gt;= weight[0]; j--) &#123;dp[0][j] = dp[0][j - weight[0]] + value[0]; // 初始化i为0时候的情况&#125;</code></pre><p><code>dp[0][j]</code>表示容量为j的背包存放物品0时候的最大价值，物品0的价值就是15，因为题目中说了<strong>每个物品只有一个！</strong>所以<code>dp[0][j]</code>如果不是初始值的话，就应该都是物品0的价值，也就是15。</p><p>但如果一旦正序遍历了，那么物品0就会被重复加入多次!</p><pre><code class="java">// 正序遍历for (int j = weight[0]; j &lt;= bagWeight; j++) &#123;dp[0][j] = dp[0][j - weight[0]] + value[0];&#125;</code></pre><p>例如<code>dp[0][1]</code> 是15，到了<code>dp[0][2] = dp[0][2 - 1] + 15;</code> 也就是<code>dp[0][2] = 30</code> 了，那么就是物品0被重复放入了</p><p>&#x3D;&gt; 一定要倒序遍历，保证编号为0的物品只被放入一次</p></blockquote><p>举一个例子：物品0的重量<code>weight[0] = 1</code>，价值<code>value[0] = 15</code></p><p>如果正序遍历<br><code>dp[1] = dp[1 - weight[0]] + value[0] = 15</code> </p><p><code>dp[2] = dp[2 - weight[0]] + value[0] = 30</code><br>此时<code>dp[2] = 30</code>，意味着物品0被放入两次，所以不能正序遍历</p><p>如果倒序遍历 （dp数组都已经初始化为0）<br><code>dp[2] = dp[2 - weight[0]] + value[0] = 15</code><br><code>dp[1] = dp[1 - weight[0]] + value[0] = 15</code> </p><p>所以从后往前遍历，每次取得的状态都不会和之前的状态重合，这样每种物品就只取一次了</p><blockquote><p>为什么二维数组遍历时不需要倒序？</p><p>因为对于⼆维dp，<code>dp[i][j]</code>都是通过上⼀层即<code>dp[i - 1][j]</code>计算⽽来，本层的<code>dp[i][j]</code>并不会被覆盖</p><p>再来看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量再遍历物品呢？ 不可以！<br>因为⼀维dp的写法，背包容量⼀定是要倒序遍历，如果遍历背包容量放在上⼀层，那么每个dp[j]就只会放⼊⼀个物品，即：背包⾥只放⼊了⼀个物品。</p><p>&#x3D;&gt; <strong>代码中DeBug</strong></p></blockquote></li><li><p>举例推导dp数组<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221214084241.png"></p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="java">public class OneWeiBaoProblem &#123;    /**     * 物品重量     */    private static final int[] weight;    /**     * 价值     */    private static final int[] value;    /**     * 背包重量     */    private static final int bagWeight;    static &#123;        weight = new int[]&#123;1,3,4&#125;;        value = new int[]&#123;15,20,30&#125;;        bagWeight = 4;    &#125;    public void oneWeiBaoProblem() &#123;        int[] dp = new int[bagWeight + 1];        // 遍历物品        for (int i = 0; i &lt; weight.length; i++) &#123;            // 遍历背包容量            for(int j = bagWeight;j &gt;= weight[i];j--) &#123;                dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i]);            &#125;            System.out.printf(&quot;物品%d : %s\n&quot;,i, Arrays.toString(dp));        &#125;        System.out.println(dp[bagWeight]);    &#125;    public static void main(String[] args) &#123;        new OneWeiBaoProblem().oneWeiBaoProblem();    &#125;&#125;</code></pre><h3 id="LeetCode–01背包面试题目解析"><a href="#LeetCode–01背包面试题目解析" class="headerlink" title="LeetCode–01背包面试题目解析"></a>LeetCode–01背包面试题目解析</h3><h4 id="416、分割等和子集"><a href="#416、分割等和子集" class="headerlink" title="416、分割等和子集"></a>416、分割等和子集</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>题目链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等</p><p>示例 1：</p><p>输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p><p>示例 2：</p><p>输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>这道题是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等 &#x3D;&gt; 只要找到集合里能够出现 <code>sum / 2</code>的子集总和，就算是可以分割成两个相同元素和子集了</p><blockquote><h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h4><p>背包问题，有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是 weight[i]，得到的价值是value[i] 。每件物品只能用⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤</p><p>背包问题有多种背包⽅式，常见的有：01背包、完全背包、多重背包、分组背包和混合背 包等等。 </p><p>要注意题⽬描述中商品是不是可以重复放⼊。 </p><p>即⼀个商品如果可以重复多次放⼊是完全背包，⽽只能放⼊⼀次是01背包，写法还是不⼀ 样的</p></blockquote><p><strong>明确本题我们要使用的是01背包，因为元素我们只用一次</strong></p><p>回归主题：首先，本题要求集合里能否出现总和为<code>sum / 2</code>的子集</p><p>&#x3D;&gt; <strong>只有确定了如下四点，才能把01背包问题套到本题上来</strong></p><ul><li>背包的体积为<code>sum / 2</code></li><li>背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为<code>sum / 2</code>的子集</li><li>背包中每一个元素都是不可重复放入的</li></ul><p>动规五部曲分析：</p><ol><li><p>确定dp数组以及下标的含义<br>01背包中，<code>dp[i]</code> 表示： 容量为<code>i</code>的背包，所背的物品价值可以最⼤为<code>dp[i]</code> &#x3D;&gt; 套到本题，<code>dp[i]</code>表示背包总容量是<code>i</code>，最⼤可以凑成<code>i</code>的子集总和为<code>dp[i]</code></p></li><li><p>确定递推公式<br>01背包的递推公式：<code>dp[j]  = Math.max(dp[j],dp[j - weight[i]] + value[i])</code>，本题相当于背包里放入数值，那么物品<code>i</code>的重量为<code>nums[i]</code>，其价值也是<code>nums[i]</code> &#x3D;&gt; 递推公式：<code>dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i])</code></p></li><li><p>dp数组初始化<br>在01背包，⼀维dp的初始化：从dp[j]的定义来看，首先dp[0]⼀定是0。如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。 这样才能<strong>让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong><br>本题题目中只包含正整数的非空数组，所以非0下标的元素初始化为0即可</p><pre><code class="java">// 题⽬中说：每个数组中的元素不会超过 100，数组的大小不会超过 200// 总和不会⼤于20000，背包最大只需要其中⼀半，所以10001大小就可以了int[] dp = new int[10001];</code></pre></li><li><p>确定遍历顺序<br>在<strong>一维dp数组（滚动数组）</strong>中已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内存for循环为倒序遍历</p><pre><code class="java">for(int i = 0; i &lt; nums.length; i++) &#123;    for(int j = target; j &gt;= nums[i]; j--) &#123; // 每⼀个元素⼀定是不可重复放⼊，所以从⼤到⼩遍历        dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);    &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br><code>dp[i] &lt;= i</code>（始终成立）<br>若<code>dp[i] == i</code>说明<strong>集合中的子集和正好可以凑成总和i</strong><br>以示例1，输入<code>[1,5,11,5]</code>为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221215142502.png"><br>最后<code>dp[11] == 11</code> &#x3D;&gt; 说明可以将这个数组分割成两个子集，使得两个子集的元素和相等</p></li></ol><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(n ^ 2)// 空间复杂度：O(n)class Solution &#123;    public boolean canPartition(int[] nums) &#123;        int sum = 0; // 记录数组总和        int[] dp = new int[10001];        for(int i = 0; i &lt; nums.length; i++) &#123;            sum += nums[i];        &#125;        // 如果sum不能均分，直接返回false        if(sum % 2 == 1) return false;        int target = sum / 2;        for(int i = 0; i &lt; nums.length; i++) &#123;            for(int j = target; j &gt;= nums[i]; j--) &#123;                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);            &#125;        &#125;        // 集合中的元素正好可以凑成总和target        return dp[target] == target;    &#125;&#125;</code></pre><h4 id="1049、最后一块石头的重量II"><a href="#1049、最后一块石头的重量II" class="headerlink" title="1049、最后一块石头的重量II"></a>1049、最后一块石头的重量II</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>题目链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></p><p>有一堆石头，用整数数组 stones 表示。其中 <code>stones[i] </code>表示第<code>i</code>块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p><ul><li>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</li><li>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x</li></ul><p>最后，<strong>最多只会剩下一块</strong>石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 0。</p><p>示例 1：</p><p>输入：stones &#x3D; [2,7,4,1,8,1]<br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，<br>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，<br>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，<br>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>示例 2：</p><p>输入：stones &#x3D; [31,26,33,21,40]<br>输出：5</p><p>提示：</p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头重量最小，这样就化解成01背包问题</p><p>本题物品的重量为<code>store[i]</code>，物品价值也是<code>store[i]</code></p><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[j]</code>表示容量（这里容量其实就是重量）为<code>j</code>的背包，最多可以背<code>dp[j]</code>这么重的石头</p></li><li><p>确定递推公式<br><code>dp[j] = Math.max(dp[j], dp[j - store[i]] + store[i])</code></p></li><li><p>dp数组初始化<br><code>dp[j]</code>表示容量，那么最大容量就是所有石头的重量和，根据题目提示得知最大重量和为30 * 1000 &#x3D;&gt; 我们只需要把dp数组开到15000的大小就可以了</p><blockquote><p>当然也可以把⽯头遍历⼀遍，计算出⽯头总重量然后除以2，得到dp数组的⼤⼩。</p></blockquote><p>因为重量不会是负数，所以<code>dp[j]</code>初始化为0即可</p><pre><code class="java">int [] dp = new int[15001];</code></pre></li><li><p>确定遍历顺序<br>在<strong>一维dp数组（滚动数组）</strong>中已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内存for循环为倒序遍历</p><pre><code class="java">for (int i = 0; i &lt; stones.length; i++) &#123; // 遍历物品     for (int j = target; j &gt;= stones[i]; j--) &#123; // 遍历背包         dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);     &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>输⼊：[2,4,1,1]，此时target &#x3D; (2 + 4 + 1 + 1)&#x2F;2 &#x3D; 4 ，dp数组状态图如下：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221215150927.png"><br>最后，<code>dp[target]</code>里是容量为target的背包所能背的最大重量 &#x3D;&gt; 分成的两堆石头，一堆石头的总重量为<code>dp[target]</code>，另一堆石头就是<code>sum - dp[target]</code></p><blockquote><p>在计算<code>target</code>的时候，<code>target = sum / 2</code>是向下取整，所以<code>sum - dp[target] &gt;= dp[target]</code></p></blockquote><p>&#x3D;&gt; 相撞之后剩下的最小的石头重量就是<code>(sum - dp[target]) - dp[target] = sum - 2 * dp[target]</code></p></li></ol><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>Java代码</p><pre><code class="java">// 时间复杂度：O(m * n) , m是⽯头总重量（准确的说是总重量的⼀半），n为⽯头块数// 空间复杂度：O(m)class Solution &#123;    public int lastStoneWeightII(int[] stones) &#123;        int sum = 0;        for(int i = 0; i &lt; stones.length; i++) sum += stones[i];        int target = sum / 2;        int[] dp = new int[target + 1];        for(int i = 0; i &lt; stones.length; i++) &#123;            for(int j = target; j &gt;= stones[i]; j--) &#123;                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);            &#125;        &#125;        return sum - 2 * dp[target];    &#125;&#125;</code></pre><h4 id="494、目标和"><a href="#494、目标和" class="headerlink" title="494、目标和"></a>494、目标和</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>题目链接：<a href="https://leetcode-cn.com/problems/target-sum/">https://leetcode-cn.com/problems/target-sum/</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code></p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> </p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目</p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 &#x3D; 3<br>+1 - 1 + 1 + 1 + 1 &#x3D; 3<br>+1 + 1 - 1 + 1 + 1 &#x3D; 3<br>+1 + 1 + 1 - 1 + 1 &#x3D; 3<br>+1 + 1 + 1 + 1 - 1 &#x3D; 3</p><p>示例 2：</p><p>输入：nums &#x3D; [1], target &#x3D; 1<br>输出：1</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li><li><code>-1000 &lt;= target &lt;= 1000</code></li></ul><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>本题要使表达式结果为<code>target</code>，既然为<code>target</code>，那么一定有<code>left组合 - right组合 = target</code>，而<code>left + right = sum</code>，sum是固定的 &#x3D;&gt; <code>left - (sum - left) = target</code> &#x3D;&gt; <code>left = (target + sum) / 2</code>，<code>target</code>和<code>sum</code>都是固定的，就可以求出<code>left</code> &#x3D;&gt; 此时问题就是在集合<code>nums</code>中找出和为<code>left</code>的组合</p><p>如何转化为01背包问题？</p><p>假设做加法运算的元素总和为<code>x</code>，那么做减法运算的元素总和就是<code>sum - x</code> &#x3D;&gt; 我们要求的是<code>x - (sum - x) = target</code> &#x3D;&gt; <code>x = (target + sum) / 2</code><br>此时问题转化为<strong>装满容量为x的背包，有几种方法</strong></p><blockquote><p><code> (target + sum) / 2</code>计算过程向下取整有影响</p><pre><code class="java">if((target +sum) % 2 == 1) return 0; // 此时没有方案（也就是 target + sum为奇数时）</code></pre><p><strong>看到这种表达式，本能的反应应该是两个int相加数值可能溢出的问题，当然本题并没有溢出</strong></p></blockquote><p>再回归到01背包问题，为什么是01背包呢？<br> 因为每个物品（题⽬中的1）只用⼀次！<br>这次和之前遇到的背包问题不⼀样，之前都是求容量为<code>j</code>的背包，最多能装多少。<br>本题则是装满有几种⽅法，其实这就是⼀个组合问题了。</p><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[j]</code>表示填满<code>j</code>这么体积的包有<code>dp[j]</code>种方法</p><blockquote><p>其实也可以使⽤⼆维dp数组来求解本题，<code>dp[i][j]</code>：使⽤ 下标为<code>[0, i]</code>的<code>nums[i]</code>能够凑满<code>j（包括j）</code>这么⼤容量的包，有<code>dp[i][j]</code>种⽅法。</p></blockquote></li><li><p>确定递推公式<br>有哪些路径可以推导出<code>dp[j]</code>？</p><p>不考虑<code>nums[i]</code>的情况下，填满容量为<code>j - nums[i]</code>的背包，有<code>dp[j - nums[i]]</code>种方法，那么只要得到<code>nums[i]</code>，凑成<code>dp[j]</code>就有<code>dp[j - nums[j]]</code>种方法</p><blockquote><p>举⼀个例⼦,<code>nums[i] = 2</code>，<code>dp[3]</code>，填满背包容量为3的话，有dp[3]种⽅法。 那么只需要得得到⼀个2（nums[i]），有<code>dp[3]</code>⽅法可以凑齐容量为3的背包，相应的就有<code>dp[3]</code>⽅法可以凑齐容量为5的背包</p></blockquote><p>那么需要把这些方法累加起来就可以了，<code>dp[j] += dp[j - nums[i]]</code><br>&#x3D;&gt; 递推公式：<code>dp[j] += dp[j - nums[i]]</code></p><blockquote><p>求组合类问题的公式都是类似这种</p><pre><code class="java">dp[j] += dp[j - nums[i]];</code></pre></blockquote></li><li><p>dp数组初始化<br>从递推公式可以看出，在初始化的时候<code>dp[0]</code>一定要初始化为1，因为<code>dp[0]</code>是在公式中一切递推公式的起源，如果<code>dp[0] = 0</code>，递推结果都是0<br><code>dp[0] = 1</code>，理论上解释：装满容量为0的背包，有1种方法，就是装0件物品<br>其他下标对应的数值应该初始化为0，从递归公式也可以看出，<code>dp[j]</code>要保证是0的初始值，才能正确的由<code>dp[j - nums[i]]</code>推导出来</p></li><li><p>确定遍历顺序<br>在<strong>一维dp数组（滚动数组）</strong>中已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内存for循环为倒序遍历</p><pre><code class="java">for(int i = 0; i &lt; nums.length; i++) &#123;    for(int j = bagSize; j &gt;= nums[i]; j--) &#123;        dp[j] += dp[j - nums[i]];    &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>输入：nums:[1,1,1,1,1],target:3<br><code>bagSize = (sum + target) / 2 = 4</code><br>dp数组变化状态：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221215155237.png"></p></li></ol><h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><p>Java代码</p><pre><code class="java">// 时间复杂度O(n * m)，n为正数个数，m为背包容量// 空间复杂度：O(m) m为背包容量class Solution &#123;    public int findTargetSumWays(int[] nums, int target) &#123;        int sum = 0;        for(int i = 0; i &lt; nums.length; i++) sum += nums[i];        // 以下三种情况没有方案        if((target &gt; sum) || (sum + target &lt; 0)  || ((sum + target) % 2 == 1)) return 0;        int bagSize = (sum + target) / 2;        int[] dp = new int[bagSize + 1];        // 初始化dp[0] = 1        dp[0] = 1;        for(int i = 0; i &lt; nums.length; i++) &#123;            for(int j = bagSize;j &gt;= nums[i]; j--) &#123;                dp[j] += dp[j - nums[i]];               &#125;        &#125;        return dp[bagSize];    &#125;&#125;</code></pre><h4 id="474、一和零"><a href="#474、一和零" class="headerlink" title="474、一和零"></a>474、一和零</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p>题⽬链接：<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">https://leetcode-cn.com/problems/ones-and-zeroes/</a></p><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><p>示例 1：</p><p>输入：strs &#x3D; [“10”, “0001”, “111001”, “1”, “0”], m &#x3D; 5, n &#x3D; 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4<br>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><p>示例 2：</p><p>输入：strs &#x3D; [“10”, “0”, “1”], m &#x3D; 1, n &#x3D; 1<br>输出：2<br>解释：最大的子集是 {“0”, “1”} ，所以答案是 2 </p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 600</code></li><li><code>1 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成</li><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><blockquote><p>本题会被认为是多重背包，但其实不是</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213134144.png"><br>多重背包是每个物品，数量不同的情况</p><p>本题中strs数组里的元素就是物品，每个物品都是一个，而m和n相当于是一个背包，两个维度的背包</p><p>理解成多重背包主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包，但本题是01背包问题，只不过这个背包有两个维度，一个是m，一个是n，而不同长度的字符串就是不同大小的待装物品</p></blockquote><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i][j]</code>表示最多有 <code>i</code> 个 <code>0</code>和 <code>j</code>个<code>1</code>的<code>strs</code>的最大子集的大小为<code>dp[i][j]</code></p></li><li><p>确定递推公式<br><code>dp[i][j]</code>可以由前一个<code>strs</code>里的字符串推导出来，<code>strs</code>里的字符串有<code>zeroNum</code>个<code>0</code>，<code>oneNum</code>个<code>1</code>，<code>dp[i][j]  =  dp[i - zeroNum][j - oneNum] + 1</code><br>然后我们在遍历的时候取<code>dp[i][j]</code>的最大值<br>&#x3D;&gt; 递推公式：<code>dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)</code></p><blockquote><p>此时可以回想⼀下01背包的递推公式：<code>dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</code> </p><p>对⽐⼀下就会发现，字符串的<code>zeroNum</code>和<code>oneNum</code>相当于物品的重量（<code>weight[i]</code>），字符串本⾝的个数相当于物品的价值（<code>value[i]</code>）。</p><p>这就是⼀个典型的01背包！ 只不过物品的重量有了两个维度⽽已</p></blockquote></li><li><p>dp数组的初始化<br>因为物品价值不会是负数，所以dp数组初始化为0，保证递推的时候<code>dp[i][j]</code>不会被初始值覆盖</p><pre><code class="java">int[][] dp = new int[m + 1][n + 1];</code></pre></li><li><p>确定遍历顺序<br>在<strong>一维dp数组（滚动数组）</strong>中已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内存for循环为倒序遍历<br>本题也是如此，物品就是strs里面的字符串，背包容量就是题目给出的m和n</p><pre><code class="java">for (String str : strs) &#123; // 遍历物品     int oneNum = 0, zeroNum = 0;     for(int k = 0; k &lt; str.length(); k++) &#123;         char c = str.charAt(k);         if(&#39;0&#39; == c) zeroNum++;         else oneNum++;     &#125;     for (int i = m; i &gt;= zeroNum; i--) &#123; // 遍历背包容量且从后向前遍历！         for (int j = n; j &gt;= oneNum; j--) &#123;             dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);         &#125;     &#125;&#125;</code></pre><blockquote><p>遍历背包容量的两个循环顺序无影响，都是物品重量的一个维度，先遍历哪个都可以</p></blockquote></li><li><p>举例推导dp数组<br>以输⼊：[“10”,”0001”,”111001”,”1”,”0”]，m &#x3D; 3，n &#x3D; 3为例<br>最后dp数组的状态<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221215162147.png"></p></li></ol><h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><p>Java代码</p><pre><code class="java">class Solution &#123;    public int findMaxForm(String[] strs, int m, int n) &#123;        int[][] dp = new int[m + 1][n + 1];        for(String str: strs) &#123;            int zeroNum = 0;            int oneNum = 0;            for(int k = 0; k &lt; str.length(); k++) &#123;                char c = str.charAt(k);                if(&#39;0&#39; == c) zeroNum++;                else oneNum++;            &#125;            for(int i = m; i &gt;= zeroNum; i--) &#123;                for(int j = n; j &gt;= oneNum; j--) &#123;                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);                &#125;            &#125;        &#125;        return dp[m][n];    &#125;&#125;</code></pre><h2 id="二、完全背包"><a href="#二、完全背包" class="headerlink" title="二、完全背包"></a>二、完全背包</h2><h3 id="完全背包理论基础"><a href="#完全背包理论基础" class="headerlink" title="完全背包理论基础"></a>完全背包理论基础</h3><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>有N件物品和一个最多能背重量W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每件物品有无限件</strong></p><hr><p>例子：背包的最大重量为4</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>每件商品都有无限个！</p><p>问背包能背的物品最大价值是多少？</p><hr><h4 id="过程理解-1"><a href="#过程理解-1" class="headerlink" title="过程理解"></a>过程理解</h4><blockquote><p>01背包和完全背包唯⼀不同就是体现在遍历顺序上，下文直接针对遍历顺序进行分析</p></blockquote><p>回顾下01背包遍历的核心代码</p><pre><code class="java">for(int i = 0; i &lt; weight.length; i++) &#123; // 遍历物品     for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量         dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);     &#125;&#125;</code></pre><p>01背包内嵌的循环是从大到小遍历的，是为了保证每个物品仅被添加一次</p><p>而完全背包的物品是可以添加多次的，所以要从小到大的遍历</p><pre><code class="java">for(int i = 0; i &lt; weight.length; i++) &#123; // 遍历物品     for(int j = weight[i]; j &lt; bagWeight; j--) &#123; // 遍历背包容量         dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);     &#125;&#125;</code></pre><p>dp状态图如下：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216090456.png"></p><blockquote><p>问题：<strong>为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong></p><p>在上面01背包中，二维dp数组的两个for循环遍历的先后顺序是可以颠倒的，一维dp数组的两个for循环遍历先后顺序一定是先遍历物品，在遍历背包容量</p><p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓</strong>，因为<code>dp[j] </code>是根据 下标<code>j</code>之前所对应的<code>dp[j]</code>计算出来的。 只要保证下标<code>j</code>之前的<code>dp[j]</code>都是经过计算的就可以了</p><p>遍历物品在外层循环，遍历背包容量在内层循环，状态如图：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216091053.png"></p><p>遍历背包容量在外层循环，遍历物品在内层循环，状态如图：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216091513.png"></p><p>先遍历背包容量再遍历物品，代码如下：</p><pre><code class="java">// 先遍历背包，再遍历物品for(int j = 0; j &lt;= bagWeight; j++) &#123; // 遍历背包容量  for(int i = 0; i &lt; weight.length; i++) &#123; // 遍历物品      if (j - weight[i] &gt;= 0) dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);  &#125;&#125;</code></pre></blockquote><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>Java代码：</p><pre><code class="java">public class OneWeiBagProbem &#123;    /**     * 物品重量     */    private static final int[] weight;    /**     * 价值     */    private static final int[] value;    /**     * 背包重量     */    private static final int bagWeight;    static &#123;        weight = new int[]&#123;1,3,4&#125;;        value = new int[]&#123;15,20,30&#125;;        bagWeight = 4;    &#125;    private void oneWeiCompleteBagProblem() &#123;        int[] dp = new int[bagWeight + 1];        // 先遍历物品，再遍历背包容量//        for(int i = 0; i &lt; weight.length; i++) &#123;//            for(int j = weight[i]; j &lt;= bagWeight; j++) &#123;//                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);//            &#125;//        &#125;                // 先遍历背包容量，再遍历物品        for (int j = 0; j &lt;= bagWeight; j++) &#123;            for(int i = 0; i &lt; weight.length; i++) &#123;                if(j - weight[i] &gt;= 0) &#123;                    dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);                &#125;            &#125;        &#125;        System.out.println(Arrays.toString(dp));        System.out.println(dp[bagWeight]);    &#125;    @Test    public void doTest() &#123;        oneWeiCompleteBagProblem();    &#125;&#125;/**打印输出结果：    [0, 15, 30, 45, 60]    60*/</code></pre><h3 id="LeetCode-完全背包面试题目解析"><a href="#LeetCode-完全背包面试题目解析" class="headerlink" title="LeetCode-完全背包面试题目解析"></a>LeetCode-完全背包面试题目解析</h3><h4 id="518、零钱兑换II"><a href="#518、零钱兑换II" class="headerlink" title="518、零钱兑换II"></a>518、零钱兑换II</h4><h5 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h5><p>题目链接：<a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p>示例 1：</p><p>输入：amount &#x3D; 5, coins &#x3D; [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5&#x3D;5<br>5&#x3D;2+2+1<br>5&#x3D;2+1+1+1<br>5&#x3D;1+1+1+1+1</p><p>示例 2：</p><p>输入：amount &#x3D; 3, coins &#x3D; [2]<br>输出：0<br>解释：只用面额 2 的硬币不能凑成总金额 3 。</p><p>示例 3：</p><p>输入：amount &#x3D; 10, coins &#x3D; [10]<br>输出：1</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><blockquote><p>这是一套典型的背包问题，一看到钱币数目不限，就知道这是一个完全背包</p><p>但是本题和纯完全背包不一样，纯完全背包是能否凑成总金额，而本题是要求凑成总金额的个数</p></blockquote><p>注意题目中描述的是凑成总金额的硬币<strong>组合数</strong>，组合数不强调元素之间的顺序，而排列强调这一点</p><p>动归五部曲：</p><ol><li><p>确定dp数组和下标的含义<br><code>dp[j]</code>：表示凑成总金额为<code>j</code>的货币组合数是<code>dp[j]</code></p></li><li><p>确定递推公式<br><code>dp[j]</code>（考虑<code>coins[i]</code>的组合总和）就是所有的<code>dp[j - coins[i]]</code>（不考虑<code>coins[i]</code>）相加<br>&#x3D;&gt;递推公式： <code>dp[j] += dp[j - coins[i]]</code>（这个式子上文<strong>494、目标和</strong>一题中解释过）</p></li><li><p>dp数组初始化<br>首先<code>dp[0]</code>一定要是1，这是递推的基础，从<code>dp[i]</code>的含义上来讲就是凑成总金额为0的货币组合数为1<br>下标非0的<code>dp[j]</code>初始化为0，这样累计加<code>dp[j - coins[i]]</code>的时候才不会影响真正的<code>dp[j]</code></p></li><li><p>确定遍历顺序</p><blockquote><p>本题中遍历顺序有先遍历物品（钱币），再遍历背包容量（金钱总额）还是先遍历背包容量（金钱总额），再遍历物品（钱币）呢？</p><p>上文讲的理论基础中说完全背包的两个for循环的先后顺序随意</p><p><strong>但是本题不行</strong></p><p>因为纯完全背包求的是能否凑成总和，跟凑成总和的元素有没有顺序没有关系（即：有关系也行，没有关系也行）</p><p>而本题要求凑成总和的组合数，<strong>元素之间要求没有顺序</strong></p><p>&#x3D;&gt; 所以纯完全背包是能凑出总和即可，不关系过程；本题要求凑出来的方案个数，且方案个数是个组合数，所以两个for循环是有要求的</p></blockquote><p><strong>先遍历物品（钱币），再遍历背包容量（金钱总额）</strong></p><pre><code class="java">for (int i = 0; i &lt; coins.length; i++) &#123; // 遍历物品     for (int j = coins[i]; j &lt;= amount; j++) &#123; // 遍历背包容量         dp[j] += dp[j - coins[i]];     &#125;&#125;</code></pre><p>假设：<code>coins[0] = 1,coins[1] = 5</code>，那么就是先把1加入运算，然后再把5加入运算，得到的方法数量只有{1,5}这种情况，而不会出现{5,1}这种情况 &#x3D;&gt; 这种遍历顺序中的<code>dp[j]</code>里计算的是组合数</p><p><strong>先遍历背包容量（金钱总额），再遍历物品（钱币）</strong></p><pre><code class="java"> for (int j = coins[i]; j &lt;= amount; j++) &#123; // 遍历背包容量    for (int i = 0; i &lt; coins.length; i++) &#123; // 遍历物品         dp[j] += dp[j - coins[i]];     &#125;&#125;</code></pre><p>背包里面的每一个值都是经过了1和5的计算，包含了{1,5}和{5,1}两种情况 &#x3D;&gt; 这种遍历顺序中的<code>dp[j]</code>里计算的是排列数</p></li><li><p>举例推导dp数组<br>输入：amount &#x3D; 5,coins &#x3D; [1,2,5]<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216102450.png"><br>最后红色框<code>dp[amount]</code>为最终结果</p></li></ol><h5 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h5><p>Java代码</p><pre><code class="java">class Solution &#123;    public int change(int amount, int[] coins) &#123;        int[] dp = new int[amount + 1];        dp[0] = 1;        for(int i = 0; i &lt; coins.length; i++) &#123;            for(int j = coins[i]; j &lt;= amount; j++) &#123;                dp[j] += dp[j - coins[i]];            &#125;        &#125;        return dp[amount];    &#125;&#125;</code></pre><h4 id="377、组合总和IV"><a href="#377、组合总和IV" class="headerlink" title="377、组合总和IV"></a>377、组合总和IV</h4><h5 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h5><p>题⽬链接：<a href="https://leetcode-cn.com/problems/combination-sum-iv/">https://leetcode-cn.com/problems/combination-sum-iv/</a></p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数</p><p>题目数据保证答案符合 32 位整数范围。</p><p> 示例 1：</p><p>输入：nums &#x3D; [1,2,3], target &#x3D; 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br><strong>请注意，顺序不同的序列被视作不同的组合。</strong></p><p>示例 2：</p><p>输入：nums &#x3D; [9], target &#x3D; 3<br>输出：0</p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><blockquote><p>本题描述说是求组合，但又说顺序不同的序列被视作不同的组合，其实就是求<strong>排列</strong>，强调元素之间顺序</p></blockquote><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[j]</code>：表示凑成目标正整数<code>j</code>的排列个数为<code>dp[j]</code></p></li><li><p>确定递推公式<br><code>dp[i]</code>（考虑<code>nums[j]</code>）可以由 <code>dp[i - nums[j]]</code>（不考虑<code>nums[j]</code>） 推导出来。 因为只要得到<code>nums[j]</code>，排列个数<code>dp[i - nums[j]]</code>，就是<code>dp[i]</code>的⼀部分<br>&#x3D;&gt; 递推公式：<code>dp[j] += dp[j - nums[i]]</code></p></li><li><p>dp数组初始化<br>因为递推公式<code>dp[i] += dp[i - nums[j]]</code>的缘故，<code>dp[0]</code>要初始化为1，这样递推其他<code>dp[i]</code>的时候 才会有数值基础</p><blockquote><p>⾄于dp[0] &#x3D; 1 有没有意义呢？<br>其实没有意义，这里不强⾏解释它的意义了，因为题⽬中也说了：给定⽬标值是正整数！ 所以dp[0] &#x3D; 1是没有意义的，仅仅是为了推导递推公式。</p></blockquote><p>非零下标的<code>dp[j]</code>初始化为0，这样才不会影响<code>dp[j]</code>累加所有的<code>dp[j - nums[i]]</code></p></li><li><p>确定遍历顺序<br>个数可以不限使⽤，说明这是⼀个完全背包。 得到的集合是排列，说明需要考虑元素之间的顺序。 本题要求的是排列，那么这个for循环嵌套的顺序有要求<br>在<strong>518、零钱兑换II</strong>中提到，<strong>如果是求组合数就是外层for遍历物品，内层for遍历背包容量；如果是去排列数就是外层for遍历背包容量，内层for遍历物品</strong><br>&#x3D;&gt; 以本题遍历顺序最终遍历顺序：<strong>target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历</strong></p></li><li><p>举例推导dp数组<br>输入：nums &#x3D; [1,2,3],target &#x3D; 4<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216104215.png"></p></li></ol><h5 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h5><p>Java代码：</p><pre><code class="java">class Solution &#123;    public int combinationSum4(int[] nums, int target) &#123;        int[] dp = new int[target + 1];        dp[0] = 1;        for(int j = 0; j &lt;= target; j++) &#123; // 遍历背包容量            for(int i = 0; i &lt; nums.length; i++) &#123; // 遍历物品                if(j - nums[i] &gt;= 0) &#123;                    dp[j] += dp[j - nums[i]];                &#125;            &#125;        &#125;        return dp[target];    &#125;&#125;</code></pre><h4 id="70、爬楼梯"><a href="#70、爬楼梯" class="headerlink" title="70、爬楼梯"></a>70、爬楼梯</h4><h5 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h5><p>题目链接：<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢</p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br>            1 阶 + 1 阶<br>            2 阶</p><p>示例 2：</p><p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>            1 阶 + 1 阶 + 1 阶<br>            1 阶 + 2 阶<br>            2 阶 + 1 阶</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><blockquote><p>这道题在<strong>动态规划篇之基础篇</strong>中已经讲过</p><p>这里稍加改动下题目：<br><strong>改为：⼀步⼀个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的⽅ 法可以爬到楼顶呢</strong></p><p>1阶，2阶，…. m阶就是物品，楼顶就是背包。 每⼀阶可以重复使⽤，例如跳了1阶，还可以继续跳1阶。 问跳到楼顶有⼏种⽅法其实就是问装满背包有⼏种⽅法  &#x3D;&gt; 完全背包问题</p></blockquote><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i]</code>:表示爬到第<code>i</code>阶台阶有<code>dp[i]</code>中方法</p></li><li><p>确定递推公式</p><blockquote><p>求装满背包有⼏种⽅法，递推公式⼀般都是dp[i] +&#x3D; dp[i - nums[j]];</p></blockquote><p>本题<code>dp[i]</code>的来源有<code>dp[i - 1]、dp[i - 2]等</code>，即<code>dp[i - j]</code></p><p>&#x3D;&gt; 递推公式：<code>dp[i] += dp[i - j]</code></p></li><li><p>dp数组初始化<br><code>dp[0] = 1</code>，其他非零下标的<code>dp[j] = 0</code></p></li><li><p>确定遍历顺序<br>这是背包里求<strong>排列</strong>的问题，即：1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不⼀ 样<br>&#x3D;&gt; 外层for遍历背包，内层for遍历物品，每⼀步可以⾛多次，这是完全背包，内循环需要从前向后遍历</p></li><li><p>举例推导dp数组<br>和<strong>377、组合总和IV</strong>几乎一样</p><p>输入：nums &#x3D; [1,2,3],target &#x3D; 4<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216104215.png"></p></li></ol><h5 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h5><p>Java代码</p><pre><code class="java">/**代码中的m表示最多可以爬m阶台阶，本题只需要把m改成2就可以AC(accept)本题*/class Solution &#123;    public int climbStairs(int n) &#123;        int[] dp = new int[n + 1];        dp[0] =1;        for(int i = 1; i &lt;= n; i++) &#123;            for(int j = 1; j &lt;= m; j++) &#123;                if(i - j &gt;= 0) dp[i] += dp[i - j];            &#125;        &#125;        return dp[n];    &#125;&#125;</code></pre><h4 id="322、零钱兑换"><a href="#322、零钱兑换" class="headerlink" title="322、零钱兑换"></a>322、零钱兑换</h4><h5 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h5><p>题⽬链接：<a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><p>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + </p><p>示例 2：</p><p>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1</p><p>示例 3：</p><p>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><blockquote><p>题目中说每种硬币的数量时无限的  &#x3D;&gt; 典型的完全背包问题</p></blockquote><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[j]</code>：凑足总金额为<code>j</code>所需要的钱币最少个数是<code>dp[j]</code></p></li><li><p>确定递推公式<br>得到<code>dp[j]</code>（考虑<code>coins[i]</code>），只有⼀个来源，<code>dp[j - coins[i]]</code>（没有考虑<code>coins[i]</code>）<br>凑⾜总额为<code>j - coins[i]</code>的最少个数为<code>dp[j - coins[i]]</code>，那么只需要加上⼀个钱币<code>coins[i]</code>即<code>dp[j - coins[i]] + 1</code>就是<code>dp[j]</code>（考虑<code>coins[i]</code>） 所以<code>dp[j]</code> 要取所有<code>dp[j - coins[i]] + 1</code>中最⼩的<br>&#x3D;&gt; 递推公式：<code>dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);</code></p></li><li><p>dp数组初始化<br>首先凑足总金额为0所需钱币的个数为0，那么<code>dp[0] = 0</code><br>对于其他下标对应的数值，考虑到递推公式的特性，<code>dp[j]</code>必须初始化为⼀个最⼤的数，否则就会在<code>Math.min(dp[j - coins[i]] + 1, dp[j])</code>⽐较的过程中被初始值覆盖 &#x3D;&gt; 下标非零的元素初始化为最大值</p><pre><code class="java">int[] dp = new int[amount + 1];Arrays.fill(dp,Integer.MAX_VALUE);dp[0] = 0;</code></pre></li><li><p>确定遍历顺序<br>本题求钱币最⼩个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最⼩个数。所以本题并不强调集合是组合还是排列<br>&#x3D;&gt; 所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍 历背包，内层for循环遍历物品<strong>都是可以</strong>的<br>这里采用<code>coins</code>放在外循环，<code>target</code>放在内循环</p></li><li><p>举例推导dp数组<br>以输⼊：coins &#x3D; [1, 2, 5], amount &#x3D; 5为例<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221216121619.png"></p></li></ol><h5 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h5><p>Java代码：</p><pre><code class="java">class Solution &#123;    public int coinChange(int[] coins, int amount) &#123;        int[] dp = new int[amount + 1];        Arrays.fill(dp, Integer.MAX_VALUE);        dp[0] = 0;        for(int i = 0; i &lt; coins.length; i++) &#123; // 遍历物品            for(int j = coins[i]; j &lt;= amount; j++) &#123; // 遍历背包容量                if(dp[j - coins[i]] != Integer.MAX_VALUE) &#123; // 如果dp[j - coins[i]] 是初始值则跳过                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);                &#125;            &#125;        &#125;        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];    &#125;&#125;</code></pre><p>对于遍历⽅式遍历背包放在外循环，遍历物品放在内循环也是可以的</p><pre><code class="java">class Solution &#123;    public int coinChange(int[] coins, int amount) &#123;        int[] dp = new int[amount + 1];        Arrays.fill(dp, Integer.MAX_VALUE);        dp[0] = 0;        for(int j = 1; j &lt;= amount; j++) &#123; // 遍历背包容量            for(int i = 0; i &lt; coins.length; i++) &#123; // 遍历物品                if(j - coins[i] &gt;= 0 &amp;&amp; dp[j - coins[i]] != Integer.MAX_VALUE) &#123;                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);                &#125;            &#125;        &#125;        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];    &#125;&#125;</code></pre><h4 id="279、完全平方数"><a href="#279、完全平方数" class="headerlink" title="279、完全平方数"></a>279、完全平方数</h4><h5 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h5><p>题目链接：<a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 12输出：3 解释：12 = 4 + 4 + 4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 13输出：2解释：13 = 4 + 9</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>题目意思理解：<strong>完全平方数就是物品（可以无限使用）。凑成正整数N就是背包，问凑满这个背包最少需要多少物品</strong></p><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i]</code>：和为<code>i</code>的完全平方数的最少数量为<code>dp[i]</code></p></li><li><p>确定递推公式<br><code>dp[i]</code>可以由<code>dp[i - j * j]</code>推出，&#x3D;&gt; <code>dp[i] = dp[i - j * j] + 1</code>，此时我们要选择最小的<code>dp[i]</code><br>&#x3D;&gt; 递推公式：<code>dp[i] = Math.min(dp[i - j * j] + 1, dp[i])</code></p></li><li><p>dp数组的初始化<br>dp[0]表示和为0的完全平⽅数的最⼩数量，那么<code>dp[0] = 0</code>。</p><blockquote><p>0 * 0 也算是⼀种，为啥<code>dp[0] </code>就是 0呢？<br>看题目描述，找到若⼲个完全平⽅数（⽐如 1, 4, 9, 16, …），题目描述中没说要从0开 始，<strong>dp[0]&#x3D;0完全是为了递推公式</strong>。 </p></blockquote><p>非0下标的<code>dp[i]</code>应该是多少呢？<br>从递推公式<code>dp[i] = Math.min(dp[i - j * j] + 1, dp[i])</code>中可以看出每次dp[j]都要选最⼩的，所以非0下 标的<code>dp[i]</code>⼀定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖</p><pre><code class="java">int[] dp = new int[n + 1];Arrays.fill(dp, Integer.MAX_VALUE);dp[0] = 0;</code></pre></li><li><p>确定遍历顺序<br>和<strong>322、零钱兑换</strong>一样，本题也是求最小数<br>所以本题外层for遍历背包，⾥层for遍历物品，还是外层for遍历物品，内层for遍历背包， 都可以</p><pre><code class="java">for (int i = 0; i &lt;= n; i++) &#123; // 遍历背包     for (int j = 1; j * j &lt;= i; j++) &#123; // 遍历物品         dp[i] = min(dp[i - j * j] + 1, dp[i]);     &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221217192726054.png" alt="image-20221217192726054"></p></li></ol><h5 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h5><p>Java代码：</p><pre><code class="java">class Solution &#123;    public int numSquares(int n) &#123;        int[] dp = new int[n + 1];        Arrays.fill(dp,Integer.MAX_VALUE);        dp[0] = 0;        for(int i = 1; i &lt;= n; i++) &#123; // 遍历背包            for(int j = 1; j * j &lt;= i; j++) &#123; // 遍历物品                dp[i] = Math.min(dp[i - j * j] + 1, dp[i]);            &#125;        &#125;        return dp[n];    &#125;&#125;</code></pre><p>先遍历物品，再遍历背包实现</p><pre><code class="java">class Solution &#123;    public int numSquares(int n) &#123;        int[] dp = new int[n + 1];        Arrays.fill(dp,Integer.MAX_VALUE);        dp[0] = 0;        for(int j = 1; j * j &lt;= n; j++) &#123; // 遍历物品            for(int i = 1; i &lt;= n; i++) &#123; // 遍历背包                if(i - j * j &gt;= 0) &#123;                    dp[i] = Math.min(dp[i - j * j] + 1, dp[i]);                &#125;                            &#125;        &#125;        return dp[n];    &#125;&#125;</code></pre><h4 id="139、单词拆分"><a href="#139、单词拆分" class="headerlink" title="139、单词拆分"></a>139、单词拆分</h4><h5 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h5><p>题目链接：<a href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a> </p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1</strong>：</p><pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。     注意，你可以重复使用字典中的单词。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li></ul><h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>题目解释：<strong>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满，拆分时可以重复使用字典中的单词</strong></p><p>动归五部曲：</p><ol><li><p>确定dp数组以及下标的含义<br><code>dp[i]</code>：字符串长度为<code>i</code>的话，<code>dp[i]</code>为<code>true</code>，表⽰可以拆分为一个或多个在字典中出现的单词</p></li><li><p>确定递推公式<br>如果确定<code>dp[j] = true</code>，且<code>[j, i]</code>这个区间的子串出现在字典里，那么<code>dp[i] = true</code>，前提是<code>j &lt; i</code><br>&#x3D;&gt; 递推公式</p><pre><code class="java">if([j, i]这个区间的子串出现在字典里 &amp;&amp; dp[j] = true)&#123;    dp[i] = true&#125;</code></pre></li><li><p>dp数组初始化<br>从递归公式中可以看出，<code>dp[i]</code> 的状态依靠<code> dp[j]</code>是否为<code>true</code>，那么<code>dp[0]</code>就是递归的根基， <code>dp[0]</code>⼀定要为<code>true</code>，否则递归下去后⾯都都是<code>false</code>了</p><blockquote><p>dp[0]的意义完全是为了递推公式<br>dp[0]表⽰如果字符串为空的话，说明出现在字典⾥。 但题目中说了“给定⼀个非空字符串 s” 所以测试数据中不会出现<code>i</code>为0的情况</p></blockquote><p>下标非零的<code>dp[i</code>]初始化为<code>false</code>，只要没有被覆盖说明都是不可拆分为一个或者多个在字典中出现的单词</p></li><li><p>确定遍历顺序<br>题目中说是拆分为一个或者多个出现在字典中的单词 &#x3D;&gt; 完全背包<br>讨论；两层for循环的前后顺序</p><blockquote><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。 </p><p>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p><p>本题最终要求的是<strong>是否都出现过</strong>，所以对出现单词集合⾥的元素是组合还是排列，并不关心</p><p>那么本题使⽤求排列的方式，还是求组合的方式都可以。 即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品都是可以的</p><p>但本题还有<strong>特殊性</strong>，因为是要<strong>求⼦串</strong>，最好是遍历背包放在外循环，将遍历物品放在内循环。 如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的⼦串都预先放在⼀个容器里（数组、列表都可以）</p><p>&#x3D;&gt; 遍历顺序：遍历背包（字符串s）在外层循环，遍历物品（字典）在内层循环，内循环从前往后</p></blockquote></li><li><p>举例推导dp数组<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20221217195417082.png" alt="image-20221217195417082"></p></li></ol><h5 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h5><pre><code class="java">// 时间复杂度：O(n^3)，因为substr返回子串的副本是O(n)的复杂度（这⾥的n是substring的长度）// 空间复杂度：O(n)class Solution &#123;    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;        int sLen = s.length();        Set&lt;String&gt; wordDictSet = new HashSet&lt;&gt;(wordDict);        boolean[] dp = new boolean[sLen + 1];        dp[0] = true;        for(int i = 1; i &lt;= sLen; i++) &#123; // 遍历背包            for(int j = 0; j &lt; i; j++) &#123;// 遍历物品                String word = s.substring(j, i);                if(dp[j] &amp;&amp; wordDictSet.contains(word))&#123;                    dp[i] = true;                    break;                &#125;            &#125;        &#125;        return dp[sLen];    &#125;&#125;</code></pre><h2 id="三、多重背包"><a href="#三、多重背包" class="headerlink" title="三、多重背包"></a>三、多重背包</h2><p><em>掌握程度：知 道它是⼀种01背包，并能在01背包的基础上写出对应代码</em></p><h3 id="多重背包理论基础"><a href="#多重背包理论基础" class="headerlink" title="多重背包理论基础"></a>多重背包理论基础</h3><h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><p>有N种物品和⼀个容量为V的背包。第i种物品最多有M<sub>i</sub>件可⽤，每件耗费的空间是C<sub>i</sub>，价 值是W<sub>i</sub>。求解将哪些物品装⼊背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p><hr><p>多重背包和01背包非常像 &#x3D;&gt; 将多重背包中的每件物品最多有M<sub>i</sub>件展开，其实就是个01背包问题</p><p><strong>例如：</strong></p><p>背包的最大重量为10</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th><th>数量</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td><td>2</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>3</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>2</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><p><strong>和如下情况有区别吗？</strong></p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th><th>数量</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td><td>1</td></tr><tr><td>物品0</td><td>1</td><td>15</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>1</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>1</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><p>&#x3D;&gt; <strong>毫无区别，这就转换成了一个01背包问题了，且每个物品只用一次</strong></p><hr><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>实现方式一：展开成01背包</strong></p><pre><code class="java">public class MultiBagProblem &#123;    /**     * 物品重量     */    private final List&lt;Integer&gt; weight;    /**     * 价值     */    private final List&lt;Integer&gt; value;    /**     * 背包重量     */    private final int bagWeight;    /**     * 物品数量     */    private final List&lt;Integer&gt; nums;    &#123;        weight = new ArrayList&lt;&gt;(Arrays.asList(1, 3, 4));        value = new ArrayList&lt;&gt;(Arrays.asList(15, 20, 30));        nums = new ArrayList&lt;&gt;(Arrays.asList(2, 3, 2));        bagWeight = 10;    &#125;    // 时间复杂度：O(m * n * k) m：物品种类个数，n背包容量，k单类物品数量    public void multiBagProblem() &#123;        // 展开物品数量        for (int i = 0; i &lt; nums.size(); i++) &#123;            int num = nums.get(i);            while (num &gt; 1) &#123;                weight.add(weight.get(i));                value.add(value.get(i));                num--;            &#125;        &#125;        // 转换成01背包问题        int[] dp = new int[bagWeight + 1];        // 遍历物品        for (int i = 0;i &lt; weight.size(); i++) &#123;            int w = weight.get(i);            for (int j = bagWeight; j &gt;= w; j--) &#123; // 遍历背包                dp[j] = Math.max(dp[j - w] + value.get(i), dp[j]);            &#125;        &#125;        System.out.println(Arrays.toString(dp));        System.out.println(&quot;结果&quot; + dp[bagWeight]);    &#125;    @Test    public void testMultiBagProblem() &#123;        multiBagProblem();    &#125;&#125;/**[0, 15, 30, 30, 35, 50, 60, 60, 70, 80, 90]结果90*/</code></pre><p><strong>实现方式二：把每种商品遍历的个数放在01背包⾥⾯在遍历⼀遍</strong></p><pre><code class="java">public class MultiBagProblem2 &#123;    /**     * 物品重量     */    private static final int[] weight;    /**     * 价值     */    private static final int[] value;    /**     * 背包重量     */    private static final int bagWeight;    /**     * 物品数量     */    private static final int[] nums;    static &#123;        weight = new int[]&#123;1, 3, 4&#125;;        value = new int[]&#123;15, 20, 30&#125;;        nums = new int[]&#123;2, 3, 2&#125;;        bagWeight = 10;    &#125;    public void multiBagProblem() &#123;        int[] dp = new int[bagWeight + 1];        // 遍历物品        for (int i = 0; i &lt; weight.length; i++) &#123;            // 遍历背包            for (int j = bagWeight; j &gt;= weight[i]; j--) &#123;                // 遍历个数                for (int k = 1; k &lt;= nums[i] &amp;&amp; j - k * weight[i] &gt;= 0; k++) &#123;                    dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);                &#125;            &#125;        &#125;        System.out.println(Arrays.toString(dp));        System.out.println(&quot;结果&quot; + dp[bagWeight]);    &#125;    @Test    public void testMultiBagProblem() &#123;        multiBagProblem();    &#125;&#125;/**[0, 15, 30, 30, 35, 50, 60, 60, 70, 80, 90]结果90*/</code></pre><h2 id="四、背包问题总结篇"><a href="#四、背包问题总结篇" class="headerlink" title="四、背包问题总结篇"></a>四、背包问题总结篇</h2><p>几种常见的背包：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221213134144.png"></p><p>理解背包问题所用到的<strong>动归五部曲</strong>：</p><ol><li>确定dp数组(dp table)以及下标的含义</li><li>确定递推公式</li><li>dp数组的初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>这五个步骤都很关键，但确定递推公式和确定遍历顺序都具有规律性和代表性</p><h3 id="背包递推公式"><a href="#背包递推公式" class="headerlink" title="背包递推公式"></a>背包递推公式</h3><p>1）问能否装满背包（或者最多装多少）：<code>dp[j] = Math,max(dp[j], dp[j - nums[i]] + nums[i])</code>，对应的题目如下：</p><ul><li><strong><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集 - 力扣（LeetCode）</a></strong></li><li><strong><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II - 力扣（LeetCode）</a></strong></li></ul><p>2）问装满背包有几种方法：<code>dp[j] += dp[j - nums[i]]</code>，对应的题目如下：</p><ul><li><strong><a href="https://leetcode.cn/problems/target-sum/">494. 目标和 - 力扣（LeetCode）</a></strong></li><li><strong><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II - 力扣（LeetCode）</a></strong></li><li><strong><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></strong></li><li><strong>70.爬楼梯进阶版（完全背包）</strong></li></ul><p>3）问背包装满最大价值：<code>dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])</code>，对应的题目如下：</p><ul><li><strong><a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零 - 力扣（LeetCode）</a></strong></li></ul><p>4）问装满背包所有物品的最小个数：<code>dp[j] = Math.min(dp[j - conins[i]] + 1, dp[j])</code>，对应的题目如下：</p><ul><li><strong><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换 - 力扣（LeetCode）</a></strong></li><li><strong><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数 - 力扣（LeetCode）</a></strong></li></ul><h3 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h3><h4 id="01背包-1"><a href="#01背包-1" class="headerlink" title="01背包"></a>01背包</h4><ul><li>二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历</li><li>一维dp数组01背包只能先遍历物品在遍历背包容量，且第二层for循环是从大到小遍历</li></ul><h4 id="完全背包-1"><a href="#完全背包-1" class="headerlink" title="完全背包"></a>完全背包</h4><ul><li>纯完全背包的一维dp数组实现， 先遍历物品还是先遍历背包都是可以的的，且第二层for循环是从小到大遍历</li><li>如果是求组合数就是外层for循环遍历物品，内层for循环遍历背包</li><li>如果是求排列数就是外层for循环遍历背包，内层for循环遍历物品</li><li>如果求最⼩数，那么两层for循环的先后顺序就无所谓了</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot运维实用技巧</title>
      <link href="/2022/12/16/SpringBoot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/12/16/SpringBoot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#springboot-%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7">SpringBoot 运维实用技巧</a><ul><li><a href="#1springboot%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E8%BF%90%E8%A1%8C">1.SpringBoot程序的打包与运行</a><ul><li><a href="#%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85">程序打包</a></li><li><a href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C">程序运行</a></li><li><a href="#springboot%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86">SpringBoot程序打包失败处理</a></li><li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88windows%E7%89%88">命令行启动常见问题及解决方案（Windows版）</a></li><li><a href="#springboot%E9%A1%B9%E7%9B%AE%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8linux%E7%89%88">SpringBoot项目快速启动（Linux版）</a></li></ul></li><li><a href="#2%E9%85%8D%E7%BD%AE%E9%AB%98%E7%BA%A7">2.配置高级</a><ul><li><a href="#21-%E4%B8%B4%E6%97%B6%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE">2.1 临时属性配置</a><ul><li><a href="#%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7">属性加载优先级</a></li><li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E5%B1%9E%E6%80%A7">开发环境中使用临时属性</a></li></ul></li><li><a href="#22-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB">2.2 配置文件分类</a></li><li><a href="#23-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">2.3 自定义配置文件</a></li></ul></li><li><a href="#3%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91">3.多环境开发</a><ul><li><a href="#31-%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91yaml%E5%8D%95%E4%B8%80%E6%96%87%E4%BB%B6%E7%89%88">3.1 多环境开发（yaml单一文件版）</a></li><li><a href="#32-%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91yaml%E5%A4%9A%E6%96%87%E4%BB%B6%E7%89%88">3.2 多环境开发（yaml多文件版）</a></li><li><a href="#33-%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91properties%E5%A4%9A%E6%96%87%E4%BB%B6%E7%89%88">3.3 多环境开发（properties多文件版）</a></li><li><a href="#34-%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%A6%E5%86%99%E6%8A%80%E5%B7%A7">3.4 多环境开发独立配置文件书写技巧</a></li><li><a href="#35-%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91%E6%8E%A7%E5%88%B6">3.5 多环境开发控制</a></li></ul></li><li><a href="#4%E6%97%A5%E5%BF%97">4.日志</a><ul><li><a href="#%E6%95%99%E4%BD%A0%E4%B8%80%E6%8B%9B%E4%BC%98%E5%8C%96%E6%97%A5%E5%BF%97%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81">教你一招：优化日志对象创建代码</a></li><li><a href="#42-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6">4.2 日志输出格式控制</a></li><li><a href="#43-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">4.3 日志文件</a></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h1 id="SpringBoot-运维实用技巧"><a href="#SpringBoot-运维实用技巧" class="headerlink" title="SpringBoot 运维实用技巧"></a>SpringBoot 运维实用技巧</h1><blockquote><p>教程视频地址：<a href="https://www.bilibili.com/video/BV15b4y1a7yG">https://www.bilibili.com/video/BV15b4y1a7yG</a></p></blockquote><h2 id="1-SpringBoot程序的打包与运行"><a href="#1-SpringBoot程序的打包与运行" class="headerlink" title="1.SpringBoot程序的打包与运行"></a>1.SpringBoot程序的打包与运行</h2><blockquote><p>开发和上线是两套不同的环境</p><ul><li>开发<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201091317258.png" alt="image-20211201091317258" style="zoom:67%;" /></li><li>上线<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201091502040.png" alt="image-20211201091502040" style="zoom:67%;" /></li></ul><p><font color="#f0f"><b>温馨提示</b></font></p><p>​企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。</p><ol><li>开发部门使用Git、SVN等版本控制工具上传工程到版本服务器</li><li>服务器使用版本控制工具下载工程</li><li>服务器上使用Maven工具在当前真机环境下重新构建项目</li><li>启动服务</li></ol></blockquote><h3 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h3><p>SpringBoot程序是<strong>基于Maven创建</strong>的，在Maven中提供有打包的指令，叫做<code>package</code></p><pre><code class="Java">mvn package</code></pre><p><em>此操作可以再Idea中执行</em>。打包后会产生一个与工程名类似的<strong>jar文件</strong>，其名称是由<code>模块名+版本号+.jar</code>组成的</p><h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>程序打包之后，在程序包所在路径下，执行命令</p><pre><code class="shell">java -jar 工程包名.jar</code></pre><p>执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。</p><p><font color="#ff0000"><b>注意事项</b></font></p><ul><li><p>上述操作需要jdk环境支持</p></li><li><p>在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序</p><pre><code class="xml">&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre></li></ul><p><strong>总结</strong></p><ol><li>SpringBoot工程可以基于java环境下独立运行jar文件启动服务</li><li>SpringBoot工程执行mvn命令<code>package</code>进行打包</li><li>执行jar命令：<code>java –jar 工程名.jar</code></li></ol><h3 id="SpringBoot程序打包失败处理"><a href="#SpringBoot程序打包失败处理" class="headerlink" title="SpringBoot程序打包失败处理"></a>SpringBoot程序打包失败处理</h3><p>失败现象：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;" /></p><p>要想搞清楚这个问题就要明白<code>.jar</code>文件的工作机制：</p><p>Java开发平时会接触很多的jar包，比如MySQL的驱动jar包，上面我们的打包程序后的得到的也是一个jar包。</p><blockquote><p>这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的SpringBoot项目为什么能执行呢？其实是因为打包方式不一样</p></blockquote><p>在SpringBoot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行</p><pre><code class="xml">&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>开启这段配置和注释掉这段配置分别执行两次打包，两次打包后的程序包的差别主要有以下3处明显的特征</p><ul><li><p>打包后文件的<strong>大小不同</strong></p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201095610270.png" alt="image-20211201095610270" style="zoom:150%;" /></li><li><p>打包后所包含的<strong>内容不同</strong></p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201101541267.png" alt="image-20211201101541267" style="zoom:50%;" /><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;" />内容也完全不一样，仅有一个目录`META-INF`是一样的容量大的程序包中的BOOT-INF目录下的classes目录下的内容与容量小的程序包中的内容完全一样<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201101805569.png" alt="image-20211201101805569" style="zoom:50%;" /><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;" />容量大的程序包下的BOOT-INF目录下，打开lib目录，里面显示了很多个jar文件，这些jar文件是开发时制作这个工程时导入的坐标对应的文件<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201102025791.png" alt="image-20211201102025791" style="zoom:50%;" /><blockquote><p>SpringBoot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因</p></blockquote></li><li><p>打包程序中个别文件内容不同<br>大程序包在最外层目录包含一个org目录，进入此目录，目录名是org\springframework\boot\loader，在里面可以找到一个<font color="#ff0000"><b>JarLauncher.class</b></font>的文件<br>两个程序包的最外层目录，查看名称相同的文件夹META-INF下都有一个叫做MANIFEST.MF的文件，但是大小不同</p><ul><li><p>小容量文件的MANIFEST.MF</p><pre><code class="java">Manifest-Version: 1.0Implementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTBuild-Jdk-Spec: 1.8Created-By: Maven Jar Plugin 3.2.0</code></pre></li><li><p>大容量文件的MANIFEST.MF</p><pre><code class="java">Manifest-Version: 1.0Spring-Boot-Classpath-Index: BOOT-INF/classpath.idxImplementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTSpring-Boot-Layers-Index: BOOT-INF/layers.idxStart-Class: com.juzi.SSMPApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.5.4Created-By: Maven Jar Plugin 3.2.0Main-Class: org.springframework.boot.loader.JarLauncher</code></pre><p>大文件中明显比小文件中多了几行信息，其中最后一行信息是Main-Class: org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font></p><blockquote><p>如果使用java -jar执行此程序包，将执行Main-Class属性配置的类，这个类恰巧就是前面看到的那个文件。原来SpringBoot打包程序中出现Spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font>类内部要查找Start-Class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名</p></blockquote></li></ul><p>&#x3D;&gt; 设定的作用</p><ol><li>SpringBoot程序添加配置后会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包</li><li>首先读取MANIFEST.MF文件中的Main-Class属性，用来标记执行java -jar命令后运行的类</li><li>JarLauncher类执行时会找到Start-Class属性，也就是启动类类名</li><li>运行启动类时会运行当前工程的内容</li><li>运行当前工程时会使用依赖的jar包，从lib目录中查找</li></ol><p>之前的报错信息：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;" /><br>    由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在MANIFEST.MF文件中也就没有了Main-Class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因</p></li></ul><h3 id="命令行启动常见问题及解决方案（Windows版）"><a href="#命令行启动常见问题及解决方案（Windows版）" class="headerlink" title="命令行启动常见问题及解决方案（Windows版）"></a>命令行启动常见问题及解决方案（Windows版）</h3><p>DOS环境下启动SpringBoot工程，可能会遇到端口占用问题</p><p>(不用背，忘了就查！！！)</p><pre><code class="shell"># 查询端口netstat -ano# 查询指定端口netstat -ano |findstr &quot;端口号&quot;# 根据进程PID查询进程名称tasklist |findstr &quot;进程PID号&quot;# 根据PID杀死任务taskkill /F /PID &quot;进程PID号&quot;# 根据进程名称杀死任务taskkill -f -t -im &quot;进程名称&quot;</code></pre><h3 id="SpringBoot项目快速启动（Linux版）"><a href="#SpringBoot项目快速启动（Linux版）" class="headerlink" title="SpringBoot项目快速启动（Linux版）"></a>SpringBoot项目快速启动（Linux版）</h3><p>启动SpringBoot项目命令同Windows。忘了就查！！！</p><h2 id="2-配置高级"><a href="#2-配置高级" class="headerlink" title="2.配置高级"></a>2.配置高级</h2><h3 id="2-1-临时属性配置"><a href="#2-1-临时属性配置" class="headerlink" title="2.1 临时属性配置"></a>2.1 临时属性配置</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211206095113771.png" alt="image-20211206095113771"> &#x3D;&#x3D;&#x3D;&gt; <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211206095101581.png" alt="image-20211206095101581"></p><p>SpringBoot提供了灵活的配置方式。如果项目中有个别属性需要重新配置，可以使用临时配置的方式快速修改某些配置 &#x3D;&gt; 启动的时候添加上相应参数即可</p><pre><code class="java">java –jar springboot.jar –-server.port=80</code></pre><p>当要修改的属性不止一个时，可以按照上述格式继续写，属性之间使用空格相隔</p><pre><code class="java">java –jar springboot.jar –-server.port=80 --logging.level.root=debug</code></pre><h4 id="属性加载优先级"><a href="#属性加载优先级" class="headerlink" title="属性加载优先级"></a>属性加载优先级</h4><p>官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html">https://docs.spring.io/spring-boot/docs/current/reference/html/features.html</a></p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211206100859236.png" alt="image-20211206100859236" style="zoom:67%;" /><p><strong>总结</strong></p><ol><li>使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性</li><li>临时属性添加方式：java –jar 工程名.jar –-属性名&#x3D;值</li><li>多个临时属性之间使用空格分隔</li><li>临时属性必须是当前boot工程支持的属性，否则设置无效</li></ol><h4 id="开发环境中使用临时属性"><a href="#开发环境中使用临时属性" class="headerlink" title="开发环境中使用临时属性"></a>开发环境中使用临时属性</h4><p>Idea界面下的操作</p><p>打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211206101947622.png" alt="image-20211206101947622" style="zoom:80%;" /></p><pre><code class="java">public static void main(String[] args) &#123;    SpringApplication.run(SSMPApplication.class,args);&#125;</code></pre><p>&#x3D;&gt; <strong>args参数传递给了run方法</strong></p><blockquote><p>不使用这个args就断开了外部传递临时属性的入口</p><pre><code class="java">public static void main(String[] args) &#123;    SpringApplication.run(SSMPApplication.class);&#125;</code></pre><p>或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口（没有实际意义）</p><pre><code class="java">public static void main(String[] args) &#123;    String[] arg = new String[1];    arg[0] = &quot;--server.port=8082&quot;;    SpringApplication.run(SSMPApplication.class, arg);&#125;</code></pre></blockquote><h3 id="2-2-配置文件分类"><a href="#2-2-配置文件分类" class="headerlink" title="2.2 配置文件分类"></a>2.2 配置文件分类</h3><p>SpringBoot提供的4级配置文件：</p><ul><li>类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）</li><li>类路径下config目录下配置文件</li><li>程序包所在目录中配置文件</li><li>程序包所在目录中config目录下配置文件</li></ul><p>&#x3D;&gt; 配置文件优先级：</p><ol><li>file ：config&#x2F;application.yml <strong>【最高】</strong></li><li>file ：application.yml</li><li>classpath：config&#x2F;application.yml</li><li>classpath：application.yml  <strong>【最低】</strong></li></ol><blockquote><p>那为什么设计这种多种呢？说一个最典型的应用吧。</p><ul><li>场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。</li><li>场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。</li><li>场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？</li></ul><p>解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？</p><p>​级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。</p></blockquote><p><strong>总结</strong></p><ol><li><p>配置文件分为4种</p><ul><li>项目类路径配置文件：服务于开发人员本机开发与测试</li><li>项目类路径config目录中配置文件：服务于项目经理整体调控</li><li>工程路径配置文件：服务于运维人员配置涉密线上环境</li><li>工程路径config目录中配置文件：服务于运维经理整体调控</li></ul></li><li><p>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</p></li></ol><h3 id="2-3-自定义配置文件"><a href="#2-3-自定义配置文件" class="headerlink" title="2.3 自定义配置文件"></a>2.3 自定义配置文件</h3><p><strong>方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名</strong><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211206105548238.png" alt="image-20211206105548238" style="zoom:67%;" /></p><p><strong>方式二：使用临时属性设置配置文件路径，这个是全路径名</strong><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211206105716450.png" alt="image-20211206105716450" style="zoom:67%;" /><br>也可以设置多个加载配置文件<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211206105750285.png" alt="image-20211206105750285" style="zoom:67%;" /><br>使用的属性一个是spring.config.name，另一个是spring.config.location</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。</p><p><strong>总结</strong></p><ol><li>配置文件可以修改名称，通过启动参数设定</li><li>配置文件可以修改路径，通过启动参数设定</li><li>微服务开发中配置文件通过配置中心进行设置</li></ol><h2 id="3-多环境开发"><a href="#3-多环境开发" class="headerlink" title="3.多环境开发"></a>3.多环境开发</h2><blockquote><p>​什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211206110958819.png" alt="image-20211206110958819" style="zoom:67%;" /></p></blockquote><h3 id="3-1-多环境开发（yaml单一文件版）"><a href="#3-1-多环境开发（yaml单一文件版）" class="headerlink" title="3.1 多环境开发（yaml单一文件版）"></a>3.1 多环境开发（yaml单一文件版）</h3><p>多环境开发就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：</p><pre><code class="yaml">server:  port: 80</code></pre><p>​如何想设计两组环境呢？中间使用三个减号分隔开</p><pre><code class="yaml">server:  port: 80---server:  port: 81</code></pre><p>​如何区分两种环境呢？起名字呗</p><pre><code class="yaml">spring:    profiles: proserver:    port: 80---spring:    profiles: devserver:    port: 81</code></pre><p>​那用哪一个呢？设置默认启动哪个就可以了</p><pre><code class="yaml">spring:    profiles:        active: pro# 启动pro---spring:    profiles: proserver:    port: 80---spring:    profiles: devserver:    port: 81</code></pre><p>​就这么简单，再多来一组环境也OK</p><pre><code class="yaml">spring:    profiles:        active: pro# 启动pro---spring:    profiles: proserver:    port: 80---spring:    profiles: devserver:    port: 81---spring:    profiles: testserver:    port: 82</code></pre><p>​其中关于环境名称定义上述格式是过时格式，标准格式如下</p><pre><code class="yaml">spring:    config:        activate:            on-profile: pro</code></pre><p><strong>总结</strong></p><ol><li>多环境开发需要设置若干种常用环境，例如开发、生产、测试环境</li><li>yaml格式中设置多环境使用—区分环境设置边界</li><li>每种环境的区别在于加载的配置属性不同</li><li>启用某种环境时需要指定启动时使用该环境</li></ol><h3 id="3-2-多环境开发（yaml多文件版）"><a href="#3-2-多环境开发（yaml多文件版）" class="headerlink" title="3.2 多环境开发（yaml多文件版）"></a>3.2 多环境开发（yaml多文件版）</h3><blockquote><p>将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。</p></blockquote><p><strong>主配置文件</strong></p><pre><code class="yaml">spring:    profiles:        active: pro# 启动pro</code></pre><p><strong>环境配置文件</strong></p><pre><code class="yaml">server:    port: 80</code></pre><p>环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。</p><p><strong>application-pro.yaml</strong></p><pre><code class="yaml">server:    port: 80</code></pre><p><strong>application-dev.yaml</strong></p><pre><code class="yaml">server:    port: 81</code></pre><p>文件的命名规则为：application-环境名.yml。</p><p>在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。</p><ul><li>主配置文件中设置公共配置（全局）</li><li>环境分类配置文件中常用于设置冲突属性（局部）</li></ul><p><strong>总结</strong></p><ol><li><p>可以使用独立配置文件定义环境属性</p></li><li><p>独立配置文件便于线上系统维护更新并保障系统安全性</p></li></ol><h3 id="3-3-多环境开发（properties多文件版）"><a href="#3-3-多环境开发（properties多文件版）" class="headerlink" title="3.3 多环境开发（properties多文件版）"></a>3.3 多环境开发（properties多文件版）</h3><p>SpringBoot最早期提供的配置文件格式是properties格式的</p><p><strong>主配置文件</strong></p><pre><code class="properties">spring.profiles.active=pro</code></pre><p><strong>环境配置文件</strong></p><p><strong>application-pro.properties</strong></p><pre><code class="properties">server.port=80</code></pre><p><strong>application-dev.properties</strong></p><pre><code class="properties">server.port=81</code></pre><p>​文件的命名规则为：application-环境名.properties。</p><p><strong>总结</strong></p><ol><li>properties文件多环境配置仅支持多文件格式</li></ol><h3 id="3-4-多环境开发独立配置文件书写技巧"><a href="#3-4-多环境开发独立配置文件书写技巧" class="headerlink" title="3.4 多环境开发独立配置文件书写技巧"></a>3.4 多环境开发独立配置文件书写技巧</h3><p><strong>准备工作</strong></p><p>​将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下</p><ul><li>application-devDB.yml</li><li>application-devRedis.yml</li><li>application-devMVC.yml</li></ul><p><strong>使用</strong></p><p>​使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔</p><pre><code class="yaml">spring:    profiles:        active: dev        include: devDB,devRedis,devMVC</code></pre><p>​比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么</p><p><strong>注意</strong></p><p>​当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效</p><p><strong>改良</strong></p><p>​但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。</p><pre><code class="yaml">spring:    profiles:        active: dev        group:            &quot;dev&quot;: devDB,devRedis,devMVC              &quot;pro&quot;: proDB,proRedis,proMVC              &quot;test&quot;: testDB,testRedis,testMVC</code></pre><p>现在再来看，如果切换dev到pro，只需要改一下就结束了</p><p><strong>总结</strong></p><ol><li>多环境开发使用group属性设置配置文件分组，便于线上维护管理</li></ol><h3 id="3-5-多环境开发控制"><a href="#3-5-多环境开发控制" class="headerlink" title="3.5 多环境开发控制"></a>3.5 多环境开发控制</h3><blockquote><p>一个冲突问题：就是maven和SpringBoot同时设置多环境的话怎么办？</p><p>要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。</p><p>​maven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。</p></blockquote><p>整个确认后下面就好做了。大体思想如下：</p><ul><li>先在maven环境中设置用什么具体的环境</li><li>在SpringBoot中读取maven设置的环境即可</li></ul><p><strong>maven中设置多环境（使用属性方式区分环境）</strong></p><pre><code class="xml">&lt;profiles&gt;    &lt;profile&gt;        &lt;id&gt;env_dev&lt;/id&gt;        &lt;properties&gt;            &lt;profile.active&gt;dev&lt;/profile.active&gt;        &lt;/properties&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&lt;!--默认启动环境--&gt;        &lt;/activation&gt;    &lt;/profile&gt;    &lt;profile&gt;        &lt;id&gt;env_pro&lt;/id&gt;        &lt;properties&gt;            &lt;profile.active&gt;pro&lt;/profile.active&gt;        &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;</code></pre><p><strong>SpringBoot中读取maven设置值</strong></p><pre><code class="yaml">spring:    profiles:        active: @profile.active@</code></pre><p>​上面的@属性名@就是读取maven中配置的属性值的语法格式。</p><p><strong>总结</strong></p><ol><li>当Maven与SpringBoot同时对多环境进行控制时，以Maven为主，SpringBoot使用<code>@..@</code>占位符读取Maven对应的配置属性值</li><li>基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动<code>compile</code>方可生效</li></ol><h2 id="4-日志"><a href="#4-日志" class="headerlink" title="4.日志"></a>4.日志</h2><p>日志其实就是记录程序日常运行的信息，主要作用如下：</p><ul><li>编程期调试代码</li><li>运营期记录信息</li><li>记录日常运营重要信息（峰值流量、平均响应时长……）</li><li>记录应用报错信息（错误堆栈）</li><li>记录运维过程数据（扩容、宕机、报警……）</li></ul><p>####4.1 代码中使用日志工具记录日志</p><p>​日志的使用格式非常固定，直接上操作步骤：</p><p><strong>步骤①</strong>：添加日志记录操作</p><pre><code class="JAVA">@RestController@RequestMapping(&quot;/books&quot;)public class BookController extends BaseClass&#123;    private static final Logger log = LoggerFactory.getLogger(BookController.class);    @GetMapping    public String getById()&#123;        log.debug(&quot;debug...&quot;);        log.info(&quot;info...&quot;);        log.warn(&quot;warn...&quot;);        log.error(&quot;error...&quot;);        return &quot;springboot is running...2&quot;;    &#125;&#125;</code></pre><p>​上述代码中log对象就是用来记录日志的对象，下面的<code>log.debug</code>，<code>log.info</code>这些操作就是写日志的API了。</p><p><strong>步骤②</strong>：设置日志输出级别</p><p>​日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：</p><ul><li>TRACE：运行堆栈信息，使用率低</li><li>DEBUG：程序员调试代码使用</li><li>INFO：记录运维过程数据</li><li>WARN：记录运维过程报警数据</li><li>ERROR：记录错误堆栈信息</li><li>FATAL：灾难信息，合并计入ERROR</li></ul><p>​一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别：</p><pre><code class="yaml"># 开启debug模式，输出调试信息，常用于检查系统运行状况debug: true</code></pre><p>​这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制</p><pre><code class="yaml"># 开启debug模式，输出调试信息，常用于检查系统运行状况debug: true# 设置日志级别，root表示根节点，即整体应用日志级别logging:    level:        root: debug</code></pre><p>​还可以再设置更细粒度的控制</p><p><strong>步骤③</strong>：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别</p><pre><code class="yaml">logging:    # 设置日志组    group:        # 自定义组名，设置当前组中所包含的包        ebank: com.juzi.controller    level:        root: warn        # 为对应组设置日志级别        ebank: debug        # 为对包设置日志级别        com.juzi.controller: debug</code></pre><p>​说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。</p><p><strong>总结</strong></p><ol><li>日志用于记录开发调试与运维过程消息</li><li>日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR</li><li>可以通过日志组或代码包的形式进行日志显示级别的控制</li></ol><h4 id="教你一招：优化日志对象创建代码"><a href="#教你一招：优化日志对象创建代码" class="headerlink" title="教你一招：优化日志对象创建代码"></a>教你一招：优化日志对象创建代码</h4><p>写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。</p><pre><code class="JAVA">@RestController@RequestMapping(&quot;/books&quot;)public class BookController extends BaseClass&#123;    private static final Logger log = LoggerFactory.getLogger(BookController.class);//这一句可以不写了&#125;</code></pre><p>​导入lombok后使用注解搞定，日志对象名为log</p><pre><code class="JAVA">@Slf4j//这个注解替代了下面那一行@RestController@RequestMapping(&quot;/books&quot;)public class BookController extends BaseClass&#123;    private static final Logger log = LoggerFactory.getLogger(BookController.class);//这一句可以不写了&#125;</code></pre><p><strong>总结</strong></p><ol><li>基于lombok提供的<code>@Slf4j</code>注解为类快速添加日志对象</li></ol><h4 id="4-2-日志输出格式控制"><a href="#4-2-日志输出格式控制" class="headerlink" title="4.2 日志输出格式控制"></a>4.2 日志输出格式控制</h4><p>日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/image-20211206123431222.png" alt="image-20211206123431222"></p><p>对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。</p><pre><code class="yaml">logging:    pattern:        console: &quot;%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n&quot;</code></pre><p><strong>总结</strong></p><ol><li>日志输出格式设置规则</li></ol><h4 id="4-3-日志文件"><a href="#4-3-日志文件" class="headerlink" title="4.3 日志文件"></a>4.3 日志文件</h4><p>​日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。</p><p>​对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。</p><p>​记录日志到文件中格式非常简单，设置日志文件名即可。</p><pre><code class="YAML">logging:    file:        name: server.log</code></pre><p>​虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：</p><pre><code class="YAML">logging:    logback:        rollingpolicy:            max-file-size: 5MB            file-name-pattern: server.%d&#123;yyyy-MM-dd&#125;.%i.log</code></pre><p>​以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达5MB以后就转存信息到第二个文件中。文件命名规则中的<code>%d</code>标识日期，<code>%i</code>是一个递增变量，用于区分日志文件。</p><p><strong>总结</strong></p><ol><li>日志记录到文件</li><li>日志文件格式设置</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之路 -- 动态规划篇之基础篇</title>
      <link href="/2022/12/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2022/12/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="算法学习之路–动态规划篇之基础篇"><a href="#算法学习之路–动态规划篇之基础篇" class="headerlink" title="算法学习之路–动态规划篇之基础篇"></a>算法学习之路–动态规划篇之基础篇</h1><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87">算法学习之路–动态规划篇之基础篇</a><ul><li><a href="#%E4%B8%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">一、动态规划理论基础</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">什么是动态规划</a></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4">动态规划解题步骤</a></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95debug">动态规划应该如何debug</a></li></ul></li><li><a href="#%E4%BA%8C%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98%E8%A7%A3%E6%9E%90">二、典型例题解析</a><ul><li><a href="#509%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0">509、斐波那契数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li><li><a href="#%E8%A1%A5%E5%85%85">补充</a></li></ul></li><li><a href="#70%E7%88%AC%E6%A5%BC%E6%A2%AF">70、爬楼梯</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-1">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-1">实现</a></li></ul></li><li><a href="#746%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF">746、使用最小花费爬楼梯</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-2">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-2">实现</a></li><li><a href="#%E6%89%A9%E5%B1%95">扩展</a></li></ul></li><li><a href="#62%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">62、不同路径</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-3">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a><ul><li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">深度优先搜索</a></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li><li><a href="#%E6%95%B0%E8%AE%BA">数论</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0-3">实现</a><ul><li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-1">深度优先搜索</a></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1">动态规划</a></li><li><a href="#%E6%95%B0%E8%AE%BA-1">数论</a></li></ul></li></ul></li><li><a href="#63%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84ii">63、不同路径<strong>II</strong></a><ul><li><a href="#%E9%A2%98%E7%9B%AE-4">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-4">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-4">实现</a></li></ul></li><li><a href="#343%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86">343、整数拆分</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-5">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-5">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-5">实现</a></li></ul></li><li><a href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">96 不同的二叉搜索树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-6">题目</a></li><li><a href="#%E6%80%9D%E8%B7%AF-6">思路</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-6">实现</a></li></ul></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h2 id="一、动态规划理论基础"><a href="#一、动态规划理论基础" class="headerlink" title="一、动态规划理论基础"></a>一、动态规划理论基础</h2><h3 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h3><p>动态规划（Dynamic Programming)，简称DP</p><p>如果某一问题有很多重叠子问题，使用动态规划是最有效的 &#x3D;&gt; 所以动态规划中每一个状态是由<strong>上一个状态推导</strong>出来的（这一点区分于贪心，贪心没有状态推导，而是从<strong>局部直接选最优</strong>）</p><h3 id="动态规划解题步骤"><a href="#动态规划解题步骤" class="headerlink" title="动态规划解题步骤"></a>动态规划解题步骤</h3><p>动归题目，状态转移公式（递推公式）是很重要，但动归不仅仅只有递推公式</p><p><strong>动归掌握五部曲</strong></p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><blockquote><p>为什么要先确定递推公式，然后再考虑初始化？</p><p>因为一些情况是递推公式决定了dp数组要如何初始化</p></blockquote><h3 id="动态规划应该如何debug"><a href="#动态规划应该如何debug" class="headerlink" title="动态规划应该如何debug"></a>动态规划应该如何debug</h3><p>写动归题目，代码出问题很正常！</p><ul><li><strong>找问题最好方式就是把dp数组打印出来，看看究竟是不是按照自己的思路推导的</strong></li><li><strong>做动归题目，写代码之前一定要把状态转移在dp数组上的具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong></li></ul><p>&#x3D;&gt; 然后再写代码，如果代码没通过就打印dp数组，看看和自己预先推导的哪里不一样</p><ul><li>如果打印出来和自己预先模拟推导的是一样的，那么就是自己的递推公式、初始化或者遍历顺序有问题</li><li>如果打印出来和自己预先模拟推导的不一样，那就是代码实现细节有问题</li></ul><h2 id="二、典型例题解析"><a href="#二、典型例题解析" class="headerlink" title="二、典型例题解析"></a>二、典型例题解析</h2><h3 id="509、斐波那契数"><a href="#509、斐波那契数" class="headerlink" title="509、斐波那契数"></a>509、斐波那契数</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p><pre><code class="markdown">斐波那契数，通常⽤ F(n) 表⽰，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后⾯的每⼀项数字都是前⾯两项数字的和。也就是：F(0) = 0，F(1) = 1,F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1，给你n ，请计算 F(n) 。⽰例 1： 输⼊：2输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1⽰例 2：输⼊：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2⽰例 3：输⼊：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3提⽰：- 0 &lt;= n &lt;= 30</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>动态规划</strong></p><p>动归五部曲：<br>    这里我们需要一个一维数组来保存递推的解雇</p><ol><li><p>确定dp数组以及下标的含义</p><ul><li><code>dp[i]</code>定义：第i个数的斐波那契数值是<code>dp[i]</code></li></ul></li><li><p>确定递推关系</p><ul><li>状态转移方程（来自于题目）：<code>dp[i] = dp[i - 1] + dp[i - 2]</code></li></ul></li><li><p>dp数组初始化</p><pre><code class="java">// 题目也将如何初始化直接给出了dp[0] = 0;dp[1] = 1;</code></pre></li><li><p>确定遍历顺序</p><p>从递推关系<code>dp[i] = dp[i - 1] + dp[i - 2]</code>可以看出，<code>dp[i]</code>是依赖<code>dp[i - 1]</code>和<code>dp[i - 2</code>]，那么遍历的顺序一定是从前往后遍历的</p></li><li><p>举例推导dp数组</p><p>根据递推公式<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，当N&#x3D;10的时候，dp数组应该是：<code>0 1 1 2 3 5 8 13 21 34 55</code></p><p>如果代码写出来发现结果不对，就把dp数组打印出来看看和我们推导的数列是否一致</p></li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int fib(int n) &#123;        if(n &lt;= 1) return n;        int[] dp = new int[n + 1];        dp[0] = 0;        dp[1] = 1;        for(int i = 2;i &lt;= n;++i) &#123;            dp[i] = dp[i - 1] + dp[i - 2];        &#125;        return dp[n];    &#125;&#125;</code></pre><p>&#x3D;&gt; 我们只需要维护两个数值就可以了，不需要记录整个序列</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int fib(int n) &#123;        if(n &lt;= 1) return n;        int[] dp = new int[2];        dp[0] = 0;        dp[1] = 1;        for(int i = 2;i &lt;= n;++i) &#123;            int sum = dp[0] + dp[1];            dp[0] = dp[1];            dp[1] = sum;        &#125;        return dp[1];    &#125;&#125;</code></pre><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>递归解法</strong></p><pre><code class="java">// 时间复杂度：O(2^n)// 空间复杂度：O(n)class Solution &#123;    public int fib(int n) &#123;        if(n &lt; 2) return n;        return fib(n - 1) + fib(n - 2);    &#125;&#125;</code></pre><h3 id="70、爬楼梯"><a href="#70、爬楼梯" class="headerlink" title="70、爬楼梯"></a>70、爬楼梯</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p><pre><code class="markdown">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的⽅法可以爬到楼顶呢？注意：给定 n 是⼀个正整数。⽰例 1： 输⼊： 2输出： 2解释： 有两种⽅法可以爬到楼顶。            1 阶 + 1 阶            2 阶⽰例 2： 输⼊： 3输出： 3解释： 有三种⽅法可以爬到楼顶。            1 阶 + 1 阶 + 1 阶            1 阶 + 2 阶            2 阶 + 1 阶</code></pre><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><blockquote><p>模拟一遍过程</p><p>爬到第一层楼梯有一种方法，爬到第二层楼梯有两种方法<br>那么第一层楼梯再跨两步就到第三层，第二层楼梯再跨一步就到第三层 &#x3D;&gt; 第三层楼梯的状态可以由到第二层楼梯和到第一层楼梯状态推导出来 &#x3D;&gt; 动态规划</p></blockquote><p><strong>动态规划五部曲</strong></p><p>定义一个一维数组来记录不同楼层的状态</p><ul><li><p>确定dp数组以及下标的含义</p><ul><li><code>dp[i]</code>：爬到第i层楼梯，有<code>dp[i]</code>种方法</li></ul></li><li><p>确定递推公式</p><p>从dp[i]的定义可以看出，dp[i]可以由两个方向推出</p><ul><li>首先是dp[i - 1]，上i-1层楼梯，有dp[i-1]种方法，那么再跳一个台阶就是dp[i]</li><li>还有就是dp[i - 2]，上i-2层楼梯，有dp[i-2]种方法，那么再跳一个台阶就是dp[i]</li></ul><p>&#x3D;&gt; <code>dp[i] = dp[i - 1] + dp[i - 2]</code></p></li><li><p>dp数组初始化</p><blockquote><p>回顾⼀下dp[i]的定义：<strong>爬到第i层楼梯，有dp[i]中⽅法</strong></p><p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。</p><p>例如强⾏安慰⾃⼰爬到第0层，也有⼀种⽅法，什么都不做也就是⼀种⽅法即：dp[0] &#x3D; 1，相当于直接站在楼顶。 但总有点牵强的成分。</p><p>那还这么理解呢：我就认为跑到第0层，⽅法就是0啊，⼀步只能⾛⼀个台阶或者两个台阶，然⽽楼层是0，直接站楼顶上了，就是不⽤⽅法，dp[0]就应该是0。</p><p>其实这么争论下去没有意义，⼤部分解释说<strong>dp[0]<strong>应该为</strong>1</strong>的理由其实是因为<strong>dp[0]&#x3D;1</strong>的话在递推的过程中<strong>i</strong>从<strong>2</strong>开始遍历本题就能过，然后就往结果上靠去解释<strong>dp[0] &#x3D; 1</strong>。 </p><p>从dp数组定义的⾓度上来说，dp[0] &#x3D; 0 也能说得通。</p><p>需要注意的是：题⽬中说了n是⼀个正整数，题⽬根本就没说n有为0的情况 &#x3D;&gt; **本题不应该讨论dp[0]的初始化</p></blockquote><ul><li><code>dp[1] = 1,dp[2] = 2</code></li></ul></li><li><p>确定遍历顺序<br>从递推公式<code>dp[i] = dp[i - 1] + dp[i - 2]</code>可以看出，遍历顺序一定是从前往后遍历的</p></li><li><p>举例推导dp数组</p><p>当n&#x3D;5时，dp table（dp数组）应该是这样的<br>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%88%AA%E5%B1%8F2022-12-05">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/截屏2022-12-05</a> 20.36.50.png)</p><p>如果代码出问题了，就把dp table打印出来，看看究竟是不是和自己推导的一样</p><blockquote><p>仔细观察，这就是斐波那契数列，唯一的区别就是没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义</p></blockquote></li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int climbStairs(int n) &#123;        if(n &lt;= 1) return n;        int[] dp = new int[n + 1];        dp[1] = 1;        dp[2] = 2;        for(int i = 3;i &lt;= n;++i) &#123;            dp[i] = dp[i - 1] + dp[i - 2];        &#125;        return dp[n];    &#125;&#125;</code></pre><p>当然代码可以优化一下空间复杂度</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int climbStairs(int n) &#123;        if(n &lt;= 1) return n;        int[] dp = new int[3];        dp[1] = 1;        dp[2] = 2;        for(int i = 3;i &lt;= n;++i) &#123;            int sum = dp[1] + dp[2];            dp[1] = dp[2];            dp[2] = sum;        &#125;        return dp[2];    &#125;&#125;</code></pre><h3 id="746、使用最小花费爬楼梯"><a href="#746、使用最小花费爬楼梯" class="headerlink" title="746、使用最小花费爬楼梯"></a>746、使用最小花费爬楼梯</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>题⽬链接：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">https://leetcode-cn.com/problems/min-cost-climbing-stairs/</a></p><pre><code class="markdown">数组的每个下标作为⼀个阶梯，第 i 个阶梯对应着⼀个⾮负数的体⼒花费值cost[i]（下标从0 开始）。每当你爬上⼀个阶梯你都要花费对应的体⼒值，⼀旦⽀付了相应的体⼒值，你就可以选择向上爬⼀个阶梯或者爬两个阶梯。请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。⽰例 1：输⼊：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后⾛两步即可到阶梯顶，⼀共花费 15 。⽰例 2：输⼊：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费⽅式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，⼀共花费 6 。提⽰：- cost 的长度范围是 [2, 1000]。- cost[i] 将会是⼀个整型数据，范围为 [0, 999] </code></pre><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><strong>注意题目描述：每当你爬上⼀个阶梯你都要花费对应的体⼒值，⼀旦⽀付了相应的体⼒值，你就可以选择向上爬⼀个阶梯或者爬两个阶梯</strong></p><ol><li><p>确认dp数组以及下标的含义、</p><p>使用一个一维数组dp[i]来记录状态：</p><p><code>dp[i]</code> &#x3D;&gt; 到达第i个台阶所花费的最少体力为dp[i]（注意这里认为是第一步一定是要花费）</p></li><li><p>确定递推公式</p><p>可以有两个途径得到<code>dp[i]</code>，一个是<code>dp[i - 1]</code>，一个是<code>dp[i - 2]</code></p><p>选择最小的，所以<code>dp[i] = Math.min(dp[i - 1],dp[i - 2]) + cost[i]</code></p><blockquote><p>注意这⾥为什么是加<code>cost[i]</code>，⽽不是<code>cost[i-1]</code>,<code>cost[i-2]</code>之类的，因为题⽬中说了：每当你爬上⼀个阶梯你都要花费对应的体⼒值</p></blockquote></li><li><p>dp数组初始化</p><p>根据dp数组的定义，dp数组初始化其实是⽐较难的，因为不可能初始化为第i台阶所花费的最少体⼒ </p><p>回归递归公式，<strong>dp[i]由dp[i-1]，dp[i-2]推出</strong>，既然初始化所有的dp[i]是不可能的， 那么**只初始化dp[0]和dp[1]**就够了，其他的最终都是dp[0]、dp[1]推出</p><pre><code class="java">int[] dp = new int[cost.length]dp[0] = cost[0];dp[1] = cost[1];</code></pre></li><li><p>确定遍历顺序</p><p>模拟台阶，⽽且dp[i]又dp[i-1]dp[i-2]推出，所以是<strong>从前到后遍历cost数组</strong>就可以了。</p></li><li><p>举例推导dp数组</p><p>拿示例2：cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟⼀下dp数组的状态变化</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221208210343.png"></p></li></ol><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n) // 空间复杂度：O(n)class Solution &#123;    public int minCostClimbingStairs(int[] cost) &#123;        int[] dp = new int[cost.length];        dp[0] = cost[0];        dp[1] = cost[1];        for(int i = 2;i &lt; cost.length;++i) &#123;            dp[i] = Math.min(dp[i - 1],dp[i - 2]) + cost[i];        &#125;        // 注意最后一步理解为不用花费        return Math.min(dp[cost.length - 1],dp[cost.length - 2]);    &#125;&#125;</code></pre><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>定义<code>dp[i]</code>为:第⼀步是不花费体⼒，最后⼀步是花费体⼒的</p><p>Java代码：</p><pre><code class="java">class Solution &#123;    public int minCostClimbingStairs(int[] cost) &#123;        int[] dp = new int[cost.length + 1];        dp[0] = 0;        dp[1] = 0;        for(int i = 2;i &lt;= cost.length;++i) &#123;            dp[i] = Math.min(dp[i - 1] + cost[i - 1],dp[i - 2] + cost[i - 2]);        &#125;        return dp[cost.length];    &#125;&#125;</code></pre><h3 id="62、不同路径"><a href="#62、不同路径" class="headerlink" title="62、不同路径"></a>62、不同路径</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>题⽬链接：<a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a> </p><p>⼀个机器⼈位于⼀个 m x n ⽹格的左上角 （起始点在下图中标记为 “Start” ）。 机器⼈每次只能向下或者向右移动⼀步。机器⼈试图达到⽹格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？</p><p>示例一：</p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28</p><p>示例二：<br>输⼊：m &#x3D; 2, n &#x3D; 3<br>输出：3 </p><p>提⽰： </p><ul><li>1 &lt;&#x3D; m, n &lt;&#x3D; 100 </li><li>题⽬数据保证答案⼩于等于 2 * 10^9</li></ul><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><h5 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h5><p>题目最直观的想法就是⽤图论⾥的<strong>深搜</strong>，来枚举出来有多少种路径</p><p>注意题⽬中说机器⼈每次只能向下或者向右移动⼀步，那么其实机器人<strong>走过的路径可以抽象为⼀颗⼆叉树，⽽叶⼦节点就是终点</strong></p><p>举例：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221209152808.png"></p><p>此时问题就可以转化为<strong>求⼆叉树叶⼦节点的个数</strong></p><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>机器人从（0,0）位置出发，到（m - 1，n - 1）</p><p>动态规划五部曲：</p><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p><code>dp[i][j]</code>：表⽰从<code>(0,0)</code>出发，到<code>(i,j)</code> 有<code>dp[i][j]</code>条不同的路径</p></li><li><p>确定递推公式</p><p>要求<code>dp[i][j]</code>，只能有两个⽅向来推导出来，即<code>dp[i - 1][j] </code>和<code> dp[i][j - 1]</code>。<br>回顾⼀下 <code>dp[i - 1][j] </code>表示什么，是从(0, 0)的位置到(i - 1, j)有⼏条路径，<code>dp[i][j - 1]</code>同 理。<br>那么很⾃然，**<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>**，因为<code>dp[i][j]</code>只有这两个⽅向过来</p></li><li><p>dp数组初始化</p><p><code>dp[i][0]</code>⼀定都是1，因为从(0, 0)的位置到(i, 0)的路径只有⼀条，那么 <code>dp[0][j]</code>也同理</p><pre><code class="java">// 初始化代码for (int i = 0; i &lt; m; i++) dp[i][0] = 1;for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</code></pre></li><li><p>确定遍历顺序<br>观察递推公式：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历即可</p></li><li><p>举例推导dp数组</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221209154253.png"></p></li></ol><h5 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h5><p>在这个图中，可以看出⼀共m，n的话，⽆论怎么⾛，⾛到终点都需要 m + n - 2 步<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221209152808.png"></p><p>在这m + n - 2 步中，⼀定有 m - 1 步是要向下⾛的，不⽤管什么时候向下⾛</p><p>走法数：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221209154635.png"></p><p>求组合的时候，要<strong>防⽌两个int相乘溢出</strong>！ 所以不能把算式的分⼦都算出来，分母都算出来再做除法</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><h5 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h5><p>Java代码：</p><pre><code class="java">class Solution &#123;    public int uniquePaths(int m, int n) &#123;        return dfs(1, 1, m, n);    &#125;    public int dfs(int i, int j, int m, int n) &#123;        if (i &gt; m || j &gt; n) return 0;  // 越界        if (i == m &amp;&amp; j == n) return 1;  // 找到了一种方法，相当于找到了叶子节点        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);    &#125;&#125;// ===&gt; 超时/* 分析⼀下时间复杂度，这个深搜的算法，其实就是要遍历整个⼆叉树。这颗树的深度其实就是m+n-1（深度按从1开始计算）。那⼆叉树的节点个数就是 2^(m + n - 1) - 1。可以理解深搜的算法就是遍历了整个满⼆叉树（其实没有遍历整个满⼆叉树，只是近似⽽已） =&gt; 上⾯深搜代码的时间复杂度为O(2^(m + n - 1) - 1)，可以看出，这是指数级别的时间复杂度，是⾮常⼤的。*/</code></pre><h5 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h5><p>Java代码</p><pre><code class="java">// 时间复杂度：O(m * n)// 空间复杂度：O(m * n)class Solution &#123;    public int uniquePaths(int m, int n) &#123;        int[][] dp = new int[m][n];        for(int i = 0;i &lt; m;++i) dp[i][0] = 1;        for(int j = 0;j &lt; n;++j) dp[0][j] = 1;        for(int i = 1;i &lt; m;++i) &#123;            for(int j = 1;j &lt; n;++j) &#123;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];            &#125;        &#125;        return dp[m - 1][n - 1];    &#125;&#125;</code></pre><h5 id="数论-1"><a href="#数论-1" class="headerlink" title="数论"></a>数论</h5><p>Java代码</p><pre><code class="java">// 时间复杂度：O(m )// 空间复杂度：O(1)class Solution &#123;    public int uniquePaths(int m, int n) &#123;        long numerator = 1;// 分子        int denominator = m - 1; // 分母        int count = m - 1;        int t = m + n - 2;        while(count-- &gt; 0) &#123;            numerator *= (t--);            while(denominator != 0 &amp;&amp; numerator % denominator == 0) &#123;                numerator /= denominator;                denominator--;            &#125;         &#125;        return (int)numerator;    &#125;&#125;</code></pre><h3 id="63、不同路径II"><a href="#63、不同路径II" class="headerlink" title="63、不同路径II"></a>63、不同路径<strong>II</strong></h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii/">https://leetcode-cn.com/problems/unique-paths-ii/</a></p><p>⼀个机器⼈位于⼀个 m x n ⽹格的左上⾓ （起始点在下图中标记为“Start” ）。 机器⼈每次只能向下或者向右移动⼀步。机器⼈试图达到⽹格的右下⾓（在下图中标记为 “Finish”）。 现在考虑⽹格中有障碍物。那么从左上⾓到右下⾓将会有多少条不同的路径？</p><p>示例1：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p><p>输⼊：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2<br>解释： 3x3 ⽹格的正中间有⼀个障碍物。<br>        从左上⾓到右下⾓⼀共有 2 条不同的路径</p><pre><code>    1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下    1.  2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><p>示例2：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt="img"></p><p>输⼊：obstacleGrid &#x3D; [[0,1],[0,0]]<br>输出：1</p><p>提示: </p><ul><li>m &#x3D;&#x3D; obstacleGrid.length </li><li>n &#x3D;&#x3D; obstacleGrid[i].length </li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 100 </li><li>obstacleGrid[i][j] 为 0 或 1</li></ul><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>62、不同路径</strong>我们已经详细分析了没有障碍的情况，有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了</p><p>动归五部曲</p><ol><li><p>确定dp数组（dp table）以及下标的含义<br><code>dp[i][j] </code>：表⽰从<code>(0,0)</code>出发，到<code>(i, j)</code> 有<code>dp[i][j]</code>条不同的路径</p></li><li><p>确定递推公式<br>   递推公式和<strong>62、不同路径</strong>⼀样，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>。 但这⾥需要注意⼀点，因为有了障碍，<code>(i, j)</code>如果就是障碍的话应该就保持初始状态（初始状态为0）</p></li></ol><pre><code class="java">if (obstacleGrid[i][j] == 0) &#123; // 当(i, j)没有障碍的时候，再推导dp[i][j] dp[i][j] = dp[i - 1][j] + dp[i][j - 1];&#125;</code></pre><ol start="3"><li><p>dp数组初始化<br>在<strong>62、不同路径</strong>不同路径中我们给出如下的初始化：</p><pre><code class="java">// 初始化代码for (int i = 0; i &lt; m; i++) dp[i][0] = 1;for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</code></pre><p>因为从(0, 0)的位置到(i, 0)的路径只有⼀条，所以<code>dp[i][0]</code>⼀定为1，<code>dp[0][j]</code>也同理。 但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是⾛不到的位置了，所以障碍之后的<code>dp[i][0]</code>应该还是初始值0<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221210135849.png"><br>下标(0, j)的初始化情况同理:</p><pre><code class="java">// 初始化代码for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;</code></pre><p>注意代码⾥for循环的终⽌条件，⼀旦遇到<code>obstacleGrid[i][0] == 1</code>的情况就停⽌<code>dp[i][0]</code>的 赋值1的操作，<code>dp[0][j]</code>同理</p></li><li><p>确定遍历顺序<br>从递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1] </code>中可以看出，⼀定是从左到右⼀层⼀层遍历， 这样保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>⼀定是有数值</p><pre><code class="java">for (int i = 1; i &lt; m; i++) &#123;     for (int j = 1; j &lt; n; j++) &#123;         if (obstacleGrid[i][j] == 1) continue;         dp[i][j] = dp[i - 1][j] + dp[i][j - 1];     &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>拿示例1来举例：<br><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p><p>对应的dp table 如图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221212180859.png"></p></li></ol><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度O(n * m) n m 分别为obstacleGrid 长度和宽度// 空间复杂度O(n * m)class Solution &#123;    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;        int m = obstacleGrid.length;        int n = obstacleGrid[0].length;                int[][] dp = new int[m][n];        // 初始化        for(int j = 0;j &lt; n &amp;&amp; obstacleGrid[0][j] == 0;++j) dp[0][j] = 1;        for(int i = 0;i &lt; m &amp;&amp; obstacleGrid[i][0] == 0;++i) dp[i][0] = 1;                for(int i = 1;i &lt; m;++i) &#123;            for(int j = 1;j &lt; n;++j) &#123;                if(obstacleGrid[i][j] == 1) continue;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];            &#125;        &#125;        return dp[m - 1][n - 1];    &#125;&#125;</code></pre><h3 id="343、整数拆分"><a href="#343、整数拆分" class="headerlink" title="343、整数拆分"></a>343、整数拆分</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode.cn/problems/integer-break/">https://leetcode.cn/problems/integer-break/</a></p><p>给定⼀个正整数 n，将其拆分为⾄少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最⼤乘积。 </p><p>示例1:<br>输⼊: 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</p><p>示例 2:<br>输⼊: 10<br>输出: 36<br>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。 </p><p>提示:</p><ul><li>2 &lt;&#x3D; n &lt;&#x3D; 58</li></ul><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>动规五部曲：</p><ol><li><p>确定dp数组(dp table)以及下标的含义<br><code>dp[i]</code>：分析数字i，可以得到最大乘积为<code>dp[i]</code></p></li><li><p>确定递推公式<br>考虑<code>dp[i]</code>的最大乘积如何得到？<br>其实可以从1 遍历到 j，然后存在两种渠道得到<code>dp[i]</code></p><ul><li><code>j * (i - j)</code></li><li><code>j * dp[i - j]</code> &#x3D;&gt; 相当于是拆分<code>i - j</code></li></ul><blockquote><p>j 从1 开始遍历，拆分 j 的情况在遍历 j 的过程中已经计算过了 &#x3D;&gt; j 无需拆分</p></blockquote></li></ol><p>​&#x3D;&gt; <code>dp[i] = Math.max(dp[i],Math.max((i - j) * j,dp[i - j] * j))</code></p><ol start="3"><li><p>dp的初始化</p><blockquote><p>有的题解⾥会给出<code>dp[0] = 1，dp[1] = 1</code>的初始化，但解释⽐较牵强，主要还是因为这么初始 化可以把题目过了。 严格从<strong>dp[i]的定义</strong>来说，<strong>dp[0] dp[1] 就不应该初始化</strong>，也就是没有意义的数值。 拆分0和拆分1的最⼤乘积是多少？ 这是⽆解的。</p></blockquote></li></ol><p>​&#x3D;&gt; 初始化：dp[2] &#x3D; 1</p><ol start="4"><li><p>确定遍历顺序<br>根据递推公式： <code>dp[i] = Math.max(dp[i],Math.max((i - j) * j,dp[i - j] * j))</code><br><code>dp[i] </code>是依靠 <code>dp[i - j]</code>的状态，所以遍历 i ⼀定是从前向后遍历，先有<code>dp[i - j]</code>再有<code>dp[i]</code>。 枚举 j 的时候，是从1开始的。i 是从 3 开始，这样<code>dp[i - j]</code>就是<code>dp[2]</code>正好可以通过我们初始化 的数值求出来</p><pre><code class="java">for (int i = 3; i &lt;= n ; i++) &#123;     for (int j = 1; j &lt; i - 1; j++) &#123;         dp[i] = Math.max(dp[i], max((i - j) * j, dp[i - j] * j));     &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>当<code>n = 10</code>时，dp数组：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221212183342.png"></p></li></ol><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n^2)// 空间复杂度：O(n)class Solution &#123;    public int integerBreak(int n) &#123;        int[] dp = new int[n + 1];        dp[2] = 1;        for(int i = 3;i &lt;= n;++i) &#123;            for(int j = 1;j &lt; i - 1;++j) &#123;                dp[i] = Math.max(dp[i],Math.max((i - j) * j,dp[i - j] * j));            &#125;        &#125;        return dp[n];    &#125;&#125;</code></pre><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96 不同的二叉搜索树"></a>96 不同的二叉搜索树</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode.cn/problems/unique-binary-search-trees/">https://leetcode.cn/problems/unique-binary-search-trees/</a></p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数</p><p>示例1 ：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p><p>输入：n &#x3D; 3<br>输出：5</p><p>示例2：<br>输入：n &#x3D; 1<br>输出：1</p><p>提示：</p><ul><li>1 &lt;&#x3D; n &lt;&#x3D; 19</li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>了解了⼆叉搜索树之后，先举⼏个例⼦，画画图，看看有没有什么规律</p><ul><li><p>n为1的时候有⼀棵树，n为2有两棵树<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221212185918.png"></p></li><li><p>n为3的时候<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221212190034.png"></p><ul><li><p>当1为头结点的时候，其右子树有两个节点，这两个节点的布局和 n 为2的时候两棵树的布局是⼀样的</p><blockquote><p>要求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异</p></blockquote></li><li><p>当3为头结点的时候，其左子树有两个节点，这两个节点的布局和n为2的时候两棵树的布局是⼀样的</p></li><li><p>当2位头结点的时候，其左右⼦树都只有⼀个节点，这两个节点布局和n为1的时候只有⼀棵树的 布局是⼀样的</p></li></ul></li></ul><p>&#x3D;&gt;</p><ul><li><p><code>dp[3]</code> &#x3D;&gt; 元素1为头节点搜索树的数量  + 元素2为头节点搜索树的数量 + 元素3为头节点搜索树的数量</p><ul><li>元素1为头节点搜索树的数量 &#x3D;&gt; 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量 &#x3D;&gt; dp[2] * dp[0]</li><li>元素2为头节点搜索树的数量 &#x3D;&gt; 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量 &#x3D;&gt; dp[1] * dp[1]</li><li>元素3为头节点搜索树的数量 &#x3D;&gt; 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量 &#x3D;&gt; dp[0] * dp[2]</li></ul><p>&#x3D;&gt; dp[3] &#x3D; dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221212191758.png"></p></li></ul><p>动规五部曲</p><ol><li><p>确定dp数组(dp table)以及下标的含义<br><code>dp[i]</code>： 1 到 i 为节点组成的⼆叉搜索树的个数为<code>dp[i]</code>。</p></li><li><p>确定递推公式<br><code>dp[i] += dp[以j为头结点左⼦树节点数量] * dp[以j为头结点右⼦树节点数量] </code><br> j 相当于是头结点的元素，从1遍历到 i 为止。<br>&#x3D;&gt; 递推公式：<code>dp[i] += dp[j - 1] * dp[i - j]</code>; ，j-1 为 j 为头结点左⼦树节点数量，i - j 为以 j 为 头结点右⼦树节点数量</p></li><li><p>dp数组初始化<br>初始化只需要初始化dp[0]即可，递推的基础都是dp[0]</p><ul><li>从定义上来讲，空节点也是⼀颗⼆叉树，也是⼀颗⼆叉搜索树</li><li>从递推公式上来讲，dp[以j为头结点左⼦树节点数量] * dp[以j为头结点右⼦树节点数量] 中 以j为头结点左⼦树节点数量为0，也需要dp[以j为头结点左⼦树节点数量] &#x3D; 1， 否则乘法的结果就都变成0了</li></ul><p>&#x3D;&gt; <code>dp[0] = 1</code></p></li><li><p>确定遍历顺序<br>首先一定是遍历节点数，从递推公式<code>dp[i] += dp[j - 1] * dp[i - j]</code>可以看出，节点数为 i 的状态是依赖 i 之前节点数的状态 &#x3D;&gt; 遍历 i 里面每一个书作为头节点的状态，用 j 来遍历</p><pre><code class="java">for (int i = 1; i &lt;= n; i++) &#123;     for (int j = 1; j &lt;= i; j++) &#123;         dp[i] += dp[j - 1] * dp[i - j];     &#125;&#125;</code></pre></li><li><p>举例推导dp数组<br>n &#x3D; 5时的dp数组状态：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221212200337.png"></p></li></ol><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度O(n^2)// 空间复杂度O(n)class Solution &#123;    public int numTrees(int n) &#123;        int[] dp = new int[n + 1];        dp[0] = 1;        for(int i = 1;i &lt;= n;++i) &#123;            for(int j = 1;j &lt;= i;++j) &#123;                dp[i] += dp[j - 1] * dp[i - j];            &#125;        &#125;        return dp[n];    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Source汇总随笔</title>
      <link href="/2022/12/12/Source%E6%B1%87%E6%80%BB%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/12/12/Source%E6%B1%87%E6%80%BB%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="作为一名有点憨又爱捣鼓东西的憨憨需要知道的东西"><a href="#作为一名有点憨又爱捣鼓东西的憨憨需要知道的东西" class="headerlink" title="作为一名有点憨又爱捣鼓东西的憨憨需要知道的东西"></a>作为一名有点憨又爱捣鼓东西的憨憨需要知道的东西</h1><blockquote><p>持续更新中……</p><p><strong>author: CodeJuzi(一个Code憨憨)</strong></p></blockquote><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p><ul><li><a href="#%E4%BD%9C%E4%B8%BA%E4%B8%80%E5%90%8D%E6%9C%89%E7%82%B9%E6%86%A8%E5%8F%88%E7%88%B1%E6%8D%A3%E9%BC%93%E4%B8%9C%E8%A5%BF%E7%9A%84%E6%86%A8%E6%86%A8%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%9C%E8%A5%BF">作为一名有点憨又爱捣鼓东西的憨憨需要知道的东西</a><ul><li><a href="#%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99">实用网站</a></li><li><a href="#code%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99">Code必备网站</a></li><li><a href="#%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7">一些实用小工具</a></li><li><a href="#%E7%94%B5%E5%AD%90%E8%B5%84%E6%BA%90%E4%B9%A6%E4%B8%8B%E8%BD%BD">电子资源书下载</a></li><li><a href="#%E5%A5%BD%E7%9C%8B%E7%9A%84%E9%80%97%E6%AF%94%E7%9A%84%E5%9B%BE%E7%89%87%E5%A3%81%E7%BA%B8%E8%A1%A8%E6%83%85%E5%8C%85">好看的、逗比的图片、壁纸、表情包</a></li><li><a href="#%E8%BD%AF%E4%BB%B6">好用的软件推荐</a></li><li><a href="#%E6%89%BE%E5%B7%A5%E4%BD%9C">找工作</a></li><li><a href="#%E5%AD%A6%E4%B9%A0%E5%8E%86%E5%8F%B2%E5%BE%88%E9%87%8D%E8%A6%81">学习历史很重要</a></li><li><a href="#%E4%BC%91%E9%97%B2">休闲</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h2 id="实用网站"><a href="#实用网站" class="headerlink" title="实用网站"></a>实用网站</h2><ul><li><a href="https://lkssite.vip/">lks良心网站推荐</a></li><li><a href="https://zh.wikihow.com/%E9%A6%96%E9%A1%B5">wikiHow：你可以信赖的万事指南</a></li><li><a href="https://spcqwserdvymm.com.vika.cn/share/shryNwH3HRgvzMTaZVAGx/fodkuzz5eaw0w">🔔 Efficiency (vika.cn)</a></li></ul><h2 id="Code必备网站"><a href="#Code必备网站" class="headerlink" title="Code必备网站"></a>Code必备网站</h2><ul><li><a href="https://kaifa.baidu.com/">开发者搜索-Beta-让技术搜索更简单高效 (baidu.com)</a></li><li><a href="https://stackoverflow.com/">Stack Overflow - Where Developers Learn, Share, &amp; Build Careers</a></li><li><a href="https://www.oschina.net/">OSCHINA - 中文开源技术交流社区</a></li><li><a href="https://github.com/">GitHub: Let’s build from here · GitHub</a></li><li><a href="https://gitee.com/enterprises">Gitee 企业版 - 企业级 DevOps 研发效能平台</a></li><li><a href="https://www.cnblogs.com/">博客园 - 开发者的网上家园 (cnblogs.com)</a></li><li><a href="https://juejin.cn/">稀土掘金 (juejin.cn)</a></li><li><a href="https://r2coding.com/#/README">Road To Coding</a></li><li><a href="https://www.code-nav.cn/">编程导航 - 发现优质编程资源 (code-nav.cn)</a></li></ul><h2 id="一些实用小工具"><a href="#一些实用小工具" class="headerlink" title="一些实用小工具"></a>一些实用小工具</h2><ul><li><a href="https://www.ilovepdf.com/">iLovePDF | Online PDF tools for PDF lovers</a></li><li><a href="https://c.runoob.com/front-end/53/">JSON 在线解析 | 菜鸟工具 (runoob.com)</a></li><li><a href="https://tool.oschina.net/">在线工具 —— OSCHINA.NET社区</a></li><li><a href="https://www.toolzl.com/">在线工具资料箱</a></li><li><a href="https://www.qijishow.com/">奇迹秀</a></li><li><a href="https://www.iamwawa.cn/">蛙蛙工具</a></li><li><a href="https://jingzhunyun.com/">精准云工具</a></li><li><a href="https://tools.miku.ac/">MikuTools-工具集合</a></li><li><a href="https://tool.lu/">在线工具</a></li><li><a href="https://www.iloveimg.com/zh-cn">iLoveIMG</a></li><li><a href="https://www.alltoall.net/">在线格式转换 ALL TO ALL</a></li></ul><h2 id="电子资源书下载"><a href="#电子资源书下载" class="headerlink" title="电子资源书下载"></a>电子资源书下载</h2><ul><li><p>中文书：鸠摩搜书 <a href="https://www.jiumodiary.com/">Jiumo Search 鸠摩搜索 - 文档搜索引擎</a></p></li><li><p>如果鸠摩上显示“图书馆联盟”，就可以淘宝找pdf电子书贩子买 3-5块一本。</p></li><li><p>中英文书、论文：<a href="https://libgen.unblockit.nz/">Library Genesis</a></p></li><li><p>古籍文言文：中国哲学书电子化计划经史子集都有，这个不能下载，但能检索 <a href="https://ctext.org/zhs">https://ctext.org/zhs</a></p></li><li><p>Zlibrary 教材多，可以输入句子搜索。但最近被美国端掉了。<br>镜像网站还能用：<a href="https://www.ooopn.com/tool/zlibrary/?source=timeline&dt_platform=wechat_friends&dt_dapp=1">Z-Library 镜像 - 小白工具箱</a></p><p>更多的离线下载资源：</p><ul><li><a href="https://www.aliyundrive.com/s/9tLs9mhbpF3">Z-library的9.29离线版种子+书目</a></li><li><a href="https://www.aliyundrive.com/s/PZcKvCqCnzn">Z-Library-All书种</a></li><li><a href="https://www.aliyundrive.com/s/KMBUF47M2ab">zlibrary电子书10月31号整理</a></li><li><a href="https://www.aliyundrive.com/s/a3Tgi7YFu6J">Z-library网站9月29日离线版种子+书目【约2300万册】</a></li></ul></li></ul><h2 id="好看的、逗比的图片、壁纸、表情包"><a href="#好看的、逗比的图片、壁纸、表情包" class="headerlink" title="好看的、逗比的图片、壁纸、表情包"></a>好看的、逗比的图片、壁纸、表情包</h2><ul><li><a href="https://wallhaven.cc/">Awesome Wallpapers - wallhaven.cc</a></li><li><a href="https://pixabay.com/zh/">免费正版高清图片素材库 超过2.7百万张优质图片和视频素材可供免费使用和下载 - Pixabay</a></li><li><a href="https://www.dbbqb.com/">逗比拯救世界–专业的表情包搜索网站 (dbbqb.com)</a></li></ul><h2 id="好用的软件推荐"><a href="#好用的软件推荐" class="headerlink" title="好用的软件推荐"></a>好用的软件推荐</h2><ul><li><a href="https://www.u.tools/">uTools官网 - 新一代效率工具平台</a></li><li><a href="https://steampp.net/">Watt Toolkit - 瓦特工具箱(Steam++官网) (steampp.net)</a></li><li><a href="https://github.com/quick123official/quick_redis_blog/">Redis可视化工具 QuickRedis</a></li><li><a href="https://dbeaver.io/">DBeaver Community | Free Universal Database Tool</a></li><li><a href="https://www.typoraio.cn/">Typora 官方中文站 (typoraio.cn)</a></li><li><a href="https://obsidian.md/">Obsidian</a></li><li><a href="https://www.leawo.com/pro/video-converter-ultimate.html">Leawo Video Converter Ultimate - Total sulution for DVD and video conversions.</a></li><li><a href="https://obsproject.com/">Open Broadcaster Software | OBS (obsproject.com)</a></li><li><a href="https://xmind.cn/">XMind</a></li></ul><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><ul><li><a href="https://www.nowcoder.com/">牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网 (nowcoder.com)</a></li><li><a href="https://leetcode.cn/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></li></ul><h2 id="学习历史很重要"><a href="#学习历史很重要" class="headerlink" title="学习历史很重要"></a>学习历史很重要</h2><ul><li><a href="https://www.allhistory.com/">全历史 (allhistory.com)</a></li></ul><h2 id="休闲"><a href="#休闲" class="headerlink" title="休闲"></a>休闲</h2><ul><li><a href="https://theuselessweb.com/">Useless Web</a></li><li><a href="https://if.caiyunai.com/">人工智障写作</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Source </tag>
            
            <tag> essays </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架铺垫知识</title>
      <link href="/2022/12/09/Django%E6%A1%86%E6%9E%B6%E9%93%BA%E5%9E%AB%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/12/09/Django%E6%A1%86%E6%9E%B6%E9%93%BA%E5%9E%AB%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#django%E6%A1%86%E6%9E%B6%E9%93%BA%E5%9E%AB%E7%9F%A5%E8%AF%86">Django框架铺垫知识</a><ul><li><a href="#django-mtv%E5%92%8Cmvc%E7%9A%84%E5%8C%BA%E5%88%AB">Django MTV和MVC的区别</a><ul><li><a href="#1mvc%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">1、MVC设计模式</a></li><li><a href="#2mtv%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">2、MTV设计模式</a></li></ul></li><li><a href="#django-orm%E6%A8%A1%E5%9D%97">Django ORM模块</a><ul><li><a href="#1%E4%BB%80%E4%B9%88%E6%98%AForm">1、什么是ORM</a></li><li><a href="#2django%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E8%A1%A8">2、Django中定义数据表</a><ul><li><a href="#1%E6%A8%A1%E5%9E%8B%E7%B1%BB">1）模型类</a></li><li><a href="#2-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E8%A1%A8">2) 定义数据表</a></li></ul></li><li><a href="#3orm%E7%AE%A1%E7%90%86%E5%99%A8%E5%AF%B9%E8%B1%A1">3、ORM管理器对象</a></li><li><a href="#4orm%E4%BC%98%E5%8A%BF%E4%B8%8E%E4%B8%8D%E8%B6%B3">4、ORM优势与不足</a></li></ul></li><li><a href="#django-auth%E5%BA%94%E7%94%A8%E6%A8%A1%E6%9D%BF">Django auth应用模板</a><ul><li><a href="#1django%E7%9A%84auth%E6%A8%A1%E6%9D%BF">1、Django的auth模板</a></li><li><a href="#2auth%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%85%B6%E4%BB%96%E4%BD%9C%E7%94%A8">2、auth应用模块的其他作用</a></li></ul></li><li><a href="#django-admin%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">Django Admin后台管理系统</a></li><li><a href="#django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0">Django视图函数</a><ul><li><a href="#1%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0">1、第一个视图函数</a></li><li><a href="#2%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">2、视图函数执行过程</a></li></ul></li><li><a href="#django%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F">Django模板系统</a><ul><li><a href="#1django%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F">1、Django的模板系统</a></li><li><a href="#2%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%94%E7%94%A8">2、模板系统的应用</a></li></ul></li><li><a href="#url">URL</a><ul><li><a href="#1url%E7%AE%80%E4%BB%8B">1、URL简介</a></li><li><a href="#2url%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3">2、URL语法格式详解</a><ul><li><a href="#1protocol%E5%8D%8F%E8%AE%AE">1)protocol（协议）</a></li><li><a href="#2-hostname%E4%B8%BB%E6%9C%BA%E5%90%8D">2) hostname（主机名）</a></li><li><a href="#3-port%E7%AB%AF%E5%8F%A3%E5%8F%B7">3) port（端口号）</a></li><li><a href="#4-path%E8%B7%AF%E7%94%B1%E5%9C%B0%E5%9D%80">4) path（路由地址）</a></li><li><a href="#5-query-%E6%9F%A5%E8%AF%A2">5) query (查询)</a></li><li><a href="#6-fragment%E4%BF%A1%E6%81%AF%E7%89%87%E6%96%AD">6) fragment（信息片断）</a></li></ul></li></ul></li><li><a href="#django%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F">Django路由系统</a><ul><li><a href="#1django%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8">1、Django路由系统应用</a></li></ul></li><li><a href="#django%E4%B8%AD%E9%97%B4%E4%BB%B6">Django中间件</a><ul><li><a href="#1django%E9%BB%98%E8%AE%A4%E8%87%AA%E5%B8%A6%E4%B8%AD%E9%97%B4%E4%BB%B6">1、Django默认自带中间件</a><ul><li><a href="#1%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E5%93%8D%E5%BA%94%E9%A1%BA%E5%BA%8F">1)中间件的执行和响应顺序</a><ul><li><a href="#1%E5%9C%A8%E8%B0%83%E7%94%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E5%89%8D">1）在调用视图之前</a></li><li><a href="#2%E5%9C%A8%E8%B0%83%E7%94%A8%E8%A7%86%E5%9B%BE%E4%B9%8B%E5%90%8E">2）在调用视图之后</a></li></ul></li></ul></li></ul></li><li><a href="#django-cache%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F">Django Cache缓存系统</a><ul><li><a href="#1%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BD%9C%E7%94%A8">1、缓存技术的作用</a></li><li><a href="#2django%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F">2、Django缓存系统</a></li></ul></li><li><a href="#django%E5%AE%9E%E6%88%98">Django实战</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><span id="more"></span><h1 id="Django框架铺垫知识"><a href="#Django框架铺垫知识" class="headerlink" title="Django框架铺垫知识"></a>Django框架铺垫知识</h1><p>官方文档：<a href="https://docs.djangoproject.com/zh-hans/3.0/">https://docs.djangoproject.com/zh-hans/3.0/</a></p><p><a href="https://docs.djangoproject.com/zh-hans/4.1/">Django 文档 | Django 文档 | Django (djangoproject.com)</a></p><h2 id="Django-MTV和MVC的区别"><a href="#Django-MTV和MVC的区别" class="headerlink" title="Django MTV和MVC的区别"></a>Django MTV和MVC的区别</h2><h3 id="1、MVC设计模式"><a href="#1、MVC设计模式" class="headerlink" title="1、MVC设计模式"></a>1、MVC设计模式</h3><p>MVC(Model-View-Controller)</p><ul><li>Model &#x3D;&gt; 数据存储层，是对数据库的定义和数据的增删改查</li><li>View &#x3D;&gt; 视图层，是系统前端显示部分，负责显示什么和如何进行显示</li><li>Controller &#x3D;&gt; 控制层，负责根据从View层输入的指令来检索Model层的数据，并在该层编写代码产生结果并输出</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/uTools_1670418714693.png"></p><p>MVC设计模式的请求与响应过程：</p><ul><li>用户通过浏览器向服务器发起 request 请求，Controller 层接受请求后，同时向 Model 层和 View 发送指令</li><li>Modle 层根据指令与数据库交互并选择相应业务数据，然后将数据发送给 Controller 层</li><li>View 层接收到 Controller 的指令后，加载用户请求的页面，并将此页面发送给 Controller 层</li><li>Controller 层接收到 Model 层和 View 层的数据后，将它们组织成响应格式发送给浏览器，浏览器通过解析后把页面展示出来</li></ul><p>&#x3D;&gt; MVC三层之间紧密相连，相互独立 &#x3D;&gt; 降低代码之间耦合性，增加模块的可用重用性</p><h3 id="2、MTV设计模式"><a href="#2、MTV设计模式" class="headerlink" title="2、MTV设计模式"></a>2、MTV设计模式</h3><p>MTV(Model-Template-View)</p><ul><li>Model &#x3D;&gt; 数据存储层，处理所有数据相关的业务，和数据库进行交互，并进行数据的增删改查</li><li>Template &#x3D;&gt; 模板层（表现层），具体来处理页面的显示</li><li>View &#x3D;&gt; 业务逻辑层，处理具体的业务逻辑，连通Model层和Template层</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221207211911.png"></p><p>&#x3D;&gt; MTV 设计模式中，用 View 层取代了 Controller 层的位置，用 Template 层取代了原来 View 层的位置</p><p>MTV设计模式的请求与响应过程：</p><ul><li>用户通过浏览器对服务器发起 request 请求，服务器接收请求后，通过 View 的业务逻辑层进行分析，同时向 Model 层和 Template 层发送指令</li><li>Modle 层与数据库进行交互，将数据返回给 View 层</li><li>Template 层接收到指令后，调用相应的模板，并返回给 View 层；</li><li>View 层接收到模板与数据后，首先对模板进行渲染（即将相应的数据赋值给模板），然后组织成响应格式返回给浏览器，浏览器进行解析后并最终呈现给用户</li></ul><p><strong>总结</strong>：MTV 是 MVC 的一种细化，将原来 MVC 中的 V 层拿出来进行分离，视图的显示与如何显示交给 Template 层，而 View 层更专注于实现业务逻辑</p><blockquote><p>实际上，Django 框架存在 Controller 层的，只不过它由框架本身来实现，我们不用关心它 &#x3D;&gt; Django 更关注于M、T 和 V</p></blockquote><h2 id="Django-ORM模块"><a href="#Django-ORM模块" class="headerlink" title="Django ORM模块"></a>Django ORM模块</h2><h3 id="1、什么是ORM"><a href="#1、什么是ORM" class="headerlink" title="1、什么是ORM"></a>1、什么是ORM</h3><p>ORM(Object Realtional Mapping)，对象关系映射，它是一种基于关系型数据的程序技术。</p><p>ORM允许开发者使用类和对象对数据库进行操作 &#x3D;&gt; 大大提高了对数据库的控制，避免直接使用SQL语句对数据库进行操作</p><p>ORM底层主要是通过<strong>映射机制</strong>实现</p><blockquote><p>Web 开发中对数据库的操作是必不可少的，然而每种数据库的操作方式以及用法不尽相同。由于 Django 中 ORM  的存在，<strong>提供了一套操作不同类型数据库的统一方法</strong>，ORM 适配了多种常用的关系型数据库，例如  PostgreSQL、MySQL、Oracle、Sqlite3 等</p><p>ORM与数据库的映射关系如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221207212905.png"></p></blockquote><p>Django将表模型定义为 Model，它需要继承自<code>django.db.models</code>中的Model类(只要是和数据库表相关的操作，都需要继承这个类)，同时ORM对于数据库的增删改查，也提供了一些简单的API，比如F查询，Q查询（<a href="https://blog.csdn.net/zy010101/article/details/120782866%EF%BC%89">https://blog.csdn.net/zy010101/article/details/120782866）</a></p><p>针对于数据中得字段类型，Django ORM都有对应<code>Field</code>来映射，下表为经常用的的字段类型</p><table><thead><tr><th>字段</th><th>说明</th><th>字段属性</th></tr></thead><tbody><tr><td>AutoField</td><td>默认自增主键（Primary_key&#x3D;Ture），Django 默认建立id字段为主键</td><td></td></tr><tr><td>CharField</td><td>字符类型</td><td>Max_length&#x3D;32，<strong>字符长度需要明确</strong></td></tr><tr><td>IntegerField</td><td>整型int</td><td></td></tr><tr><td>DateFiled</td><td>yyyy-MM-dd时间类型</td><td>auto_now&#x3D;True，数据被更新就会更新时间 auto_now_add&#x3D;True，数据第一次添加时产生</td></tr><tr><td>DateTimeFiled</td><td>yyyy-MM-dd HH:mm:ss时间类型</td><td>auto_now&#x3D;True，数据被更新就会更新时间；auto_now_add&#x3D;True，数据第一次添加时产生</td></tr><tr><td>DecimalFiled</td><td>混合精度的小数类型</td><td>max_digits&#x3D;3，限定数字的最大位数(包含小数位)；decimal_places&#x3D;2，限制小数的最大位数</td></tr><tr><td>BooleanFiled</td><td>布尔字段，对应数据库 tinyint 类型数据长度只有1位</td><td>值为True或False</td></tr><tr><td>TextField</td><td>用于大文本</td><td></td></tr></tbody></table><h3 id="2、Django中定义数据表"><a href="#2、Django中定义数据表" class="headerlink" title="2、Django中定义数据表"></a>2、Django中定义数据表</h3><h4 id="1）模型类"><a href="#1）模型类" class="headerlink" title="1）模型类"></a>1）模型类</h4><p>模型类本质上属于一个 Python 类，只不过在 Django 中称之为做模型类 </p><p>它是由 <code>django.db.models.Model</code>  派生出的子类，在 Django 中模型类是数据交互的接口，一个<strong>模型类</strong>代表数据库中的一张<strong>数据表</strong>，模型类中每一个<strong>类属性</strong>都代表数据表中的一个<strong>字段</strong></p><h4 id="2-定义数据表"><a href="#2-定义数据表" class="headerlink" title="2) 定义数据表"></a>2) 定义数据表</h4><p>定义一张用户信息表<code>UserInfo</code>，字段<code>name</code>、<code>password</code></p><pre><code class="python">    from django.db import models    class UserInfo（models.Model）:          name = models.CharFiled(max_length=100)          password = models.CharFiled(max_length=100)</code></pre><p>解析：</p><ul><li>第 1 行，使用 from django.db import models 导入 models 模块；、</li><li>第 2 行，使用 class 关键字对 UserInfo 表进行类定义，并继承了models 模块中的 Model 类；（Model类常用于与数据库交互的数据模型）</li><li>第3、4 行，数据表中的字段 name 和 password 是 UserInfo 类的属性，name 和 password 字段类型都是 CharFiled，字段长度均是100</li></ul><h3 id="3、ORM管理器对象"><a href="#3、ORM管理器对象" class="headerlink" title="3、ORM管理器对象"></a>3、ORM管理器对象</h3><p>操作数据库表方式：</p><ul><li><p>方式一：直接使用类名（数据表名）来插入数据</p><pre><code class="python">UserInfo.objects.create(name=&#39;codejuzi&#39;,password=&#39;aaaaaa&#39;)</code></pre><p><strong><code>objects</code><strong>：每个继承自 <code>models.Model</code> 的模型类，都会有一个 objects 对象被同时继承下来，这个对象就叫做“</strong>管理器对象</strong>”，数据库的增删改查可以用 objects 管理器对象来实现</p></li><li><p>方式二：创建示例对象，调用<code>save()</code>方法</p><pre><code class="python">    user_obj=UserInfo(name=&#39;codejuzi&#39;,password=&#39;aaaaaa&#39;)    user_obj.name=&quot;dogjuzi&quot;    user_obj.save()</code></pre><p>上述代码中 name 属性值会被赋值为“dogjuzi”，最后调用 <code>save()</code>方法保存</p></li></ul><p>ORM的CRUD(create、read、upate、delete)操作常用语句：</p><pre><code class="python">UserInfo.objects.all()#查询表中的所有记录UserInfo.objects.filter(name_contains=&#39;j&#39;)#查询表中name含有“j”的所有记录,被使用较多UserInfo.objects.get(name=&quot;dogjuzi&quot;)#有且只有一个查询结果，如果超出一个或者没有,则抛出异常UserInfo.objects.get(name=&quot;dogjuzi&quot;).delete()#删除名字为dogjuzi的记录UserInfo.objects.get(name=&quot;dogjuzi&quot;).update(name=&#39;juzidog&#39;)#更新数据表的name为juzidog</code></pre><h3 id="4、ORM优势与不足"><a href="#4、ORM优势与不足" class="headerlink" title="4、ORM优势与不足"></a>4、ORM优势与不足</h3><p>优势：</p><ul><li>使用该模块只需要<strong>面向对象编程</strong>，不需要面向数据库编写代码，对数据库的操作转换为对类属性和方法的操作，不用我们编写各种数据库的 SQL 语句</li><li>实现数据模型与数据库的<strong>解耦</strong>，屏蔽了不同数据库操作上的差异化，不在关注不同数据库内部的操作细节，通过简单更改配置就可以实现数据库的更换而无需更改代码</li></ul><p>不足：</p><ul><li>相比直接用 SQL 语句操作数据库会有<strong>性能损失</strong>，因为在映射的过程中 ORM 需要与 SQL 之间进行转换，根据对象的操作转换成 SQL 语句，根据查询结果转换成对象，所以在映射的过程存在性能损失</li></ul><h2 id="Django-auth应用模板"><a href="#Django-auth应用模板" class="headerlink" title="Django auth应用模板"></a>Django auth应用模板</h2><p><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/auth/">django.contrib.auth | Django 文档 | Django (djangoproject.com)</a></p><h3 id="1、Django的auth模板"><a href="#1、Django的auth模板" class="headerlink" title="1、Django的auth模板"></a>1、Django的auth模板</h3><blockquote><p>实现用户的注册、登陆、退出或者注销，到用户的浏览、订阅等功能</p></blockquote><p>新建项目后，Django 就把 auth 模块的所有功能提供给了开发者使用，开发者可以调用相应的接口，实现不同的功能需求</p><p>auth  模块定义了一张名叫 <code>auth_user</code> 的数据表，该表是 auth 模块的内建用户表，开发者调用 auth  模块的相应接口生成此表，<code>auth_user </code>表的字段以及字段类型</p><pre><code class="bash">+--------------+--------------+------+-----+---------+----------------+| Field        | Type         | Null | Key | Default | Extra          |+--------------+--------------+------+-----+---------+----------------+| id           | int(11)      | NO   | PRI | NULL    | auto_increment || password     | varchar(128) | NO   |     | NULL    |                || last_login   | datetime(6)  | YES  |     | NULL    |                || is_superuser | tinyint(1)   | NO   |     | NULL    |                || username     | varchar(150) | NO   | UNI | NULL    |                || first_name   | varchar(30)  | NO   |     | NULL    |                || last_name    | varchar(150) | NO   |     | NULL    |                || email        | varchar(254) | NO   |     | NULL    |                || is_staff     | tinyint(1)   | NO   |     | NULL    |                || is_active    | tinyint(1)   | NO   |     | NULL    |                || date_joined  | datetime(6)  | NO   |     | NULL    |                |+--------------+--------------+------+-----+---------+----------------+11 rows in set (0.02 sec)#auth_user表</code></pre><p>现在新建一张<code>auth_user</code>用户表，并添加一个新用户user</p><ul><li>引入auth模块的User方法</li><li>创建新用户user</li></ul><pre><code class="python">from django.contrib.auth.models import Useruser=User.objects.create_user(username=&#39;codejuzi&#39;,password=&#39;123456&#39;,email=&#39;1741530592@qq.com&#39;)save()#保存数据 user.set_password(password=&#39;12345abc&#39;)#修改密码</code></pre><p>涉及用户概念时会产生用户权限问题，此时需要对用户进行<strong>鉴权</strong>操作 &#x3D;&gt; auth模板提供了标准的权限管理系统，结合Admin后台可以快速建立网站管理系统</p><ul><li>引入鉴权功能</li><li>使用关键字传参的方式传递用户凭证，进行用户鉴权</li></ul><pre><code class="python">from django.contrib.auth import authenticateuser = authenticate(username=&#39;codejuzi&#39;,password=&#39;123456&#39;)</code></pre><h3 id="2、auth应用模块的其他作用"><a href="#2、auth应用模块的其他作用" class="headerlink" title="2、auth应用模块的其他作用"></a>2、auth应用模块的其他作用</h3><p>文档：<a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/auth/">django.contrib.auth | Django 文档 | Django (djangoproject.com)</a></p><p>auth模块还实现一些其他的功能</p><ul><li>用户的登录（login）、退出（logout）功能，封装在 <code>django.contrib.auth</code> 里</li><li>用户权限系统封装在 <code>django.contrib.auth.models.Permission</code> 中 ，可以对用户的权限进行增加、修改、删除</li><li>用户组可以通过 <code>from django.contrib.auth.models.Group</code> 导入后来创建组或者删除组 （类似于Linux下的用户组管理）</li></ul><pre><code class="python">user.user_permission.add(permission)#给某个用户权限的添加权限group = Group.objects.create(name=group_name)#添加新的用户组group.save() #保存新建好的用户组group.delete()#删除用户组</code></pre><h2 id="Django-Admin后台管理系统"><a href="#Django-Admin后台管理系统" class="headerlink" title="Django Admin后台管理系统"></a>Django Admin后台管理系统</h2><p><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/django-admin/">django-admin 和 manage.py | Django 文档 | Django (djangoproject.com)</a></p><p>使用<strong>可视化界面</strong>对后台数据进行操作，减少Shell或者SQL语句的操作不便，提高容错率</p><p>后台管理系统主要是对数据表的存储做专门的管理，减少对多个数据表管理的复杂度和减少重复性操作</p><p><strong>创建超级用户</strong></p><p>在项目目录下开启terminal终端，输入下面的命令：</p><pre><code class="bash">python manage.py createsuperuser</code></pre><p>输入你想要使用的用户名</p><pre><code class="bash">Username: admin</code></pre><p>输入你要想要的邮件地址</p><pre><code class="bash">Email address: admin@example.com</code></pre><p>输入密码。你会被要求输入两次密码，第二次的目的是为了确认第一次输入的确实是你想要的密码</p><pre><code class="bash">Password: **********Password (again): *********Superuser created successfully.</code></pre><p><strong>启动开发服务器</strong></p><p>Django的管理界面默认就是启用的</p><p>如果开发服务器未启用，用以下命令启动它：</p><pre><code class="bash">python manage.py runserver</code></pre><p>打开浏览器访问<code>你的本地域名的&quot;/admin/&quot;</code>目录：比如<code>localhost:8000/admin/</code></p><p><img src="https://docs.djangoproject.com/zh-hans/4.1/_images/admin01.png" alt="Django 管理员登录界面"></p><p><strong>进入管理站点页面</strong></p><p><img src="https://docs.djangoproject.com/zh-hans/4.1/_images/admin02.png" alt="Django admin index page"></p><p>Django 原生的 Admin 管理界面，虽然没有做太多的修饰，但是开发者可以利用 Model Admin 实现个性化定制，比如字段值的过滤功能、表字段展示的排序、搜索功能等</p><p>更多功能参照文档：<a href="https://docs.djangoproject.com/zh-hans/4.1/ref/contrib/admin/">Django 管理站点 | Django 文档 | Django (djangoproject.com)</a></p><h2 id="Django视图函数"><a href="#Django视图函数" class="headerlink" title="Django视图函数"></a>Django视图函数</h2><p><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/http/views/">编写视图 | Django 文档 | Django (djangoproject.com)</a></p><p>视图是 MTV 设计模式中的 V 层 &#x3D;&gt; <strong>实现业务逻辑的关键层</strong>，可以用来连接 M 层与 T 层，起着纽带般的作用</p><h3 id="1、第一个视图函数"><a href="#1、第一个视图函数" class="headerlink" title="1、第一个视图函数"></a>1、第一个视图函数</h3><p>在 Django 中，视图函数是一个 Python 函数或者类，开发者主要通过编写视图函数来实现业务逻辑。视图函数首先接受来自浏览器或者客户端的请求，并最终返回响应，视图函数返回的响应可以是 HTML 文件，也可以是 HTTP 协议中的 303 重定向</p><pre><code class="python">from django.http import HttpResponsedef Hello_my_django(request):        return HttpResponse(&#39;&lt;html&gt;&lt;body&gt;Hello my Django&lt;/body&gt;&lt;/html&gt;&#39;)</code></pre><ol><li><p>HttpResponse视图响应类型</p><p>从 <code>django.http</code> 模块中导入 <code>HttpResponse</code></p></li><li><p>视图函数参数<code>request</code></p><p>我们定义了一个名为“Hello_my_django”的函数，Django 规定，视图函数至少有一个参数，第一个参数必须是  request，request 是 HttpRequest 请求类型的对象，它携带了浏览器的请求信息，所以视图函数的第一个参数必须为  <code>request</code>。</p></li><li><p>return 视图响应</p><p>视图函数要返回响应内容，这里的响应内容是我们用 HTML 标签编写的，把它作为 HttpResponse 的对象返回给浏览器</p></li></ol><h3 id="2、视图函数执行过程"><a href="#2、视图函数执行过程" class="headerlink" title="2、视图函数执行过程"></a>2、视图函数执行过程</h3><p>Django 收到请求以后</p><ul><li>首先创建一个带有请求信息的 HttpRequset 对象</li><li>将 HttpRequest 的对象 request  作为第一个参数传递给视图函数</li><li>视图接收参数后继续向下执行</li><li>然后选择加载对应的视图</li><li>最后返回 HttpResponse 对象给浏览器。</li></ul><h2 id="Django模板系统"><a href="#Django模板系统" class="headerlink" title="Django模板系统"></a>Django模板系统</h2><p><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/templates/">模板 | Django 文档 | Django (djangoproject.com)</a></p><pre><code class="python">from django.http import HttpResponsedef Hello_my_django(request):        return HttpResponse(&#39;&lt;html&gt;&lt;body&gt;Hello my Django&lt;/body&gt;&lt;/html&gt;&#39;)</code></pre><h3 id="1、Django的模板系统"><a href="#1、Django的模板系统" class="headerlink" title="1、Django的模板系统"></a>1、Django的模板系统</h3><p>上述代码不具有可行性</p><ul><li>页面代码需要经常改动，如果将页面放到视图函数中，那么当对前端页面修改的时候，也会使得视图函数发生变化</li><li>从 MTV 设计模式的角度出发，视图层是实现业务逻辑的，在视图层编写代码和编写 HTML 页面是两项可以相互独立的工作</li></ul><p>&#x3D;&gt; 考虑将视图函数与页面代码分离开，也就是进行解耦</p><p>&#x3D;&gt; 模板系统</p><h3 id="2、模板系统的应用"><a href="#2、模板系统的应用" class="headerlink" title="2、模板系统的应用"></a>2、模板系统的应用</h3><p>Template（模板），它使得HTML和View视图层实现了解耦</p><p>T层的实现：</p><ol><li>创建好一个 Django 项目后，我们在项目的同级目录下创建一个名为 <code>templates </code>文件夹</li><li>进行简单的配置后，这个文件夹将被 Django 自动识别</li></ol><p>改造上述代码：</p><ol><li><p>在 templates 文件中新建一个 HTML 文件，并且将此文件命名为 <code>hello.html</code></p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &#123;&#123;vaule&#125;&#125;    &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>改造视图函数</p><pre><code class="python">from django.shortcuts import render def hello_my_django(request):        return render(request,&quot;hello.html&quot;,&#123;&quot;vaule&quot;:&quot;hello my Django&quot;&#125;)</code></pre><p><strong>1)模板传参</strong></p><p><code>hello.html </code>文件中的 <code>&#123;&#123;vaule&#125;&#125; </code>是一个模板的变量，视图函数必须把数据形成<strong>字典</strong>的形式才可以传递给模板</p><p><strong>2）<code>render()</code>方法</strong></p><p><code>render </code>是 View 层加载模板的一种方式，它封装在 <code>django.shortcuts</code> 模块中，<code>render()</code> 方法使用起来非常方便，它首先加载模板，然后将加载完成的模板响应给浏览器</p></li></ol><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/http/urls/">URL调度器 | Django 文档 | Django (djangoproject.com)</a></p><h3 id="1、URL简介"><a href="#1、URL简介" class="headerlink" title="1、URL简介"></a>1、URL简介</h3><p>URL(Uniform Resource Location)，统一资源定位符，它用来表示互联网上的某个资源地址</p><p>互联网上的每个文件都有一个<strong>唯一</strong>的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它</p><h3 id="2、URL语法格式详解"><a href="#2、URL语法格式详解" class="headerlink" title="2、URL语法格式详解"></a>2、URL语法格式详解</h3><p>URL语法格式：</p><pre><code class="apl">protocol://hostname[:port]/path[?query][#fragment]</code></pre><p>示例：</p><pre><code class="apl">https://www.baidu.com/movie/movieshow?id=234&amp;number=1314#name</code></pre><h4 id="1-protocol（协议）"><a href="#1-protocol（协议）" class="headerlink" title="1)protocol（协议）"></a>1)protocol（协议）</h4><p>protocol 是指网络传输协议，以下是经常用到的几个协议：</p><ul><li>http，通过 HTTP 协议访问该资源，格式 http:&#x2F;&#x2F;；</li><li>https，通过安全的 HTTPS 协议访问该资源， 格式 https:&#x2F;&#x2F;；</li><li>file，资源是本地计算机上的文件，格式 file:&#x2F;&#x2F;&#x2F;；</li><li>ftp，通过 FTP访问资源，格式 FTP:&#x2F;&#x2F;。</li></ul><h4 id="2-hostname（主机名）"><a href="#2-hostname（主机名）" class="headerlink" title="2) hostname（主机名）"></a>2) hostname（主机名）</h4><p>是指存放资源的服务器的域名、主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。</p><h4 id="3-port（端口号）"><a href="#3-port（端口号）" class="headerlink" title="3) port（端口号）"></a>3) port（端口号）</h4><p>port 是一个可选的整数，它的取值范围 是 0-65535。如果 port 被省略时就使用默认端口，各种传输协议都有默认的端口号，如 http 的默认端口为 80，https 的端口是 443。</p><h4 id="4-path（路由地址）"><a href="#4-path（路由地址）" class="headerlink" title="4) path（路由地址）"></a>4) path（路由地址）</h4><p>由零个或多个<code>/</code>符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。路由地址决定了服务端如何处理这个请求。</p><h4 id="5-query-查询"><a href="#5-query-查询" class="headerlink" title="5) query (查询)"></a>5) query (查询)</h4><p>从<code>?</code>开始到<code>#</code>为止，它们之间的部分就是参数，又称搜索部分或者查询字符串。这个部分允许有多个参数，参数与参数之间用<code>&amp;</code>作为分隔符。本例的参数部分为<code>id=234&amp;number=1314</code>。</p><h4 id="6-fragment（信息片断）"><a href="#6-fragment（信息片断）" class="headerlink" title="6) fragment（信息片断）"></a>6) fragment（信息片断）</h4><p>它用于指定网络资源中的片断，例如一个网页中有多个名词解释，那么可使用 fragment 直接对它们定位。例子中的信息片段是<code>#</code>后的 name。<code>#</code>代表网页中的一个位置而 name 就是这个位置的标志符号，当浏览器读取到上述 URL 后，浏览器将直接展示该位置。</p><h2 id="Django路由系统"><a href="#Django路由系统" class="headerlink" title="Django路由系统"></a>Django路由系统</h2><h3 id="1、Django路由系统应用"><a href="#1、Django路由系统应用" class="headerlink" title="1、Django路由系统应用"></a>1、Django路由系统应用</h3><p><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/urls/">URLconfs 中使用的 django.urls 函数 | Django 文档 | Django (djangoproject.com)</a></p><p>用户请求会到达相应的视图函数，视图函数通过路由系统找到相应的访问资源</p><p>Django 中利用 <code>ROOT_URLCONF </code>构建了 URL 与视图函数的映射关系。在 <code>django.conf.urls</code>  中封装了路由模块，新建的 Django 项目中提供了 <code>urls.py</code>（创建项目后自动生成的配置文件） 路由配置文件，<code>urls.py</code>  文件中定义了一个 <code>urlpatterns </code>的列表，它是由 <code>path( )</code> 实例对象组成的列表，Django 中 url 的定义就是在这个列表完成的</p><pre><code class="python">from django.conf.urls import urlurlpatterns=[    path(&#39;admin/&#39;,admin.site.urls),    ...]</code></pre><p>后台Admin管理系统的路由就定义在列表的第一个位置</p><pre><code class="python">    path(regex,view,name=None)</code></pre><ul><li>regex，匹配请求路径，用正则表达式表示</li><li>view，指定 regex 匹配路径所对应的视图函数的名称</li><li>name，是给 url 地址起个别名，在模板反向解析的时候使用</li></ul><h2 id="Django中间件"><a href="#Django中间件" class="headerlink" title="Django中间件"></a>Django中间件</h2><p><a href="https://docs.djangoproject.com/zh-hans/4.1/ref/middleware/">中间件 | Django 文档 | Django (djangoproject.com)</a></p><p>中间件是一个插件系统，嵌入在 Django 的 Request 和 Response 之间执行，可以对输入和输出内容作出修改，它是处理所有请求与响应的通用框架组件</p><h3 id="1、Django默认自带中间件"><a href="#1、Django默认自带中间件" class="headerlink" title="1、Django默认自带中间件"></a>1、Django默认自带中间件</h3><p>中间件的本质 &#x3D;&gt; Python类，类内定义了函数，这些函数在视图函数执行前后调用，函数称为”钩子函数“</p><p>Django提供中间件、开发者可以使用Django的中间件接口来自定义中间件</p><p>创建Django项目后，在配置文件<code>settings.py</code>中默认生成中间件</p><pre><code class="python">MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre><h4 id="1-中间件的执行和响应顺序"><a href="#1-中间件的执行和响应顺序" class="headerlink" title="1)中间件的执行和响应顺序"></a>1)中间件的执行和响应顺序</h4><p>项目创建后，所有中间件都是<strong>默认激活</strong>的状态。可以根据具体的业务需求，通过代码注释的方式来关闭某个中间件。</p><p>Django  同时规定了中间件的执行顺序与配置关系，以上述代码为例</p><ul><li>执行顺序：从上到下</li><li>返回响应结果顺序：从下至上</li></ul><p>从浏览器发出一个请求 Request，最后得到一个 HttpResponse 响应 ，这个请求传递与响应返回的过程如下图所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221208175516.png"></p><p>中间件作为一个可插拔的组件对外提供服务，每个中间件都负责完成一些特定的功能。</p><p>中间件定义的钩子函数，是在视图函数执行的前后调用的，它们的执行过程如下所示：</p><h5 id="1）在调用视图之前"><a href="#1）在调用视图之前" class="headerlink" title="1）在调用视图之前"></a>1）在调用视图之前</h5><p>如上图所示，在请求阶段，Django 按照自定义的顺序自上而下地应用中间件。这个过程执行两个钩子函数 <code>process_request() </code>和 <code>process_view()</code>，它们都是在视图函数执行前调用的</p><h5 id="2）在调用视图之后"><a href="#2）在调用视图之后" class="headerlink" title="2）在调用视图之后"></a>2）在调用视图之后</h5><p>如上图所示，在响应阶段，中间件从下往上返回 HttpResponse，这个过程有三个挂钩函数可供选择：</p><ul><li><code>process_exception()</code> （只有当视图引发异常时调用）；</li><li><code>process_template_response()</code> （仅适用于模板响应）；</li><li><code>process_response()</code></li></ul><h2 id="Django-Cache缓存系统"><a href="#Django-Cache缓存系统" class="headerlink" title="Django Cache缓存系统"></a>Django Cache缓存系统</h2><p><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/cache/">Django 缓存框架 | Django 文档 | Django (djangoproject.com)</a></p><h3 id="1、缓存技术的作用"><a href="#1、缓存技术的作用" class="headerlink" title="1、缓存技术的作用"></a>1、缓存技术的作用</h3><p>缓存是指保存一些计算开销较大的数据，可以是某个网页，也可以是网页的一部分，或者仅仅只是格式化的数据，合理运用缓存技术可以减少数据库访问次数，不用每次都到数据库中读取数据，从而优化了网页的访问速度</p><p> 缓存系统真正的提高了 Web 站点执行效率，常被用来缓存用户经常访问的页面，比如网站的首页等，用户再次访问的时候直接返回已经缓存的内容，从而减小了 Web 服务器的压力</p><h3 id="2、Django缓存系统"><a href="#2、Django缓存系统" class="headerlink" title="2、Django缓存系统"></a>2、Django缓存系统</h3><p>Django 提供了一个健壮的缓存系统，可以保存动态页面，这样就不必每次都把相同的请求进行重复计算。并且 Django 还提供了不同级别的缓存粒度，可以缓存特定视图的输出，或者只缓存某些特定的片段，比如网站自动跳出的咨询栏等，或者也可以缓存整个站点。</p><p> 同时 Django 还支持多种缓存类型，可以根据实际情况来选择用哪种类型，例如 Memcached、数据库、文件系统等。</p><p> <strong>Memcached</strong> 是 Django 支持的最快、最高效的分布式高效缓存系统，它是一种完全基于内存的缓存服务器。它被 Facebook 、维基百科等网站使用，从而减少数据库的访问并显著提高网站的性能</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr><h2 id="Django实战"><a href="#Django实战" class="headerlink" title="Django实战"></a>Django实战</h2><p>菜鸟教程：<a href="https://www.runoob.com/django/django-tutorial.html">https://www.runoob.com/django/django-tutorial.html</a></p><p>官方文档基础实战教学：</p><ul><li><p><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/install/">快速安装指南 | Django 文档 | Django (djangoproject.com)</a></p></li><li><p><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial01/">编写你的第一个 Django 应用，第 1 部分 | Django 文档 | Django (djangoproject.com)</a></p></li><li><p><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial02/">编写你的第一个 Django 应用，第 2 部分 | Django 文档 | Django (djangoproject.com)</a></p></li><li><p><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial03/">编写你的第一个 Django 应用，第 3 部分 | Django 文档 | Django (djangoproject.com)</a></p></li><li><p><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial03/">编写你的第一个 Django 应用，第 3 部分 | Django 文档 | Django (djangoproject.com)</a></p></li><li><p><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial05/">编写你的第一个 Django 应用，第 5 部分 | Django 文档 | Django (djangoproject.com)</a></p></li><li><p><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial06/">编写你的第一个 Django 应用，第 6 部分 | Django 文档 | Django (djangoproject.com)</a></p><p><a href="https://docs.djangoproject.com/zh-hans/4.1/intro/tutorial07/">编写你的第一个 Django 应用，第 7 部分 | Django 文档 | Django (djangoproject.com)</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之路--贪心篇</title>
      <link href="/2022/12/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%B4%AA%E5%BF%83%E7%AF%87/"/>
      <url>/2022/12/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%B4%AA%E5%BF%83%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="算法学习之路-–-贪心篇"><a href="#算法学习之路-–-贪心篇" class="headerlink" title="算法学习之路 – 贪心篇"></a>算法学习之路 – 贪心篇</h1><h2 id="一、贪心的本质"><a href="#一、贪心的本质" class="headerlink" title="一、贪心的本质"></a>一、贪心的本质</h2><p><strong>本质</strong>  &#x3D;&gt; 选择每一阶段的局部最优，从而达到全局最优</p><h2 id="二、贪心使用的时机"><a href="#二、贪心使用的时机" class="headerlink" title="二、贪心使用的时机"></a>二、贪心使用的时机</h2><p>贪心算法没有固定套路，唯一的<strong>难点</strong> &#x3D;&gt; 如何通过局部最优，推出整体最优</p><p>判别：刷题或者面试时，手动<strong>模拟</strong>，感觉可以局部最优推出整体最优，而且想不出反例，可以尝试贪心</p><h2 id="三、贪心一般解题步骤"><a href="#三、贪心一般解题步骤" class="headerlink" title="三、贪心一般解题步骤"></a>三、贪心一般解题步骤</h2><ul><li>将问题分解成若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>&#x3D;&gt; 常识性推导 + 举反例</p><h2 id="四、典型例题分析"><a href="#四、典型例题分析" class="headerlink" title="四、典型例题分析"></a>四、典型例题分析</h2><span id="more"></span><h3 id="455、分发饼干"><a href="#455、分发饼干" class="headerlink" title="455、分发饼干"></a>455、分发饼干</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/assign-cookies/">https://leetcode-cn.com/problems/assign-cookies/</a></p><pre><code class="markdown">假设你是⼀位很棒的家长，想要给你的孩⼦们⼀些⼩饼⼲。但是，每个孩⼦最多只能给⼀块饼⼲。对每个孩⼦ i，都有⼀个胃⼜值 g[i]，这是能让孩⼦们满⾜胃⼜的饼⼲的最⼩尺⼨；并且每块饼⼲ j，都有⼀个尺⼨ s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼⼲ j 分配给孩⼦ i ，这个孩⼦会得到满⾜。你的⽬标是尽可能满⾜越多数量的孩⼦，并输出这个最⼤数值。 ⽰例 1:输⼊: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩⼦和两块⼩饼⼲，3个孩⼦的胃⼜值分别是：1,2,3。虽然你有两块⼩饼⼲，由于他们的尺⼨都是1，你只能让胃⼜值是1的孩⼦满⾜。所以你应该输出1。 ⽰例 2:输⼊: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩⼦和三块⼩饼⼲，2个孩⼦的胃⼜值分别是1,2。 你拥有的饼⼲数量和尺⼨都⾜以让所有孩⼦满⾜。所以你应该输出2.提⽰：- 1 &lt;= g.length &lt;= 3 * 10^4- 0 &lt;= s.length &lt;= 3 * 10^4- 1 &lt;= g[i], s[j] &lt;= 2^31 - 1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>为了满足更多的小孩，就不要造成饼干的浪费</p><p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子 &#x3D;&gt; 优先满足胃口大的孩子</p><p>&#x3D;&gt; <strong>局部最优解：大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优解：喂饱尽可能多的孩子</strong></p><p>&#x3D;&gt; 尝试贪心策略</p><ul><li><p>将饼干数组和小孩数组排序</p></li><li><p>从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量</p></li><li><p>图示</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/455%E3%80%81%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.png"></p></li></ul><p>​&#x3D;&gt; 饼干9只有喂给胃口为7的小孩，才是整体最优解</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(nlogn)// 空间复杂度：O(1)class Solution &#123;    public int findContentChildren(int[] g, int[] s) &#123;        Arrays.sort(g);        Arrays.sort(s);        int res = 0;        int index = s.length - 1; // 饼干数组的下标        for(int i = g.length - 1;i &gt;= 0;--i) &#123;            if(index &gt;= 0 &amp;&amp; s[index] &gt;= g[i]) &#123;                --index;                ++res;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><p><strong>换一个思路：小饼干喂饱小胃口</strong></p><p>Java代码如下：</p><pre><code class="java">class Solution &#123;    public int findContentChildren(int[] g, int[] s) &#123;        Arrays.sort(g);        Arrays.sort(s);        int index = 0;        for(int i = 0;i &lt; s.length;++i) &#123;            if(index &lt; g.length &amp;&amp; g[index] &lt;= s[i]) &#123;                ++index;            &#125;        &#125;        return index;    &#125;&#125;</code></pre><h3 id="376、摆动序列"><a href="#376、摆动序列" class="headerlink" title="376、摆动序列"></a>376、摆动序列</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a></p><pre><code class="markdown">如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第⼀个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。例如，[1,7,4,9,2,5] 是⼀个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反,[1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第⼀个序列是因为它的前两个差值都是正数，第⼆个序列是因为它的最后⼀个差值为零。给定⼀个整数序列，返回作为摆动序列的最长⼦序列的长度。 通过从原始序列中删除⼀些 （也可以不删除）元素来获得⼦序列，剩下的元素保持其原始顺序。⽰例 1:输⼊: [1,7,4,9,2,5]输出: 6解释: 整个序列均为摆动序列。 ⽰例 2:输⼊: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含⼏个长度为 7 摆动序列，其中⼀个可为[1,17,10,13,10,16,8]。 ⽰例 3:输⼊: [1,2,3,4,5,6,7,8,9]输出: 2</code></pre><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>示例二图示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/376%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%E7%A4%BA%E4%BE%8B%E4%BA%8C.png"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点）&#x3D;&gt; 这个坡度就可以有两个局部峰值</strong></p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong></p><blockquote><p>⚠️实际操作上，其实连删除的操作都不用做</p><p>题目要求的是最长摆动子序列的长度 &#x3D;&gt; 只需要统计数组的峰值数量即可（相当于是删除单一坡度上的节点，然后统计长度）</p><p><strong>贪</strong> ： 让峰值尽可能保持峰值，然后删除单一坡度上的节点</p><p>代码实现中的技巧：</p><ul><li>统计峰值时，数组最左边和最右边是最不好统计的<br>例如序列<code>[2,5]</code>，他的峰值数量是2，如果考统计差值来计算峰值个数就需要考虑数组最左边和最右边的情况<br>&#x3D;&gt; 针对序列<code>[2,5]</code>，可以假设为<code>[2,2,5]</code> &#x3D;&gt; 存在坡度即<code>preDiff = 0</code><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/376%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%E6%8A%80%E5%B7%A7.png"><br>针对以上情况，<code>result</code>初始为1（默认最右边存在一个峰值)，此时<code>curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0</code>，那么<code>result++</code>（计算了左边的峰值)，最后得到结果<code>result = 2</code>（峰值个数为2，即摆动序列长度为2)</li></ul></blockquote><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度： O(nlogn)// 空间复杂度： O(1)class Solution &#123;    public int wiggleMaxLength(int[] nums) &#123;        int len = nums.length;        if(len &lt;= 1) return len;        int curDiff = 0; // 当前一对差值        int preDiff = 0; // 之前一对差值        int result = 1; // 记录峰值个数，默认序列最右边存在一个峰值        for(int i = 0;i &lt; len - 1;++i) &#123;            curDiff = nums[i + 1] - nums[i];            if((preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)) &#123;                ++result;                preDiff = curDiff;            &#125;        &#125;        return result;    &#125;&#125;</code></pre><h3 id="53、最大子序和"><a href="#53、最大子序和" class="headerlink" title="53、最大子序和"></a>53、最大子序和</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><pre><code class="markdown">给定⼀个整数数组 nums ，找到⼀个具有最⼤和的连续⼦数组（⼦数组最少包含⼀个元素），返回其最⼤和。⽰例: 输⼊: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续⼦数组 [4,-1,2,1] 的和最⼤，为 6。</code></pre><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><strong>局部最优：当前“连续和”为负数的时候就立刻放弃，从下一个元素开始重新计算“连续和”，因为负数加上下一个元素“连续和”只会越来越小</strong></p><p><strong>全局最优：选取最大的“连续和”</strong></p><p>&#x3D;&gt; 局部最优的情况下，记录最大的“连续和”，可以推出全局最优</p><blockquote><p>从代码的角度看：遍历nums，从头开始用count累计，如果一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累计count了，因为已经变成负数的count只会拖累总和</p><p>&#x3D;&gt; <strong>相当于是暴力解法中的不断调整最大子序列和区间的起始位置</strong></p></blockquote><blockquote><p>关于区间终止位置：</p><p>区间的终止位置，其实就是如果count取到最大值了，及时记录下来了</p><pre><code class="java">if(count &gt; result) result = count</code></pre><p>&#x3D;&gt; **相当于是用reslut记录最大子序和区间和（变相算是调整了终止位置）</p></blockquote><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度： O(n)// 空间复杂度： O(1)class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int result = Integer.MIN_VALUE;        int count = 0;        for(int i = 0;i &lt; nums.length;++i) &#123;            count += nums[i];            if(count &gt; result) result = count; // 取区间累计的最大值（相当于不断确定最大子序终止位置）            if(count &lt;= 0) count = 0; // 相当于重置最大子序其实位置，因为遇到负数一定是拉低总和        &#125;        return result;    &#125;&#125;</code></pre><h3 id="122、买卖股票的最佳时机II"><a href="#122、买卖股票的最佳时机II" class="headerlink" title="122、买卖股票的最佳时机II"></a>122、买卖股票的最佳时机<strong>II</strong></h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><pre><code class="markdown">给定⼀个数组，它的第 i 个元素是⼀⽀给定股票第 i 天的价格。设计⼀个算法来计算你所能获取的最⼤利润。你可以尽可能地完成更多的交易（多次买卖⼀⽀股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。⽰例 1:输⼊: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买⼊，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。随后，在第 4 天（股票价格 = 3）的时候买⼊，在第 5 天（股票价 格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。⽰例 2:输⼊: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买⼊，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。⽰例 3:输⼊: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最⼤利润为 0。提⽰：- 1 &lt;= prices.length &lt;= 3 * 10 ^ 4- 0 &lt;= prices[i] &lt;= 10 ^ 4</code></pre><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>本题需要贯穿的点</p><ul><li>只有一支股票</li><li>当前只有买股票或者卖股票的操作</li></ul><p><strong>要点</strong>：最终利益是可以分解的</p><p>假如第0天买入，第三天卖出，那么利润为：<code>prices[3] - prices[0]</code> &#x3D;&gt; <code>(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])</code> &#x3D;&gt; 把利益分解为每天为单位的维度，而不是从第0天到第3天整体去考虑  &#x3D;&gt; 每天的利润序列：<code>(prices[i] - prices[i - 1]) + (prices[i - 1] - prices[i - 2]) + ... + (prices[1] - prices[0])</code></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/LeetCode122.png"></p><blockquote><p>⚠️第一天没有利润，第二天才会有利润，所以利润的序列比股票序列少一天</p><p><strong>贪</strong>：由图可知，只需收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，我们只关注最终利润，不需要记录区间</strong></p></blockquote><p><strong>局部最优：收集每天的正利润</strong></p><p><strong>全局最优：求得最大利润</strong></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int maxProfit(int[] prices) &#123;        int result = 0;        for(int i = 1;i &lt; prices.length;++i) &#123;            result += Math.max(prices[i] - prices[i - 1],0);        &#125;        return result;    &#125;&#125;</code></pre><h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><pre><code class="markdown">给定⼀个⾮负整数数组，你最初位于数组的第⼀个位置。 数组中的每个元素代表你在该位置可以跳跃的最⼤长度。判断你是否能够到达最后⼀个位置。 ⽰例 1:输⼊: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后⼀个位置。⽰例 2:输⼊: [3,2,1,0,4]输出: false解释: ⽆论怎样，你总会到达索引为 3 的位置。但该位置的最⼤跳跃长度是 0 ， 所以你永远不可能到达最后⼀个位置。</code></pre><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>关键</strong> &#x3D;&gt; 可跳的覆盖范围</p><p>不一定要明确每一次跳几步，每次取最大的跳跃步数（可以跳跃的覆盖范围）</p><p>&#x3D;&gt; 问题转化为<strong>跳跃覆盖范围是否可以覆盖到终点</strong></p><p><strong>局部最优：每次取最大跳跃步数</strong></p><p><strong>全局最优：最后得到整体覆盖范围，看是否能到终点</strong></p><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/54">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/54</a> 跳跃游戏.png)</p><ul><li>i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去</li><li>而cover每次只取max（该元素数值补充后的范围，cover本身范围）</li></ul><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">class Solution &#123;    public boolean canJump(int[] nums) &#123;        int len = nums.length;        int cover = 0;        if(len == 1) return true; // 只有一个元素 =&gt; 可达        for(int i = 0;i &lt;= cover;++i) &#123; // 注意这里是小于等于cover            cover = Math.max(cover,i + nums[i]);            if(cover &gt;= len - 1) return true; // 说明可以覆盖到终点了        &#125;        return false;    &#125;&#125;</code></pre><h3 id="45、跳跃游戏II"><a href="#45、跳跃游戏II" class="headerlink" title="45、跳跃游戏II"></a>45、跳跃游戏<strong>II</strong></h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode.cn/problems/jump-game-ii">https://leetcode.cn/problems/jump-game-ii</a></p><pre><code class="markdown">给定⼀个⾮负整数数组，你最初位于数组的第⼀个位置。 数组中的每个元素代表你在该位置可以跳跃的最⼤长度。你的⽬标是使⽤最少的跳跃次数到达数组的最后⼀个位置。 ⽰例: 输⼊: [2,3,1,1,4]输出: 2解释: 跳到最后⼀个位置的最⼩跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后 跳 3 步到达数组的最后⼀个位置。 说明:假设你总是可以到达数组的最后⼀个位置。</code></pre><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>本题相较于<a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a>，思路类似，还是要看最大覆盖范围</p><p><strong>局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一</strong></p><p><strong>整体最优：一步尽可能多走，从而达到最小步数</strong></p><p>&#x3D;&gt; 真正解题时，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数 &#x3D;&gt; 统计两个覆盖范围，<strong>当前这一步的最大覆盖</strong>和<strong>下一步的最大覆盖</strong>，如果移动下标达到了当前这一步的最大覆盖最远距离了仍旧未到终点，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/45%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E4%BA%8C.png"></p><blockquote><p>上图覆盖范围的意义在于：只要红色的区域，最多两步就一定可以到</p></blockquote><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><ul><li><p>方法一</p><p>由图可以看出，就是移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离，最后的步数就是最少步数</p><p>特殊情况考虑：当移动下标达到了当前覆盖的最远距离下标时</p><ul><li>如果当前覆盖的最远距离下标不是集合终点，步数就加一，还需要继续走</li><li>如果当前覆盖的最远距离就是集合终点，步数就不用加一，因为不能再往后走了</li></ul><p>Java代码：</p><pre><code class="java">class Solution &#123;    public int jump(int[] nums) &#123;        int len = nums.length;        if(len == 0) return 0;        int curDistance = 0; // 当前覆盖最远距离的下标        int nextDistance = 0; // 下一步覆盖最远距离的下标        int ans = 0; // 记录走的最大步数        for(int i = 0;i &lt; len;++i) &#123;            nextDistance = Math.max(nextDistance,nums[i] + i); // 更新下一步覆盖的最远距离下标            if(i == curDistance) &#123; // 遇到当前覆盖最远距离下标                if(curDistance != len - 1) &#123; // 如果当前覆盖最远距离下标不是终点                    ++ans; // 需要走下一步                    curDistance = nextDistance; // 更新当前覆盖最远距离下标                    if(nextDistance &gt;= len - 1) &#123;                      // 下一步的覆盖范围已经可以到达终点，结束循环                        break;                     &#125;                &#125; else &#123;                  // 当前覆盖最远距离时集合终点，不需要再进行ans++操作，结束循环                    break;                &#125;            &#125;         &#125;        return ans;    &#125;&#125;</code></pre><ul><li><p>方法二</p><p><strong>针对于方法一的特殊情况，可以统一处理</strong> &#x3D;&gt; 移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况 &#x3D;&gt; <strong>只需要让移动下标，最大只能移动到<code>nums.length - 2</code>的位置就可以了</strong></p><p>因为当移动下标指向<code>nums.length - 2</code>时：</p><ul><li><p>如果移动下标等于当前覆盖最大距离下标，需要再走一步（<code>++ans</code>)，因为最后一步一定是可以到的终点（题目假设）</p><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/LeetCode45">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/LeetCode45</a> method2 一.png)</p></li><li><p>如果移动下标不等于当前覆盖最大距离的下标，说明当前覆盖最远距离就是可以直接达到终点了，不需要再走一步</p><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/LeetCode45">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/LeetCode45</a> method2 二.png)</p></li></ul><p>Java代码</p><pre><code class="java">class Solution &#123;    public int jump(int[] nums) &#123;        int len = nums.length;        if(len == 0) return 0;        int curDistance = 0; // 当前覆盖最远距离的下标        int nextDistance = 0; // 下一步覆盖最远距离的下标        int ans = 0; // 记录走的次数        for(int i = 0;i &lt; len - 1;++i) &#123; // 关键步骤：小于 nums.length - 1            nextDistance = Math.max(nextDistance,nums[i] + i); // 更新下一步覆盖的最远距离下标            if(i == curDistance) &#123; // 遇到当前覆盖的最远距离下标                ++ans;                curDistance = nextDistance; // 更新当前覆盖的最远距离下标            &#125;         &#125;        return ans;    &#125;&#125;</code></pre></li></ul></li></ul><h3 id="1005、K次取反后最大化的数组和"><a href="#1005、K次取反后最大化的数组和" class="headerlink" title="1005、K次取反后最大化的数组和"></a>1005、K次取反后最大化的数组和</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/</a></p><pre><code class="markdown">给定⼀个整数数组 A，我们只能⽤以下⽅法修改该数组：我们选择某个索引 i 并将 A[i] 替换为-A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同⼀个索引 i。）以这种⽅式修改数组后，返回数组可能的最⼤和。⽰例 1： 输⼊：A = [4,2,3], K = 1输出：5 解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。 ⽰例 2：输⼊：A = [3,-1,0,2], K = 3输出：6 解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。 ⽰例 3： 输⼊：A = [2,-3,-1,5,-4], K = 2输出：13解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。提⽰：- 1 &lt;= A.length &lt;= 10000- 1 &lt;= K &lt;= 10000- -100 &lt;= A[i] &lt;= 100</code></pre><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>如何使得数组和最大 &#x3D;&gt; </p><ul><li><strong>局部最优：让绝对值大的负数变成正数</strong></li><li><strong>整体最优：整个数组和达到最大</strong></li></ul><p>如果将负数都转变成正数了，K依然大于0，此时的问题变成一个有序正整数序列，如何转变K次&#x3D;正负，让数组和达到最大 &#x3D;&gt; </p><ul><li><strong>局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大</strong></li><li><strong>整体最优：整个数组和达到最大</strong></li></ul><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>解题步骤：</p><ul><li>将数组按照绝对值大小降序排列（⚠️按照绝对值的大小排序）</li><li>从前往后遍历，遇到负数将其变为正数，同时<code>K--</code></li><li>若<code>K&gt;0</code>，反复转变数值最小的元素，使得<code>k==0</code></li><li>求和</li></ul><p>C++代码</p><pre><code class="C++">class Solution &#123;static bool cmp(int a, int b) &#123;     return abs(a) &gt; abs(b);&#125;public: int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) &#123;   sort(A.begin(), A.end(), cmp); // 第⼀步   for (int i = 0; i &lt; A.size(); i++) &#123; // 第⼆步     if (A[i] &lt; 0 &amp;&amp; K &gt; 0) &#123;       A[i] *= -1;       K--;           &#125;   &#125;   if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步   int result = 0;   for (int a : A) result += a; // 第四步   return result;     &#125;&#125;;</code></pre><h3 id="134、加油站"><a href="#134、加油站" class="headerlink" title="134、加油站"></a>134、加油站</h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/gas-station/">https://leetcode-cn.com/problems/gas-station/</a></p><pre><code class="markdown">在⼀条环路上有 N 个加油站，其中第 i 个加油站有汽油gas[i] 升。 你有⼀辆油箱容量⽆限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的⼀个加油站出发，开始时油箱为空。如果你可以绕环路⾏驶⼀周，则返回出发时加油站的编号，否则返回 -1。 说明:- 如果题⽬有解，该答案即为唯⼀答案- 输⼊数组均为⾮空数组，且长度相同- 输⼊数组中的元素均为⾮负数⽰例 1:输⼊:  gas = [1,2,3,4,5]  cost = [3,4,5,1,2]输出: 3解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好⾜够你返回到 3 号加油站。因此，3 可为起始索引。⽰例 2:输⼊:  gas = [2,3,4]  cost = [3,4,3]输出: -1解释: 你不能从 0 号或 1 号加油站出发，因为没有⾜够的汽油可以让你⾏驶到下⼀个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你⽆法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。 因此，⽆论怎样，你都不可能绕环路⾏驶⼀周</code></pre><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><h4 id="贪心算法（方法一）"><a href="#贪心算法（方法一）" class="headerlink" title="贪心算法（方法一）"></a>贪心算法（方法一）</h4><p>直接从全局进行贪心选择，情况如下</p><ul><li>情况一：如果gas的总和小于cost的总和，那么无论从哪里出发都无法跑完一圈</li><li>情况二：<code>rest[i] = gas[i] - cost[i]</code>为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油没有断过，那么0就是起点</li><li>情况三：如果累加的最小值时负数，汽车就要从非0节点出发，从后向前，看哪个节点能将这个负数填平，能把这个负数填平的节点就是出发节点</li></ul><h4 id="贪心算法（方法二）"><a href="#贪心算法（方法二）" class="headerlink" title="贪心算法（方法二）"></a>贪心算法（方法二）</h4><p>若总油量减去总消耗大于等于零，那么一定可以跑完一圈，说明各个站点的加油站剩油量<code>rest[i]</code>相加一定是大于等于零的</p><p>每个加油站的剩余量<code>rest[i] = gas[i] - cost[i]</code></p><p>i从0开始累加<code>rest[i]</code>，和记为<code>curSum</code>，一旦curSum小于零，说明<code>[0,i]</code>区间都不能作为起始位置，起始位置从<code>i+1</code>算起，再从0开始计算curSum</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/134%E5%8A%A0%E6%B2%B9%E7%AB%99.png"></p><blockquote><p>为什么一旦<code>[i,j]</code>区间和为负数，起始位置就可以是<code>j + 1</code>呢，<code>j + 1</code>后面就不会出现更大的负数？</p><p>如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了</p><p>而且j之前出现了多少个负数，j后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定一定可以跑完全程了）</p></blockquote><p><strong>局部最优：当前累加rest[j]的和curSum一旦小于零，起始位置至少要是j+1，因为从j开始一定不行</strong></p><p><strong>全局最优：找到可以跑一圈的起始位置</strong></p><h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><h4 id="方法一实现："><a href="#方法一实现：" class="headerlink" title="方法一实现："></a>方法一实现：</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int canCompleteCircuit(int[] gas, int[] cost) &#123;        int curSum = 0;        int min = Integer.MAX_VALUE;        for(int i = 0;i &lt; gas.length;++i) &#123;            int rest = gas[i] - cost[i];            curSum += rest;            if(curSum &lt; min) &#123;                min = curSum;            &#125;        &#125;        if(curSum &lt; 0) return -1; // 情况一        if(min &gt;= 0) return 0; // 情况二        for(int i = gas.length - 1;i &gt;= 0;--i) &#123; // 情况三            int rest = gas[i] - cost[i];            min += rest;            if(min &gt;= 0) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><h4 id="方法二实现："><a href="#方法二实现：" class="headerlink" title="方法二实现："></a>方法二实现：</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int canCompleteCircuit(int[] gas, int[] cost) &#123;        int curSum = 0;        int totalSum = 0;        int start = 0;        for(int i = 0;i &lt; gas.length;++i) &#123;            int rest = gas[i] - cost[i];            totalSum += rest;            curSum += rest;            if(curSum &lt; 0) &#123; // 当前累加rest[i]和curSum一旦小于零                start = i + 1; // 起始位置更新为i+1                curSum = 0; // curSum从0开始            &#125;        &#125;        if(totalSum &lt; 0) return -1; // 说明怎么走都不可能跑一圈        return start;    &#125;&#125;</code></pre><h3 id="135、分发糖果"><a href="#135、分发糖果" class="headerlink" title="135、分发糖果"></a>135、分发糖果</h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/candy/">https://leetcode-cn.com/problems/candy/</a></p><pre><code class="markdown">⽼师想给孩⼦们分发糖果，有 N 个孩⼦站成了⼀条直线，⽼师会根据每个孩⼦的表现，预先给他们评分。你需要按照以下要求，帮助⽼师给这些孩⼦分发糖果：- 每个孩⼦⾄少分配到 1 个糖果- 相邻的孩⼦中，评分⾼的孩⼦必须获得更多的糖果那么这样下来，⽼师⾄少需要准备多少颗糖果呢？ ⽰例 1:输⼊: [1,0,2]输出: 5解释: 你可以分别给这三个孩⼦分发 2、1、2 颗糖果。⽰例 2:输⼊: [1,2,2]输出: 4解释: 你可以分别给这三个孩⼦分发 1、2、1 颗糖果。第三个孩⼦只得到 1 颗糖果，这已满⾜上述两个条件</code></pre><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>这道题目一定是要确定一边之后，再确定另外一边，例如比较每个孩子的左边，再比较右边，如果<strong>两边一起考虑一定会顾此失彼</strong></p><ol><li>先确定右边评分大于左边的情况（也就是从前往后遍历）此时 &#x3D;&gt;</li></ol><p>​<strong>局部最优：只要右边评分比左边大，右边的孩子就多一个糖果</strong></p><p>​<strong>整体最优：相邻的孩子中，评分高的右孩子获得比左孩子更多的糖果</strong></p><p>​如果<code>ratings[i] &gt; ratings[i - 1]</code>，那么<code>[i]</code>的糖一定要比<code>[i-1]</code>的糖多一个，所以贪心：<code>candyVec[i] = candyVec[i - 1] + 1</code></p><pre><code class="Java">// 从前往后for(int i = 1;i &lt; ratings.length;++i) &#123;  if(ratings[i] &gt; ratings[i - 1]) &#123;    candyVec[i] = candyVec[i - 1] + 1;  &#125;&#125;</code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/135%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C%EF%BC%88%E4%BB%8E%E5%89%8D%E5%BE%80%E5%90%8E%EF%BC%89.png"></p><ol start="2"><li><p>再确定左孩子大于右孩子的情况（<strong>从后往前</strong>遍历）</p><blockquote><p>此处的遍历顺序，为什么不能从前往后遍历呢？</p><p>因为如果从前往后遍历，根据<code>ratings[i + 1]</code>来确定<code>ratings[i]</code>对应的糖果，那么每次都不能利用上前一次的比较结果了</p><p><strong>所以确定左孩子大于右孩子的情况一定要从后往前遍历</strong></p></blockquote></li></ol><p>如果<code>ratings[i] &gt; ratings[i + 1]</code>，此时<code>candyVec[i]</code>（第i个小孩的糖果数量）就有两个选择了，一个是<code>candyVec[i + 1] + 1</code>（从右边这个加一得到的糖果数量），一个是<code>candyVec[i]</code>（之前比较右孩子大于左孩子得到的糖果数量），此时 &#x3D;&gt;</p><p><strong>局部最优：取<code>candyVec[i1+ 1] + 1</code>和<code>candyVec[i]</code>最大的糖果数量</strong>，保证第i个小孩的糖果数量既大于左边也大于右边</p><p><strong>全局最优：相邻的孩子中，评分高的孩子获得更多的糖果</strong></p><p>取<code>candyVec[i1+ 1] + 1</code>和<code>candyVec[i]</code>最大的糖果数量。**<code>candyVec[i]</code>只有取最大的才能既保持对左边<code>candyVec[i - 1]</code>的糖果多，也比右边<code>candyVec[i + 1]</code>的糖果多**</p><pre><code class="java">// 从后往前for(int i = ratings.length - 2;i &gt;= 0;--i) &#123;  if(ratings[i] &gt; ratings[i + 1]) &#123;    candyVec[i] = Math.max(ratings[i + 1] + 1,candyVec[i]);  &#125;&#125;</code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/20221129215250.png"></p><h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public int candy(int[] ratings) &#123;        int[] candyVec = new int[ratings.length];        Arrays.fill(candyVec,1);        // 从前往后        for(int i = 1;i &lt; candyVec.length;++i) &#123;            if(ratings[i] &gt; ratings[i - 1]) &#123;                candyVec[i] = candyVec[i - 1] + 1;            &#125;        &#125;        // 从后往前        for(int i = candyVec.length - 2;i &gt;= 0;--i) &#123;            if(ratings[i] &gt; ratings[i + 1]) &#123;                candyVec[i] = Math.max(candyVec[i + 1] + 1,candyVec[i]);            &#125;        &#125;        int result = 0;        for(int i = 0;i &lt; candyVec.length;++i) &#123;            result += candyVec[i];        &#125;        return result;    &#125;&#125;</code></pre><h3 id="860、柠檬水找零"><a href="#860、柠檬水找零" class="headerlink" title="860、柠檬水找零"></a>860、柠檬水找零</h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/lemonade-change/">https://leetcode-cn.com/problems/lemonade-change/</a></p><pre><code class="markdown">在柠檬⽔摊上，每⼀杯柠檬⽔的售价为 5 美元。顾客排队购买你的产品，（按账单 bills ⽀付的顺序）⼀次购买⼀杯。每位顾客只买⼀杯柠檬⽔，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你⽀付 5 美元。 注意，⼀开始你⼿头没有任何零钱。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。⽰例 1： 输⼊：[5,5,5,10,20]输出：true解释： 前 3 位顾客那⾥，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那⾥，我们收取⼀张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那⾥，我们找还⼀张 10 美元的钞票和⼀张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 ⽰例 2：输⼊：[5,5,10]输出：true⽰例 3： 输⼊：[10,10]输出：false⽰例 4： 输⼊：[5,5,10,10,20]输出：false解释： 前 2 位顾客那⾥，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取⼀张 10 美元的钞票，然后返还 5 美元。 对于最后⼀位顾客，我们⽆法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。提⽰:- 0 &lt;= bills.length &lt;= 10000- bills[i] 不是 5 就是 10 或是 20</code></pre><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>需要维护三种金额的数量：5、10和20</p><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><blockquote><p>情况一和情况二都是固定策略</p><p>情况三（可以模拟），5 更万能 &#x3D;&gt; 优先消耗账单10和账单5</p></blockquote><p><strong>局部最优：遇到账单20，优先消耗美元10，完成本次找零</strong></p><p><strong>全局最优：完成全部账单的找零</strong></p><h4 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public boolean lemonadeChange(int[] bills) &#123;        int five = 0;        int ten = 0;        for(int bill : bills) &#123;          // 情况一            if(bill == 5) &#123;                ++five;            &#125; else if (bill == 10) &#123; // 情况二                if(five &gt; 0) &#123;                    --five;                    ++ten;                &#125; else return false;            &#125; else if(bill == 20) &#123; // 情况三              // 优先消耗                if(five &gt; 0 &amp;&amp; ten &gt; 0) &#123;                    --five;                    --ten;                &#125; else if(five &gt;= 3) &#123;                    five -= 3;                &#125; else return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><h3 id="406、根据身高重建队列"><a href="#406、根据身高重建队列" class="headerlink" title="406、根据身高重建队列"></a>406、根据身高重建队列</h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><p>题⽬链接：<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p><pre><code class="markdown">假设有打乱顺序的⼀群⼈站成⼀个队列，数组 people 表⽰队列中⼀些⼈的属性（不⼀定按顺序）。每个 people[i] = [hi, ki] 表⽰第 i 个⼈的⾝⾼为 hi ，前⾯ 正好 有 ki 个⾝⾼⼤于或等于hi 的⼈。 请你重新构造并返回输⼊数组 people 所表⽰的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个⼈的属性（queue[0] 是排在队列前⾯的⼈）。⽰例 1： 输⼊：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的⼈⾝⾼为 5 ，没有⾝⾼更⾼或者相同的⼈排在他前⾯。编号为 1 的⼈⾝⾼为 7 ，没有⾝⾼更⾼或者相同的⼈排在他前⾯。编号为 2 的⼈⾝⾼为 5 ，有 2 个⾝⾼更⾼或者相同的⼈排在他前⾯，即编号为 0 和 1 的⼈。编号为 3 的⼈⾝⾼为 6 ，有 1 个⾝⾼更⾼或者相同的⼈排在他前⾯，即编号为 1 的⼈。编号为 4 的⼈⾝⾼为 4 ，有 4 个⾝⾼更⾼或者相同的⼈排在他前⾯，即编号为 0、1、2、3 的 ⼈。编号为 5 的⼈⾝⾼为 7 ，有 1 个⾝⾼更⾼或者相同的⼈排在他前⾯，即编号为 1 的⼈。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 ⽰例 2： 输⼊：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]提⽰：- 1 &lt;= people.length &lt;= 2000- 0 &lt;= hi &lt;= 10^6- 0 &lt;= ki &lt; people.length题⽬数据确保队列可以被重建</code></pre><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>本题存在两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排序</p><blockquote><p>在<strong>135、分发糖果</strong>中：<strong>遇到两个维度权衡时，一定要先确定一个维度，再确定另外一个维度</strong></p></blockquote><p>对于本题而言</p><ul><li><p>如果按照k来从小到大排序，排完之后，发现k的排列的并不符合条件，身高h也不符合条件，两个维度都未确定</p></li><li><p>如果按照身高h从大到小排序（身高相同的k小的排前面），让高个子排前面 &#x3D;&gt; <strong>此时可以确定一个维度，就是身高，前面的节点一定都比本节点高</strong><br>此时就只需要按照k为下标重新插入队列就可以了</p><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%88%AA%E5%B1%8F2022-11-30">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/截屏2022-11-30</a> 15.57.30.png)</p></li></ul><p>以图中的<code>&#123;5,2&#125;</code>为例 &#x3D;&gt; </p><p>按照身高排序后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列</p><p>所以在按照身高从大到小排序后 &#x3D;&gt; </p><p><strong>局部最优：优先按身高高的people的k插入，插入操作后的prople满足队列属性</strong></p><p><strong>全局最优：最后都做完插入属性，整个队列满足题目队列属性</strong></p><p>整个插入过程：</p><p>排序完的people：</p><p><code>[[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</code></p><p>插⼊的过程：</p><p>插⼊[7,0]：<code>[[7,0]]</code></p><p>插⼊[7,1]：<code>[[7,0],[7,1]]</code></p><p>插⼊[6,1]：<code>[[7,0],[6,1],[7,1]]</code></p><p>插⼊[5,0]：<code>[[5,0],[7,0],[6,1],[7,1]]</code></p><p>插⼊[5,2]：<code>[[5,0],[7,0],[5,2],[6,1],[7,1]]</code></p><p>插⼊[4,4]：<code>[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</code></p><p>此时就按照题目的要求完成了重新排列</p><h4 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">class Solution &#123;    public int[][] reconstructQueue(int[][] people) &#123;      // h =&gt; 降序。k =&gt; 升序        Arrays.sort(people,(a,b) -&gt; &#123;            if(a[0] != b[0]) &#123;                return b[0] - a[0];            &#125; else &#123;                return a[1] - b[1];            &#125;        &#125;);        List&lt;int[]&gt; ans = new LinkedList&lt;&gt;();        for(int i = 0;i &lt; people.length;++i) &#123;            if(ans.size() &gt; people[i][1]) &#123;                ans.add(people[i][1],people[i]);            &#125; else &#123;                ans.add(ans.size(),people[i]);            &#125;        &#125;        return ans.toArray(new int[ans.size()][]);    &#125;&#125;</code></pre><h3 id="452、用最少数量的箭引爆气球"><a href="#452、用最少数量的箭引爆气球" class="headerlink" title="452、用最少数量的箭引爆气球"></a>452、用最少数量的箭引爆气球</h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>题⽬链接：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><pre><code class="markdown">在⼆维空间中有许多球形的⽓球。对于每个⽓球，提供的输⼊是⽔平⽅向上，⽓球直径的开始和结束坐标。由于它是⽔平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标 就⾜够了。开始坐标总是⼩于结束坐标。 ⼀⽀⼸箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出⼀⽀箭，若有⼀个⽓球的直径的开始和结束坐标为 xstart，xend， 且满⾜ xstart ≤ x ≤ xend，则该⽓球会被引爆。可以射出的⼸箭的数量没有限制。 ⼸箭⼀旦被射出之后，可以⽆限地前进。我们想找到使得所 有⽓球全部被引爆，所需的⼸箭的最⼩数量。 给你⼀个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有⽓球所必须射出的最⼩⼸箭数。⽰例 1： 输⼊：points = [[10,16],[2,8],[1,6],[7,12]]输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个⽓球，以及 x = 11 射爆另外两个⽓球 ⽰例 2： 输⼊：points = [[1,2],[3,4],[5,6],[7,8]]输出：4 ⽰例 3： 输⼊：points = [[1,2],[2,3],[3,4],[4,5]]输出：2 ⽰例 4： 输⼊：points = [[1,2]]输出：1 ⽰例 5： 输⼊：points = [[2,3],[2,3]]输出：1提⽰：- 0 &lt;= points.length &lt;= 10^4- points[i].length == 2- -2^31 &lt;= xstart &lt; xend &lt;= 2^31 - 1</code></pre><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>使用最少的弓箭 &#x3D;&gt; 只射重叠最多的气球</p><p><strong>局部最优：当气球出现重叠，一起射，所用弓箭最少</strong></p><p><strong>整体最优：把所有气球射爆所用弓箭最少</strong></p><blockquote><p>如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记嗯？</p><ul><li>真实的模拟射气球的过程，应该射一个，气球数组就<code>remove</code>一个元素，最直观</li><li>代码实现中：如果把气球排序之后，从前往后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组<code>remove</code>气球，只要记录一下箭的数量即可</li></ul></blockquote><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong></p><blockquote><p>按照气球起始位置排序或者按照气球终止位置排序皆可，只是遍历顺序的区别</p><p>此处按气球的起始位置排序</p></blockquote><p>按照起始位置排序 &#x3D;&gt; 从前往后遍历气球数组，靠左尽可能让气球重叠，若<strong>遇到气球重叠，重叠气球中右边边界的最小值之前的区间一定需要一支弓箭</strong></p><p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（⽅便起见，已经排序）</p><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%88%AA%E5%B1%8F2022-11-30">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/截屏2022-11-30</a> 16.43.41.png)</p><p>可以看出第一组重叠气球，一定是需要一支箭，气球3的左边界大于了第一组重叠气球的最小右边界，所以需要一支箭来射气球3</p><h4 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(nlogn)// 空间复杂度：O(1)class Solution &#123;    public int findMinArrowShots(int[][] points) &#123;        if(points.length == 0) return 0;        Arrays.sort(points,new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] point1, int[] point2) &#123;                if (point1[0] &gt; point2[0]) &#123;                    return 1;                &#125; else if (point1[0] &lt; point2[0]) &#123;                    return -1;                &#125; else &#123;                    return 0;                &#125;            &#125;        &#125;);        int result = 1; // points不为空，至少需要一支箭        for(int i = 1;i &lt; points.length;++i) &#123;            if(points[i][0] &gt; points[i - 1][1]) &#123; // 气球i和气球i-1不挨着，注意这里不是 &gt;=                ++result; // 需要一支箭            &#125; else &#123; // 气球i和气球i-1挨着                points[i][1] = Math.min(points[i][1],points[i - 1][1]); // 更新重叠气球最小右边界            &#125;        &#125;        return result;    &#125;&#125;</code></pre><blockquote><p>⚠️注意题⽬中说的是：满⾜ <code>xstart ≤ x ≤ xend</code>，则该⽓球会被引爆。那么说明两个⽓球挨在⼀起 ，不重叠也可以⼀起射爆，</p><p>所以代码中 <code>if (points[i][0] &gt; points[i - 1][1]) </code>不能是<code>&gt;=</code></p></blockquote><h3 id="435、无重叠区间"><a href="#435、无重叠区间" class="headerlink" title="435、无重叠区间"></a>435、无重叠区间</h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><p>题⽬链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p><pre><code class="markdown">给定⼀个区间的集合，找到需要移除区间的最⼩数量，使剩余区间互不重叠。注意:可以认为区间的终点总是⼤于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 ⽰例 1:输⼊: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 ⽰例 2:输⼊: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 ⽰例 3:输⼊: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是⽆重叠的了。</code></pre><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p><strong>排序</strong></p><ul><li>按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大 &#x3D;&gt; <strong>按照右边界排序，从左向右遍历，优先选择右边界小的</strong></li><li>按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大 &#x3D;&gt; <strong>按照左边界排序，从右向左遍历，优先选择左边界大的</strong>*</li></ul><blockquote><p>备注：题目只要求求出移除区间个数，没有必要真实的模拟删除区间</p><p><strong>按右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong> &#x3D;&gt; 此时问题就是要求非交叉区间的最大个数</p></blockquote><p>按右边界排序后</p><p><strong>局部最优：优先选择右边界小的区间，所以从左向右遍历，留给下一个区间大一些，从而尽量避免交叉</strong></p><p><strong>全局最优：选取最多的非交叉区间</strong>*</p><blockquote><p>记录非交叉区间的个数技巧：</p><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%88%AA%E5%B1%8F2022-12-01">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/截屏2022-12-01</a> 07.52.51.png)</p><p>区间1，2，3，4，5，6都按照右边界排序</p><p>每次取非交叉区间时，都是取右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间1结束的位置</p><p>接下来就是找大于区间1结束为止的区间，是从区间4开始区间4结束之后，再找到区间6，所以一共记录非交叉区间的个数是3个</p><p>总共区间个数为6，减去非交叉区间的个数3，移除区间的最小数量就是3</p></blockquote><h4 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(nlogn)// 空间复杂度：O(1)class Solution &#123;    public int eraseOverlapIntervals(int[][] intervals) &#123;        if(intervals.length == 0) return 0;                // 按照右边界排序        Arrays.sort(intervals,(a,b) -&gt; a[1] - b[1]);        int count = 1; // 记录非交叉区间个数        int end = intervals[0][1]; // 记录区间分割点        for(int i = 1;i &lt; intervals.length;++i) &#123;            if(end &lt;= intervals[i][0]) &#123;                ++count;                end = intervals[i][1];            &#125;        &#125;        return intervals.length - count;    &#125;&#125;</code></pre><h3 id="763、划分字母区间"><a href="#763、划分字母区间" class="headerlink" title="763、划分字母区间"></a>763、划分字母区间</h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><p>题⽬链接： <a href="https://leetcode-cn.com/problems/partition-labels/">https://leetcode-cn.com/problems/partition-labels/</a></p><pre><code class="markdown">字符串 S 由⼩写字母组成。我们要把这个字符串划分为尽可能多的⽚段，同⼀字母最多出现在⼀个⽚段中。返回⼀个表⽰每个字符串⽚段的长度的列表。 ⽰例： 输⼊：S = &quot;ababcbacadefegdehijhklij&quot;输出：[9,7,8]解释： 划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。 每个字母最多出现在⼀个⽚段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的⽚段数较少。提示：- S的长度在[1, 500]之间。 - S只包含⼩写字母 &#39;a&#39; 到 &#39;z&#39; 。</code></pre><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>，此时前面出现过所有字母，最远也就到这个边界了</p><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%88%AA%E5%B1%8F2022-12-01">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/截屏2022-12-01</a> 22.53.30.png)</p><h4 id="实现-13"><a href="#实现-13" class="headerlink" title="实现"></a>实现</h4><p>Java代码</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public List&lt;Integer&gt; partitionLabels(String s) &#123;        int[] hash = new int[26]; // i为字符，hash[i]记录字符出现的最后位置        int len = s.length();        for(int i = 0;i &lt; len;++i) &#123;            hash[s.charAt(i) - &#39;a&#39;] = i;        &#125;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        int right = 0;        int left = 0;        for(int i = 0;i &lt; len;++i) &#123;            right = Math.max(right,hash[s.charAt(i) - &#39;a&#39;]); // 找到字符的最远边界            if(i == right) &#123;                ans.add(right - left + 1);                left = i + 1;            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="56、合并区间"><a href="#56、合并区间" class="headerlink" title="56、合并区间"></a>56、合并区间</h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>题⽬链接：<a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a></p><pre><code class="markdown">给出⼀个区间的集合，请合并所有重叠的区间。 ⽰例 1:输⼊: intervals = [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].⽰例 2:输⼊: intervals = [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 提⽰：- `intervals[i][0] &lt;= intervals[i][1]`</code></pre><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><blockquote><p>直观感觉：此题一定要排序，那么按照左边界排序抑或是按照右边界排序都可以</p><p><strong>此处按左边界排序</strong></p></blockquote><p><strong>局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间</strong></p><p><strong>整体最优：合并所有的重叠区间</strong></p><p>按照左边界从小到大排序之后，如果<code>interval[i][0] &lt; interval[i - 1][1]</code>，即<code>interval[i]左边界 &lt; interval[i - 1]右边界</code>，则一定有重复，因为interval[i]的左边界一定是大于等于interval[i - 1]的右边界</p><p>即：interval[i]的左边界在interval[i - 1]左边界和右边界的范围内，那么一定有重复（如图，下图是按照左边界排序后的）</p><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%88%AA%E5%B1%8F2022-12-02">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/截屏2022-12-02</a> 10.34.51.png)</p><p>模拟合并区间：用合并区间后左边界和右边界，作为一个新的区间，加入result；如果没有合并就把原区间加入result</p><h4 id="实现-14"><a href="#实现-14" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int[][] merge(int[][] intervals) &#123;        if(intervals.length &lt;= 1) return intervals;        Arrays.sort(intervals,(a,b) -&gt; a[0] - b[0]);        List&lt;int[]&gt; ans = new ArrayList&lt;&gt;();        for(int i = 0;i &lt; intervals.length;++i) &#123;            int left = intervals[i][0];            int right = intervals[i][1];            if(ans.size() == 0 || ans.get(ans.size() - 1)[1] &lt; left) &#123;                 ans.add(new int[] &#123;left,right&#125;);            &#125; else &#123; // 合并区间                ans.get(ans.size() - 1)[1] = Math.max(ans.get(ans.size() - 1)[1],right);            &#125;        &#125;        return ans.toArray(new int[ans.size()][]);    &#125;&#125;</code></pre><h3 id="738、单调递增的数字"><a href="#738、单调递增的数字" class="headerlink" title="738、单调递增的数字"></a>738、单调递增的数字</h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode.cn/problems/monotone-increasing-digits/">https://leetcode.cn/problems/monotone-increasing-digits/</a></p><pre><code class="markdown">给定⼀个⾮负整数 N，找出⼩于或等于 N 的最⼤的整数，同时这个整数需要满⾜其各个位数上的数字是单调递增。 （当且仅当每个相邻位数上的数字 x 和 y 满⾜ x &lt;= y 时，我们称这个整数是单调递增的。）⽰例 1:输⼊: N = 10输出: 9⽰例 2:输⼊: N = 1234输出: 1234⽰例 3:输⼊: N = 332输出: 299说明: N 是在 [0, 10^9] 范围内的⼀个整数。</code></pre><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>题目要求小于等于N的最大单调递增的整数，举一个二位数的例子：</p><p>例如：98，一旦出现<code>strNum[i - 1] &gt; strNum[i]</code>的情况（非单调递增），首先想让<code>strNum[i - 1]--</code>，然后给<code>strNum[i]</code>赋值为9，这样这个整数就是89，即小于等于98的最大单调递增整数</p><p><strong>局部最优：遇到<code>strNum[i - 1] &gt; strNum[i]</code>，让<code>strNum[i - 1]--</code>，然后给<code>strNum[i]</code>赋值为9，可以保证这两位变成最大单调递增整数</strong></p><p><strong>全局最优：得到小于等于N的最大单调的整数</strong></p><p>但这里局部最优推出全局最优，还需要其他条件，即<strong>遍历顺序</strong>以及<strong>标记从哪一位开始统一改成9</strong></p><p>下面考虑是从前往后遍历还是从后往前遍历</p><ul><li>从前往后遍历<br>遇到<code>strNum[i - 1] &gt; strNum[i]</code>的情况，让<code>strNum[i - 1]--</code>，但此时如果<code>strNum[i - 1]</code>减一，可能又小于<code>strNum[ i - 2]</code></li></ul><blockquote><p>举个例子：</p><p>数字332，从前往后遍历的话，那么就变成329，但是此时2又小于第一位的3，真正的结果是299</p></blockquote><p>​&#x3D;&gt; <strong>从前往后遍历会改变已经遍历过的结果</strong></p><ul><li><p>从后往前遍历</p><p>可以重复利用上次比较得出的结果</p></li></ul><blockquote><p>从后往前遍历332的数值变化为：332 &#x3D;&gt; 329 &#x3D;&gt; 299</p></blockquote><p>&#x3D;&gt; 确定了遍历顺序之后，此时局部最优可以推出全局最优，并且找不出反例</p><h4 id="实现-15"><a href="#实现-15" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution &#123;    public int monotoneIncreasingDigits(int n) &#123;        char[] num = String.valueOf(n).toCharArray();        int len = num.length;      // flag用于标记赋值9从哪里开始      // 设置默认值，防止第二个for循环在flag没有被赋值的情况下执行        int flag = len;        for(int i = len - 1;i &gt; 0;i--) &#123;            if(num[i - 1] &gt; num[i]) &#123;                flag = i;                num[i - 1]--;            &#125;        &#125;        for(int i = flag;i &lt; len;i++) &#123;            num[i] = &#39;9&#39;;        &#125;        return Integer.parseInt(new String(num));    &#125;&#125;</code></pre><h3 id="714、买卖股票的最佳时机含手续费"><a href="#714、买卖股票的最佳时机含手续费" class="headerlink" title="714、买卖股票的最佳时机含手续费"></a>714、买卖股票的最佳时机含手续费</h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><p>题⽬链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><pre><code class="markdown">给定⼀个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格；⾮负整数 fee 代表了交易股票的⼿续费⽤。你可以⽆限次地完成交易，但是你每笔交易都需要付⼿续费。如果你已经购买了⼀个股票， 在卖出它之前你就不能再继续购买股票了。返回获得利润的最⼤值。 注意：这⾥的⼀笔交易指买⼊持有并卖出股票的整个过程，每笔交易你只需要为⽀付⼀次⼿续费。⽰例 1:输⼊: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最⼤利润: 在此处买⼊ prices[0] = 1在此处卖出 prices[3] = 8在此处买⼊ prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8注意：- 0 &lt; prices.length &lt;= 50000.- 0 &lt; prices[i] &lt; 50000.- 0 &lt;= fee &lt; 50000.</code></pre><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>本题相对于<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122、买卖股票的最佳时机<strong>II</strong></a>，多了一个条件：手续费</p><p>在<code>122.买卖股票的最佳时机II</code>中使⽤贪⼼策略不⽤关⼼具体什么时候买卖，只要收集每天的正利润，最后稳稳的就是最⼤利润了。</p><p>⽽本题有了⼿续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不⾜以⼿续费的情况。</p><p>如果使⽤贪⼼策略，就是最低值买，最⾼值（如果算上⼿续费还盈利）就卖。 </p><p>此时⽆⾮就是要找到两个点，买⼊⽇期，和卖出⽇期。</p><ul><li>买入时间：遇到最低点就记录一下</li><li>卖出时间：<code>当前价格</code>大于<code>最低价格+手续费</code>，就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天</li></ul><p>做收获利润操作时的三种情况</p><ul><li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润</li><li>情况二：前一天时收获利润区间里的最后一天（相当于真正的卖出），今天就要记录最小价格</li><li>情况三：不做操作，保持原有状态（买入、卖出、不买不卖）</li></ul><h4 id="实现-16"><a href="#实现-16" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">// 时间复杂度：O(n)// 空间复杂度：O(1)class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        int result = 0;        int minPrice = prices[0]; // 记录最低价格        for(int i = 1;i &lt; prices.length;i++) &#123;            // 情况二 =&gt; 相当于买入            if(minPrice &gt; prices[i]) &#123;                 minPrice = prices[i];            &#125;            /*            // 情况三 =&gt; 保持原有状态（因为此时买则不便宜，卖则亏本）            if(prices[i] &gt;= minPrice &amp;&amp; prices[i] &lt;= minPrice + fee) &#123;                continue;            &#125;            */            // 情况一 =&gt; 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出            if(prices[i] &gt; minPrice + fee) &#123;                result += prices[i] - minPrice - fee;                minPrice = prices[i] - fee; // 关键步骤            &#125;        &#125;        return result;    &#125;&#125;</code></pre><blockquote><p>针对情况一的操作，因为如果还在收获利润的区间里，表示并不是真正的卖出，而计算利润每次都要减去手续费，**所以要让<code>minPrice = prices[i] - fee</code>**，这样在明天收获利润时，才不会多减一次手续费</p><p>情况三代码可删</p></blockquote><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>动态规划</strong></p><p>Java代码：</p><pre><code class="java">class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        int holdStock = -prices[0]; // 持有股票        int saleStock = 0; // 卖出股票        for(int i = 1;i &lt; prices.length;i++) &#123;            int preHoldStock = holdStock;            holdStock = Math.max(holdStock,saleStock - prices[i]);            saleStock = Math.max(saleStock,preHoldStock + prices[i] - fee);        &#125;        return saleStock;    &#125;&#125;</code></pre><h3 id="968、监控二叉树"><a href="#968、监控二叉树" class="headerlink" title="968、监控二叉树"></a>968、监控二叉树</h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-cameras/">https://leetcode.cn/problems/binary-tree-cameras/</a></p><p>给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/bst_cameras_01.png"><br>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。</p><p>示例 2：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/bst_cameras_02.png"><br>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p><p>提示：</p><ul><li>给定树的节点数的范围是 [1, 1000]。</li><li>每个节点的值都是 0。</li></ul><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>如何放置，才能让摄像头最少？</p><p><strong>题目示例中的摄像头都没有放在叶子结点上</strong> &#x3D;&gt; 摄像头可以覆盖上中下三层，如果把摄像头放在叶子结点上，就浪费了一层的覆盖</p><blockquote><p>为什么不从头节点开始看起，而从叶子结点开始看起呢？</p><p>因为头节点放不放摄像头也就省下一个摄像头，叶子结点放不放摄像头省下的摄像头数量时指数阶级的 &#x3D;&gt; <strong>要从下往上看</strong></p></blockquote><p><strong>局部最优：从叶子结点的父节点安摄像头，所用摄像头最少</strong></p><p><strong>整体最优：全部摄像头数量所用最少</strong></p><p>大体思路：先给叶子结点父节点放个摄像头，然后隔两个节点放一个摄像头，直到二叉树头节点</p><p>难点：</p><ul><li>二叉树的遍历</li><li>如何隔两个节点放一个摄像头</li></ul><p><strong>1. 确定遍历顺序</strong></p><p>二叉树中从下往上遍历 &#x3D;&gt; 可以使用<strong>后序遍历</strong>（左右中），可以在<strong>回溯</strong>的过程中从下往上进行推导</p><pre><code class="java">// 后序遍历private int traversal(TreeNode curNode) &#123;  // 空节点，该节点有覆盖  if(终止条件) return ;    int left = traversal(curNode.left); // 左  int right = traversal(curNode.right); // 右    逻辑处理// 中  return ;&#125;</code></pre><p><strong>2. 如何隔两个节点放一个摄像头</strong></p><p>此时需要状态转移方程（单纯的状态转移，没有择优的过程）</p><p>每个节点的状态 &#x3D;&gt; 表示规则：</p><ul><li>本节点无覆盖 &#x3D;&gt; 0</li><li>本节点有摄像头 &#x3D;&gt; 1</li><li>本节点有覆盖 &#x3D;&gt; 2</li></ul><blockquote><p>本节点无摄像头 &#x3D;&gt; 无覆盖 或者 有覆盖，归根到底是三个状态</p></blockquote><p>在遍历树的过程中，会遇到空节点，空节点的状态 &#x3D;&gt; </p><p>回归本质，为了让摄像头的数量最少，我们要尽量让叶子结点的父节点安装摄像头，这样才能让摄像头的数量最少。</p><p>那么空节点不能是无覆盖的状态，否则叶子结点就要放置摄像头了；空节点也不能是有摄像头的状态，否则叶子结点的父节点就灭有必要放摄像头了，而是把摄像头放在叶子节点的爷爷节点上 </p><p>&#x3D;&gt; <strong>空节点的状态只能是有覆盖</strong>，这样就可以在叶子结点的父节点放摄像头</p><p><strong>3.递推关系</strong></p><p>递归的终止条件 &#x3D;&gt; 遇到空节点，此时应该返回2（有覆盖的状态）</p><pre><code class="java">if(cur == null) return 2;</code></pre><p><strong>4.单层处理逻辑</strong></p><ul><li>情况一：左右节点都有覆盖<br>左节点和右节点都有覆盖，此时中间节点就是无覆盖的状态<br>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%88%AA%E5%B1%8F2022-12-03">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/截屏2022-12-03</a> 11.36.06.png)</li></ul><pre><code class="java">// 左右节点都有覆盖if(left == 2 &amp;&amp; right == 2) return 0;</code></pre><ul><li><p>情况二：左右节点至少有一个无覆盖的情况</p><p>若是以下情况，则中间节点（父节点）应该放置摄像头</p><ul><li><code>left == 0 &amp;&amp; right == 0</code> &#x3D;&gt; 左右节点无覆盖</li><li><code>left == 1 &amp;&amp; right == 0</code> &#x3D;&gt; 左节点有摄像头，右节点无覆盖</li><li><code>left == 0 &amp;&amp; right == 1</code> &#x3D;&gt; 左节点无覆盖，右节点有摄像头</li><li><code>left == 0 &amp;&amp; right == 2</code> &#x3D;&gt; 左节点无覆盖，右节点覆盖</li><li><code>left == 2 &amp;&amp; right == 0</code> &#x3D;&gt; 左节点覆盖，右节点无覆盖</li></ul></li></ul><p>&#x3D;&gt; 此时摄像头加一，并且返回1，代表中间节点有摄像头</p><pre><code class="java">if(left == 0 || right == 0) &#123;  ++result;  return 1;&#125;</code></pre><ul><li><p>情况三：左右节点至少有一个节点有摄像头</p><p>若是以下情况，其实就是左右孩子节点有一个摄像头了，那么其父节点就应该是2（覆盖的状态）</p><ul><li><code>left == 1 &amp;&amp; right == 2</code> &#x3D;&gt; 左节点有摄像头，有节点有覆盖</li><li><code>left == 2 &amp;&amp; right == 1</code> &#x3D;&gt; 左节点有覆盖，右节点有摄像头</li><li><code>left == 1 &amp;&amp; right == 1</code> &#x3D;&gt; 左右节点都有摄像头</li></ul></li></ul><pre><code class="java">if(left == 1 || right == 1) &#123;  return 2;&#125;</code></pre><blockquote><p><code>left == 1 &amp;&amp; right == 0</code> &#x3D;&gt; 情况二已经判断过</p><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%88%AA%E5%B1%8F2022-12-03">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/截屏2022-12-03</a> 11.47.02.png)</p></blockquote><ul><li><p>情况四：头节点没有覆盖</p><p>递归结束之后，可能头节点还有一个无覆盖的情况</p><p>![](<a href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%88%AA%E5%B1%8F2022-12-03">https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/截屏2022-12-03</a> 11.48.12.png)</p><p>所以递归结束之后，还要判断根节点，如果没有覆盖，则<code>result++</code></p></li></ul><pre><code class="java">if(traversal(root) == 0) &#123;  // root未覆盖  result++;&#125;</code></pre><h4 id="实现-17"><a href="#实现-17" class="headerlink" title="实现"></a>实现</h4><p>Java代码：</p><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */class Solution &#123;    int result;    public int minCameraCover(TreeNode root) &#123;        result = 0;        // 情况四：头节点未覆盖        if(travelsal(root) == 0) &#123;            ++result;        &#125;        return result;    &#125;    private int travelsal(TreeNode curNode) &#123;        /**            - 本节点无覆盖 =&gt; 0            - 本节点有摄像头 =&gt; 1            - 本节点有覆盖 =&gt; 2         */        // 空节点，返回已覆盖        if(curNode == null) &#123;            return 2;        &#125;                int left = travelsal(curNode.left);        int right = travelsal(curNode.right);        // 情况一：左右节点都有覆盖        if(left == 2 &amp;&amp; right == 2) &#123;            return 0;        &#125;        // 情况二：左右节点至少有一个无覆盖        if(left == 0 || right == 0) &#123;            ++result;            return 1;        &#125;        // 情况三： 左右节点至少有一个有摄像头        if(left == 1 || right == 1) &#123;            return 2;        &#125;        // 为了语法上通过        return -1;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet技术简述</title>
      <link href="/2022/11/27/Servlet%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"/>
      <url>/2022/11/27/Servlet%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><blockquote><p>参考文章 &#x3D;&gt; <a href="https://www.cnblogs.com/whgk/category/947929.html">Java Web - 随笔分类 - 有梦想的老王 - 博客园 (cnblogs.com)</a></p><p>Servlet技术笔记</p></blockquote><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><ul><li>参考文章 <a href="https://www.cnblogs.com/whgk/p/6399262.html">Java Web(一) Servlet详解！！ - 有梦想的老王 - 博客园 (cnblogs.com)</a></li></ul><h3 id="一、servlet"><a href="#一、servlet" class="headerlink" title="一、servlet"></a>一、servlet</h3><h4 id="1⃣️-概述"><a href="#1⃣️-概述" class="headerlink" title="1⃣️ 概述"></a>1⃣️ 概述</h4><ul><li>Servlet时运行在web服务器端的应用程序，使用Java编写</li><li>Servlet对象主要封装了对HTTP请求的处理，它的运行需要<strong>Servlet容器</strong>（比如Tomcat）的支持</li><li><strong>Servlet</strong>由<strong>Servlet容器</strong>进行管理，Servlet容器将Servlet动态加载到服务器上，与HTTP协议相关的Servlet使用HTTP请求和HTTP请求和HTTP响应与客户端进行交互</li><li>Servlet的请求首先会被HTTP服务器（比如Apache）接收，HTTP服务器只负责静态HTML界面的解析，而Servlet的请求则转交给Servlet容器，Servlet容器会根据请求路径以及Servlet之间的映射关系，调用相应的Servlet，Servlet将处理的结果返回给Servlet容器，并通过HTTP服务器将响应传输给客户端</li></ul><span id="more"></span><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><pre><code class="mermaid">graph LR;A[客户端] --&gt; |HTTP请求| B[HTTP服务器]B --&gt; C[Servlet服务器]C --&gt; D[Servlet]D --&gt; CC --&gt; BB --&gt; |HTTP响应| A</code></pre><h4 id="2⃣️-Servlet接口"><a href="#2⃣️-Servlet接口" class="headerlink" title="2⃣️ Servlet接口"></a>2⃣️ Servlet接口</h4><ul><li>Servlet就是实现了<strong>Servlet接口</strong>的类，它由Web服务器创建并调用，用于接收和响应用户的请求</li><li>在Servlet接口中定义了五个抽象方法</li></ul><table><thead><tr><th>方法声明</th><th>说明</th></tr></thead><tbody><tr><td>void init(ServletConfig config)</td><td>Servlet实例化后，Servlet容器调用该方法完成Servlet的初始化工作</td></tr><tr><td>ServletConfig getServletConfig()</td><td>获取Servlet对象的配置信息</td></tr><tr><td>String getServletInfo()</td><td>返回包含Servlet信息的字符串，比如作者、版权等</td></tr><tr><td>void service(ServletRequest req,ServletResponse resp)</td><td>负责响应用户的请求，当容器接收到客户端访问Servlet对象的请求时就会调用此方法。容器会构造一个表示客户端请求信息的<strong>ServletRequest</strong>对象和一个用于响应客户端的<strong>ServletResponse</strong>对象作为<strong>参数</strong>传递给**service()**方法，在service()方法中可以通过ServletRequest对象的到客户端的相关信息和请求信息，在对请求进行处理后，调用ServletResponse对象的方法设置响应信息</td></tr><tr><td>void destroy()</td><td>负责释放Servlet对象占用的资源，当服务器关闭或者Servlet对象被移除时会销毁Servlet对象，此时会调用此方法</td></tr></tbody></table><blockquote><p>注意⚠️：编写的Servlet类必须实现Servlet接口或者继承Servlet接口的实现类（比如<strong>GenericServlet</strong>、<strong>HttpServlet</strong>），这两个类都是<strong>抽象类</strong>并且HttpServlet继承了GenericServlet，其中GenericServlet存在一个抽象方法**service()**，而HttpServlet不存在抽象方法</p></blockquote><ul><li><p>编写Servlet类的方式</p><ol><li><p><strong>实现Servlet接口</strong>，需要重写Servlet接口里面的所有方法</p></li><li><p><strong>继承GenericServlet抽象类</strong>，必须**重写service()**方法，其他方法也可以重写</p></li><li><p><strong>继承HttpServlet抽象类</strong>，此时不需要重写service()方法，因为HttpServlet在service()方法中调用了另外一个**重载的service()<strong>方法，这个重载的方法内会根据参数选择相应的方法（比如</strong>doGet()<strong>、</strong>doPost()**）&#x3D;&gt; 可以重写doGet()或者doPost()方法实现功能</p></li><li><p><strong style="color:red">通常情况下使用继承HttpServlet抽象类的方式编写Servlet类</strong></p></li><li><p>实例</p><pre><code class="java">public class ServletDemo extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;doGet()方法执行了&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;</code></pre></li></ol></li><li><p>Servlet线程安全问题</p><ul><li><p>在实现Servlet的类中如果存在自定义的成员变量，并且在service()方法中操作了这个变量时可能会出现线程安全问题，参考文章<a href="https://www.cnblogs.com/kaleidoscope/p/9628969.html">Servlet线程安全问题 - kaleidoscopic - 博客园 (cnblogs.com)</a></p></li><li><p>解决方法</p><ul><li>将成员变量改为定义在方法内部的局部变量</li><li>使用sychronized锁</li></ul></li></ul></li><li><p>HttpServlet常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Protected void doGet(HttpServletRequest req,HttpServletResponse resp)</td><td>用于处理Get类型的Http请求</td></tr><tr><td>Protected void doPost(HttpServletRequest req,HttpServletResponse resp)</td><td>用于处理Post类型的Http请求</td></tr><tr><td>Protected void doPut(HttpServletRequest req,HttpServletResponse resp)</td><td>用于处理Put类型的Http请求</td></tr></tbody></table></li><li><p>关系视图</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5809/ServletDiagram.png" alt="ServletDiagram"></p></li></ul><h4 id="3⃣️Servlet生命周期"><a href="#3⃣️Servlet生命周期" class="headerlink" title="3⃣️Servlet生命周期"></a>3⃣️Servlet生命周期</h4><ul><li><p>图示</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5809/ServletLive.png"></p></li><li><p>Servlet生命周期大致分为三个阶段：初始化阶段、运行阶段、销毁阶段</p><ol><li><p>初始化阶段</p><p>当客户端向Servlet容器发出HTTP请求访问Servlet时</p><ul><li>Servlet容器首先<strong>解析请求</strong>，检查内存中是否存在该Servlet对象，如果存在，直接使用该Servlet对象；不存在，创建Servlet实例对象；</li><li>然后调用**init()**方法完成Servlet的初始化</li></ul><blockquote><p>⚠️在Servlet的整个生命周期中，<strong>init()方法只会被调用一次</strong></p></blockquote></li><li><p>运行阶段</p><ul><li>Servlet容器为客户端请求创建代表HTTP请求的<strong>ServletRequest</strong>对象和代表HTTP响应的<strong>ServletResponse</strong>对象 &#x3D;&gt; 作为参数传递给**service()**方法</li><li>service()方法从ServletRequest对象获取客户端请求并处理该请求，通过ServletResponse对象生成响应结果</li></ul><blockquote><p>在Servlet整个生命周期内，对于Servlet的每一次访问请求，Servlet容器都会调用一次Servlet的service()方法，并且创建新的ServletRequest对象和ServletResponse对象 &#x3D;&gt; <strong>service()方法在Servlet整个生命周期中会被调用多次</strong></p></blockquote></li><li><p>销毁阶段</p><p>当服务器关闭或者Web应用被移除出容器是，Servlet随着Web应用的销毁而销毁</p><ul><li>在销毁Servlet之前，Servlet容器会调用Servlet的destroy()方法 &#x3D;&gt; 让Servlet对象释放它所占用的资源</li></ul><blockquote><p>⚠️</p><ul><li><p>在Servlet的整个生命周期中，<strong>destroy()方法只会被调用一次</strong></p></li><li><p>Servlet对象一旦创建就会驻留在内存中等待客户端的访问，直到服务器关闭或者Web应用被移除出容器时Servlet对象才会被销毁</p></li></ul></blockquote></li></ol></li></ul><h4 id="4⃣️Servlet配置"><a href="#4⃣️Servlet配置" class="headerlink" title="4⃣️Servlet配置"></a>4⃣️Servlet配置</h4><ul><li><p>使用<code>web.xml</code>配置Servlet</p><ol><li><p>在<code>web.xml</code>文件中，通过<code>&lt;servlet&gt;&lt;/servlet&gt;</code>标签进行注册，该标签下包含若干个字元素，功能如下</p><table><thead><tr><th>元素</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;servlet-name&gt;&lt;/servlet-name&gt;</code></td><td>String</td><td>指定Servlet名称，一般与Servlet类同名，要求唯一</td></tr><tr><td><code>&lt;servlet-class&gt;&lt;/servlet-class&gt;</code></td><td>String</td><td>指定Servlet位置，一般是全类名</td></tr><tr><td><code>&lt;description&gt;&lt;/description&gt;</code></td><td>String</td><td>指定Servlet的详细信息</td></tr><tr><td><code>&lt;display-name&gt;&lt;/display-name&gt;</code></td><td>String</td><td>指定Servlet的显示名</td></tr></tbody></table></li><li><p>把Servlet映射到URL地址 &#x3D;&gt; 使用<code>&lt;servlet-mapping&gt;&lt;/servlet-mappint&gt;</code>进行映射，在<code>&lt;servlet-mapping&gt;</code>元素下配置<code>&lt;servlet-name&gt;&lt;/servlet-name&gt;</code>指出Servlet的名称，<strong>需要和之前在<code>&lt;servlet&gt;</code>标签下注册的相同</strong>；配置<code>&lt;url-pattern&gt;&lt;/url-pattern&gt;</code>映射URL地址，<strong>地址前需要添加&#x2F;</strong></p></li><li><p>实例</p><pre><code class="xml">&lt;servlet&gt;    &lt;!--指出Servlet名称--&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!--指出Servlet全类名--&gt;    &lt;servlet-class&gt;com.demo.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;!--和servlet标签下的名称一致--&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!--映射地址，必须加斜杠--&gt;    &lt;url-pattern&gt;/ServletDemo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre></li></ol></li><li><p>使用注解配置Servlet</p><ol><li><p>**<code>@WebServlet</code>**注解用于替代<code>web.xml</code>文件中的<code>&lt;servlet&gt; &lt;servlet-mapping&gt;</code>等标签，该注解会在项目部署时被容器处理，容器会根据具体的属性配置将响应的类部署为Servlet</p></li><li><p>**<code>@WebServlet</code>**常用属性</p><table><thead><tr><th>属性声明</th><th>功能</th></tr></thead><tbody><tr><td>String name</td><td>指定Servlet的name属性，等价于<code>&lt;servlet-name&gt;</code>，如果没有显示置顶，则取值为类的全限定名（包名 + 类型名）</td></tr><tr><td>String[]  value</td><td>等价于<code>&lt;url-pattern&gt;</code></td></tr><tr><td>String[] urlPatterns</td><td>功能同value，二者不能混合使用</td></tr><tr><td>int loadOnStartup</td><td>指定Servlet的加载时机，等价于<code>&lt;load-on-startup&gt;</code></td></tr><tr><td>WebInitParam[] initParams</td><td>指定一组Servlet初始化参数，等价于<code>&lt;init-param&gt;</code>，其中<code>@WebInitParam</code>也是一种注解</td></tr></tbody></table></li><li><p>实例</p><pre><code class="java">@WebServlet(name = &quot;ServletDemo&quot;,urlPatterns = &quot;/ServletDemo&quot;,initParams = &#123;@WebInitParam(name = &quot;encoding&quot;,value = &quot;UTF-8&quot;),@WebInitParam(name = &quot;desc&quot;,value = &quot;this is ServletDemo&quot;)&#125;)public class ServletDemo extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;ServletDemo运行了&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;</code></pre></li></ol></li></ul><h4 id="5⃣️Servlet创建时机"><a href="#5⃣️Servlet创建时机" class="headerlink" title="5⃣️Servlet创建时机"></a>5⃣️Servlet创建时机</h4><ul><li><p>第一次访问时创建</p><p>优势：减少服务器内存的浪费</p><p>弊端：如果有一些需要在应用加载时就做的初始化操作，无法完成</p></li><li><p>服务器加载时创建</p><p>优势：提前创建好对象，提高首次执行的效率，可以完成一些应用加载时要做的初始化工作</p><p>弊端：对服务器内存占用，影响服务器的启动效率</p></li></ul><ul><li><p>修改Servlet创建时机</p><p>在<code>web.xml</code>文件的<code>&lt;servlet&gt;</code>标签中添加<code>&lt;load-on-startup&gt;val&lt;/load-on-startup&gt;</code>标签，其中val是一个整数</p><blockquote><p><strong style="color:red">正整数表示在服务器加载时创建，值越小优先级越高，负整数或者不填表示第一次访问时创建</strong></p></blockquote></li></ul><h4 id="6⃣️默认Servlet"><a href="#6⃣️默认Servlet" class="headerlink" title="6⃣️默认Servlet"></a>6⃣️默认Servlet</h4><ul><li>默认Servlet时服务器提供的一个Servlet，它配置在Tomcat的conf目录中的<code>web.xml</code>文件中</li><li>它的映射路径是<code>/</code>，在接收请求时，首先会在项目中的<code>web.xml</code>文件查找映射配置，找到则执行，未找到时去找默认的Servlet，由默认Servlet处理</li></ul><h3 id="二、ServletConfig"><a href="#二、ServletConfig" class="headerlink" title="二、ServletConfig"></a>二、ServletConfig</h3><h4 id="1⃣️概述"><a href="#1⃣️概述" class="headerlink" title="1⃣️概述"></a>1⃣️概述</h4><ul><li><p>ServletConfig是一个接口</p></li><li><p>当Tomcat初始化一个Servlet时，会将该Servlet的配置好信息封装到一个ServletConfig对象中，通过调用init(ServletConfig config)方法将ServletConfig对象传递给Servlet，ServletConfig的生命周期和Servlet一样</p></li><li><p>ServletConfig封装的配置信息是<code>键值对</code>形式</p></li><li><p>常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getInitParameter(String name)</td><td>根据参数名返回对应的参数值</td></tr><tr><td>Enumeration getInitParameterNames()</td><td>返回一个封装了所有参数名Enumeration对象</td></tr><tr><td>ServletContext getServletContext()</td><td>返回当前代表Web应用的ServletContext对象</td></tr><tr><td>String getServletName()</td><td>返回Servlet的名称</td></tr></tbody></table></li></ul><h4 id="2⃣️ServletConfig配置"><a href="#2⃣️ServletConfig配置" class="headerlink" title="2⃣️ServletConfig配置"></a>2⃣️ServletConfig配置</h4><ul><li><p>配置SerlvetConfig是在<code>web.xml</code>文件中的<code>&lt;serlvet&gt;&lt;/servlet&gt;</code>标签下进行的，需要使用<code>&lt;init-param&gt;&lt;/init-param&gt;</code>标签将参数名和参数名囊括，表示一个键值对，其中参数名 &#x3D;&gt; <code>&lt;param-name&gt;&lt;/param-name&gt;</code>，参数值 &#x3D;&gt; <code>&lt;param-value&gt;&lt;/param-value&gt;</code></p><blockquote><p>一个<code>&lt;init-param&gt;&lt;/init-param&gt;</code>只能表示一个键值对</p></blockquote></li><li><p>实例</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.juzi.ServletConfigDemo&lt;/servlet-class&gt;    &lt;!--配置encoding参数，使用一个init-param标签--&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!--配置desc参数，使用一个init-param标签--&gt;    &lt;init-param&gt;        &lt;param-name&gt;desc&lt;/param-name&gt;        &lt;param-value&gt;this is ServletConfigDemo&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;        &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt;        &lt;url-pattern&gt;/ServletConfigDemo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre></li></ul><h3 id="三、ServletContext"><a href="#三、ServletContext" class="headerlink" title="三、ServletContext"></a>三、ServletContext</h3><h4 id="1⃣️概述-1"><a href="#1⃣️概述-1" class="headerlink" title="1⃣️概述"></a>1⃣️概述</h4><ul><li>Servlet容器启动时会为每一个Web应用创建一个唯一的ServletContext对象代表当前Web应用，ServletContext对象<strong>封装了当前Web应用的所有信息</strong></li><li>ServletContext可以配置和获得应用的全局初始化参数，可以实现多个Servlet之间的数据共享</li><li>生命周期：应用加载时创建，应用停止时销毁</li></ul><h4 id="2⃣️ServletContext配置"><a href="#2⃣️ServletContext配置" class="headerlink" title="2⃣️ServletContext配置"></a>2⃣️ServletContext配置</h4><ul><li><p>在<code>web.xml</code>文件的<code>&lt;web-app&gt;</code>标签中，通过<code>&lt;context-param&gt;</code>标签来配置，其存在两个子标签</p><ul><li><p><code>&lt;param-name&gt;</code>表示全局初始化参数的key</p></li><li><p><code>&lt;param-value&gt;</code>表示全局初始化参数的value</p></li><li><p>实例</p><pre><code class="xml">&lt;context-param&gt;    &lt;param-name&gt;globalEncoding&lt;/param-name&gt;    &lt;param-value&gt;UTF-8&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt;    &lt;param-name&gt;globaleDesc&lt;/param-name&gt;    &lt;param-value&gt;This is SevletContext&lt;/param-value&gt;&lt;/context-param&gt;</code></pre></li></ul></li></ul><h4 id="3⃣️ServletContext的三个作用"><a href="#3⃣️ServletContext的三个作用" class="headerlink" title="3⃣️ServletContext的三个作用"></a>3⃣️ServletContext的三个作用</h4><ul><li><p>获取Web应用程序的初始化参数</p><ol><li><code>Enumeration getInitParameterName()</code>方法用于返回包含所有参数名的Enumeration对象</li><li><code>String getInitParameter(String name)</code>方法用于根据参数名获取参数值</li></ol></li><li><p>实现多个Servlet之间的数据共享</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Enumeration getAttributeNames()</td><td>返回包含所有域属性名的Enumeration对象</td></tr><tr><td>Object getAttribute(String name)</td><td>根据域属性名返回域属性值</td></tr><tr><td>Void removeAttribute(String name)</td><td>根据域属性名从ServletContext中删除对应的域属性</td></tr><tr><td>void SetAttribute(String name,Object obj)</td><td>设置ServletContext的域属性，其中name是域属性名，obj是域属性值</td></tr></tbody></table><blockquote><p>⚠️域属性 &#x3D;&gt; 可以共享的数据，即可以被多个Servlet访问到</p></blockquote></li><li><p>读取Web应用下的资源文件</p><ol><li><p>实际开发中有时会需要读取Web应用中的一个资源文件，为此ServletContext接口定义了一些读取Web资源的方法，这些方法依靠Serlvet容器实现，可以根据资源文件相对Web应用的路径，返回关联资源文件的IO流、资源文件的绝对路径等</p></li><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Set getResourcePaths(String path)</td><td>返回一个包含path指定路径下的<strong>子目录名称</strong>和<strong>文件名称</strong>但是不包含子目录下文件名称的Set集合，path以斜杠**&#x2F;**开头表示Web应用等根目录</td></tr><tr><td>String getRealPath(String path)</td><td>返回资源文件在服务器文件系统上的真实路径，参数path表示资源文件相对于Web应用的路径，以斜杠**&#x2F;**开头表示Web应用的根目录，如果不能将虚拟路径转为真实路径则返回null</td></tr><tr><td>URL getResource(String path)</td><td>返回映射到某个资源文件的URL对象，参数path必须以斜杠**&#x2F;**开头表示Web应用的根目录</td></tr><tr><td>InputStream getResourceAsStream(String path)</td><td>返回映射到某个资源文件的InputStream输出流对象，参数path的传递规则和getResource()一致</td></tr></tbody></table><p>总结：这四个方法中的path &#x3D;&gt; 相对于Web应用的路径，以**&#x2F;**开头</p></li></ol></li></ul><h3 id="四、HttpServletRequest"><a href="#四、HttpServletRequest" class="headerlink" title="四、HttpServletRequest"></a>四、HttpServletRequest</h3><h4 id="1⃣️概述-2"><a href="#1⃣️概述-2" class="headerlink" title="1⃣️概述"></a>1⃣️概述</h4><ul><li>HTTPServletRequest接口继承自ServletRequest接口</li><li>HTTPServletRequest专门用于封装HTTP请求消息</li><li>HTTPServletRequest提供了一些用于访问请求消息的方法，如获取请求行、获取请求头等</li></ul><h4 id="2⃣️相关方法"><a href="#2⃣️相关方法" class="headerlink" title="2⃣️相关方法"></a>2⃣️相关方法</h4><ul><li><p>获取请求行信息</p><ol><li><p><code>String getMethod()</code> &#x3D;&gt; 获取HTTP请求消息中的请求方式（比如<strong>Get</strong>或者<strong>Post</strong>）</p></li><li><p><code>String getRequestURL()</code> &#x3D;&gt; 获取请求行中<strong>资源名称</strong>部分，即URL中主机端口好之后和参数部分之前的部分</p></li><li><p><code>String getQueryString()</code> &#x3D;&gt; 获取请求行中的参数部分，即资源路径<strong>？</strong>之后的内容</p></li><li><p><code>String getContextPath()</code> &#x3D;&gt; 获取URL中Web应用程序的路径，以**&#x2F;**开头，结尾没有斜杠</p></li><li><p><code>String getProtocol()</code> &#x3D;&gt;  获取请求行中的协议名和版本，比如<strong>HTTP&#x2F;1.0</strong>、<strong>HTTP&#x2F;1.1</strong></p></li><li><p><code>String getServletPath()</code> &#x3D;&gt; 获取Servlet映射的路径或者Servlet名称</p></li><li><p><code>String getRemoteAddr()</code> &#x3D;&gt; 获取发送请求的客户端IP地址</p></li><li><p><code>String getRemoteHost()</code> &#x3D;&gt; 获取发送请求的客户端的完整主机名，如果解析不到则返回IP地址</p></li><li><p><code>int getRemoteHost()</code> &#x3D;&gt; 获取发送请求的客户端的端口号</p></li><li><p><code>String getLocalAddr()</code> &#x3D;&gt; 获取Web服务器上接收当前请求的网络的IP地址对应的主机名</p></li><li><p><code>String getLocalName()</code> &#x3D;&gt; 获取Web服务器上接收当前请求的网络IP地址对应的主机名</p></li><li><p><code>int getLocalPort()</code> &#x3D;&gt; 获取Web服务器上接收当前网络连接的端口号</p></li><li><p><code>String getServerName()</code> &#x3D;&gt; 获取当前请求所指向的主机名，即HTTP氢请求消息中Host字段所对应的主机名部分</p></li><li><p><code>String getServerPort()</code> &#x3D;&gt; 获取当前请求所连接的服务器端口号，即HTTP请求消息中Host字段所对应的端口号部分</p></li><li><p><code>String getSchema()</code> &#x3D;&gt; 获取请求的协议名，如HTTP、HTTPS</p></li><li><p><code>StringBuffer getRequestURL()</code> &#x3D;&gt; 获取客户端发出请求时的完成URL，包括协议、服务器名、端口号、资源路径等，但不包括后面的参数部分，StringBuffer类型方便修改</p></li></ol><p>实例：</p><pre><code class="java">@WebServlet(&quot;/HttpServletRequestDemo&quot;)public class HttpServletRequestDemo extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String method = req.getMethod();        System.out.println(method);        String requestURI = req.getRequestURI();        System.out.println(requestURI);        String queryString = req.getQueryString();        System.out.println(queryString);        String protocol = req.getProtocol();        System.out.println(protocol);        String contextPath = req.getContextPath();        System.out.println(contextPath);        String servletPath = req.getServletPath();        System.out.println(servletPath);        String remoteAddr = req.getRemoteAddr();        System.out.println(remoteAddr);        String remoteHost = req.getRemoteHost();        System.out.println(remoteHost);        int remotePort = req.getRemotePort();        System.out.println(remotePort);        String localAddr = req.getLocalAddr();        System.out.println(localAddr);        String localName = req.getLocalName();        System.out.println(localName);        int localPort = req.getLocalPort();        System.out.println(localPort);        String serverName = req.getServerName();        System.out.println(serverName);        int serverPort = req.getServerPort();        System.out.println(serverPort);        String scheme = req.getScheme();        System.out.println(scheme);        StringBuffer requestURL = req.getRequestURL();        System.out.println(requestURL);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;</code></pre><p>输出结果：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5809/HttpServletRequestDemo.png"></p></li><li><p>获取请求头信息的相关方法</p><ol><li><code>String getHeader(String name)</code> &#x3D;&gt; 获取请求头中指定名称字段的值，如果没有该字段则返回null，如果有多个该指定名称的字段，则返回第一个字段的值</li><li><code>Enumeration getHeaders(String name)</code> &#x3D;&gt; 返回一个包含所有请求头中指定名称字段的值的Enumeration对象</li><li><code>Enumeration getHeaderName()</code> &#x3D;&gt; 返回一个包含所有请求头字段的Enumeration对象</li><li><code>int getIntHeader(String name)</code> &#x3D;&gt; 获取一个指定请求头字段的值，并将该字段的值转为int类型再返回，如果该字段不存在则返回-1，如果该字段的值不能转为int类型则抛出NumberFormatException异常</li><li><code>long getDateHeaders(String name)</code> &#x3D;&gt; 获取一个指定请求头字段的值，并将其转为一个代表日期&#x2F;实践的长整数，这个长整数是1970.1.1 0:0:0算起到现在的毫秒值（时间戳）</li><li><code>String getContentType()</code> &#x3D;&gt; 获取Content-Type字段的值</li><li><code>int getContentLength()</code> &#x3D;&gt; 获取Content- Length字段的值</li><li><code>String getCharacterEncoding()</code> &#x3D;&gt; 获取请求消息的实体部分的字符集编码，通常从Content-Type字段中截取</li></ol><p>实例：</p><pre><code class="java">@WebServlet(&quot;/HttpServletRequestDemo&quot;)public class HttpServletRequestDemo extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        Enumeration&lt;String&gt; headerNames = req.getHeaderNames();        while(headerNames.hasMoreElements())&#123;            String s = headerNames.nextElement();            System.out.println(s+&quot;:&quot;+req.getHeader(s));        &#125;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;</code></pre><p>输出结果：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5809/HttpServletRequestDemo01.png"></p></li><li><p>获取请求参数相关方法</p><ol><li><code>String getParameter(String name)</code> &#x3D;&gt; 获取指定名称参数的参数值，如果不存在参数则返回null，如果该参数没有设置返回值则返回空串，如果该参数有多个值则返回第一个值</li><li><code>String getParamterValues()</code> &#x3D;&gt; 获取同一个参数名称的所有值</li><li><code>Enumeration getParameterNames()</code> &#x3D;&gt; 返回包含所有参数名的Enumeration对象</li><li><code>Map getParameterMap()</code> &#x3D;&gt; 将参数名和参数值装入一个Map对象中返回</li></ol><p>实例：</p><pre><code class="java">@WebServlet(&quot;/HttpServletRequestDemo&quot;)public class HttpServletRequestDemo extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        Enumeration&lt;String&gt; parameterNames = req.getParameterNames();        while (parameterNames.hasMoreElements()) &#123;            String s = parameterNames.nextElement();            String[] parameterValues = req.getParameterValues(s);            System.out.println(s+&quot;:&quot;+Arrays.toString(parameterValues));        &#125;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;</code></pre><p>输出结果：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5809/HttpServletRequestDemo02.png"></p></li></ul><h4 id="3⃣️HttpServletRequest共享数据"><a href="#3⃣️HttpServletRequest共享数据" class="headerlink" title="3⃣️HttpServletRequest共享数据"></a>3⃣️HttpServletRequest共享数据</h4><ul><li>HttpServletRequest可以通过属性共享、传递一些数据（比如运用在<strong>请求转发</strong>和<strong>请求包含</strong>中）</li><li>相关方法<ol><li><code>void setAttribute(String name,Object obj)</code> &#x3D;&gt; 用于定义一个属性，属性名: name，属性值:obj；如果原先已经存在相同名称的属性，则会将原来的属性删除在添加该属性，如果obj为null则会删除指定名称的属性</li><li><code>Object getAttribute(String name)</code> &#x3D;&gt; 根据属性名获取属性值</li><li><code>void removeAttribute(String name)</code> &#x3D;&gt; 删除指定属性名的属性</li><li><code>Enumeration getAttributeNames()</code> &#x3D;&gt; 返回一个包含所有属性名的Enumeration对象</li></ol></li></ul><blockquote><p>⚠️ <strong>同一个请求</strong>中的数据才能共享、传递</p></blockquote><h4 id="4⃣️请求转发和请求包含"><a href="#4⃣️请求转发和请求包含" class="headerlink" title="4⃣️请求转发和请求包含"></a>4⃣️请求转发和请求包含</h4><ul><li>请求转发<ul><li>Servlet之间可以相互跳转<br>如果某个Servlet的功能<strong>不能处理</strong>客户端的请求，可以使用跳转的方式将请求传递给另一个Servlet，由另一个Servlet完成并响应给客户端</li><li>相关方法<ol><li><code>RequestDispatcher getRequestDispatcher(String path)</code> &#x3D;&gt; 该方法有HttpServletRequest提供，用于获取一个封装了某条路径所指定资源的RequestDispatcher对象，路径必须以**&#x2F;**开头，即该路径就是需要转发到某个Servlet的路径</li><li><code>void forward(ServletRequest req,ServletResponse response)</code> &#x3D;&gt; 该方法有RequestDispatcher提供，用于将请求转发给另一个Web资源，如某个Servlet</li></ol></li></ul></li><li>请求包含<ul><li>某个Servlet<strong>不能完全处理</strong>一个请求时可以将另一个Servlet“包含”进来，实现功能之后合并然后响应给客户端，这是浏览器的地址栏不会发生改变，被包含的Servlet的响应头会丢失，因为是由第一个Servlet做出响应的</li><li>相关方法<ol><li><code>RequestDispatcher getRequestDispatcher(String path)</code> &#x3D;&gt; 跟请求转发的相同，路径是需要包含的哪个Servlet的路径</li><li><code>void include(ServletRequest req, ServletResponse resp)</code> &#x3D;&gt; 该方法有RequestDispatcher提供，用于实现包含另一个Servlet的功能</li></ol></li></ul></li></ul><h4 id="5⃣️流对象获取数据"><a href="#5⃣️流对象获取数据" class="headerlink" title="5⃣️流对象获取数据"></a>5⃣️流对象获取数据</h4><ul><li><code>BufferReader getReader()</code> &#x3D;&gt; 获取一个字符输入缓冲流</li><li><code>ServletInputStream getInpitStream()</code> &#x3D;&gt; 获取一个字节数入流</li></ul><blockquote><p>⚠️这两个方法读取的数据来自<strong>请求体</strong> &#x3D;&gt; 使用GET方式获取不到数据，使用POST方式可以</p></blockquote><h4 id="6⃣️中文乱码问题"><a href="#6⃣️中文乱码问题" class="headerlink" title="6⃣️中文乱码问题"></a>6⃣️中文乱码问题</h4><ul><li>在网页的表单中如果需要提交的数据存在中文时可能会出现乱码的情况</li><li>HttpServletRequest提供了<code>void serCharacterEncoding(String name)</code>方法用于设置Request对象的解码方式</li><li>GET方式提交的请求不会出现乱码的问题，但是POST方式存在乱码问题</li></ul><h3 id="五、HttpServletResponse"><a href="#五、HttpServletResponse" class="headerlink" title="五、HttpServletResponse"></a>五、HttpServletResponse</h3><h4 id="1⃣️概述-3"><a href="#1⃣️概述-3" class="headerlink" title="1⃣️概述"></a>1⃣️概述</h4><ul><li>HttpServletResponse接口继承自ServletResponse接口</li><li>用于封装HTTP响应消息</li><li>HTTP响应消息分为响应行、响应头、响应体三部分，所以HttpServletResponse中定义了想客户端发送响应状态吗、响应消息头、响应消息体等方法</li></ul><h4 id="2⃣️常见状态码"><a href="#2⃣️常见状态码" class="headerlink" title="2⃣️常见状态码"></a>2⃣️常见状态码</h4><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>成功</td></tr><tr><td>302</td><td>重定向</td></tr><tr><td>304</td><td>请求资源未改变，使用缓存</td></tr><tr><td>400</td><td>请求错误，常见于请求参数错误</td></tr><tr><td>404</td><td>请求资源未找到</td></tr><tr><td>405</td><td>请求方式不支持</td></tr><tr><td>500</td><td>服务器错误</td></tr></tbody></table><h4 id="3⃣️发送状态码的方法"><a href="#3⃣️发送状态码的方法" class="headerlink" title="3⃣️发送状态码的方法"></a>3⃣️发送状态码的方法</h4><ol><li><code>void setStatus(int status)</code> &#x3D;&gt; 设置响应消息状态码，并生成响应状态行</li><li><code>void sendError(int sc)</code> &#x3D;&gt; 发送表示错误信息的状态码</li><li><code>void sendError(int sc,String message)</code> &#x3D;&gt; 设置表示错误的状态码外还向客户端发送一条错误信息，其中包含message的内容</li></ol><h4 id="4⃣️发送响应消息头的方法"><a href="#4⃣️发送响应消息头的方法" class="headerlink" title="4⃣️发送响应消息头的方法"></a>4⃣️发送响应消息头的方法</h4><ol><li><code>void addHeader(String name,String value)</code> &#x3D;&gt; 设置响应头指定名称字段的值，会覆盖掉原来该名称字段的值</li><li><code>void setHeader(String name,String value)</code> &#x3D;&gt; 与<code>addHeader(name,value)</code>方法功能相同，但是不会覆盖掉原来的值，而是添加一个值</li><li><code>void setContentLength(int Len)</code> &#x3D;&gt; 设置响应头的实体内容的大小，单位是字节</li><li><code>void setContentType(String type)</code> &#x3D;&gt; 设置响应内容的类型，即<code>Content-Type</code>的值，并且响应内容为文本类型时还能指定字符集编码，比如<strong>text&#x2F;html;charset&#x3D;UTF-8</strong></li></ol><h4 id="5⃣️发送响应消息体的方法"><a href="#5⃣️发送响应消息体的方法" class="headerlink" title="5⃣️发送响应消息体的方法"></a>5⃣️发送响应消息体的方法</h4><ol><li><code>ServletOutputStream getOutputStream()</code> &#x3D;&gt; 获取字节输出流对象</li><li><code>PrintWriter getWriter()</code> &#x3D;&gt; 获取输出流对象</li></ol><blockquote><p>⚠️在使用这些输出流时可能会出现乱码的情况，所以在使用输出流时可以使用<code>resp.setContentType(&quot;text/html;UTF-8&quot;)</code>来设置字符集编码，用来解决乱码问题</p></blockquote><h4 id="6⃣️请求重定向"><a href="#6⃣️请求重定向" class="headerlink" title="6⃣️请求重定向"></a>6⃣️请求重定向</h4><ul><li>请求重定向是指服务器接收到客户端请求后，可能由于某些条件限制，不能访问请求指定的资源，让客户端去访问另一个指定的资源</li><li><code>HttpServletResponse</code>定义了一个<code>sendRedirect()</code>方法，用于生成304状态码和<code>Location</code>响应头，从而通知客户端重新访问<code>Location</code>响应头中指定的URL</li><li>方法：<code>void sendRedirect(String location)</code></li><li><code>location</code>可以使用相对路径重定向到同一个Web服务器的其他Servlet，也可以使用绝对路径重定向到其他Web服务器</li></ul><blockquote><p>⚠️重定向时会重新生成另一个HttpServletRequest对象，所以不能使用Servlet的共享数据，如果需要共享数据那么可以使用请求转发</p></blockquote><h4 id="7⃣️设置缓存时间"><a href="#7⃣️设置缓存时间" class="headerlink" title="7⃣️设置缓存时间"></a>7⃣️设置缓存时间</h4><ul><li>对于不经常变化的数据，可以设置缓存时间减少频繁访问服务器，提高效率</li><li>使用<code>void setDateHeader(String name,long time)</code>方法来设置响应头</li><li>范例 &#x3D;&gt; <code>resp.setDateHeader(&quot;Expires&quot;,System.currentTimeMills+1*60*60*1000);</code>，设置缓存时间为1个小时</li></ul><h4 id="8⃣️设置定时刷新"><a href="#8⃣️设置定时刷新" class="headerlink" title="8⃣️设置定时刷新"></a>8⃣️设置定时刷新</h4><ul><li>定时刷新：设置经过某个时间后自动跳转到某个页面</li><li>使用<code>void setHeader(String name,String value)</code>方法</li><li>范例 &#x3D;&gt; <code>resp.setHeader(&quot;Refresh&quot;,&quot;3;URL=/虚拟目录/demo.html&quot;);</code></li></ul><h4 id="9⃣️文件下载"><a href="#9⃣️文件下载" class="headerlink" title="9⃣️文件下载"></a>9⃣️文件下载</h4><ul><li><p>实现浏览器中下载文件的功能</p><ol><li>创建字节数入流，关联读取的文件</li><li>设置响应消息头支持的类型</li><li>设置响应消息头以下载方式打开资源</li><li>通过响应对象获得字节输出流对象</li><li>循环读写</li><li>释放资源</li></ol></li><li><p>示例</p><pre><code class="java">@WebServlet(&quot;/ServletDownloadDemo&quot;)public class ServletDownloadDemo extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //1. 创建字节输入流，关联读取的文件        String realPath = getServletContext().getRealPath(&quot;/img/ServletLive.png&quot;);        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(realPath));        //2. 设置响应消息头支持的类型        //Content-Type是消息头名称，表示支持的类型        //application/octet-stream是消息头参数，表示字节流        resp.setHeader(&quot;Content-Type&quot;,&quot;application/octet-stream&quot;);        //3. 设置响应消息头以下载方式打开资源        //Content-Disposition是消息头名称，表示处理形式        //attachment;filename=ServletLive.png是消息头参数，表示附件形式处理，filename表示文件名称        resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=ServletLive.png&quot;);        //4. 通过响应对象获得字节输出流对象        ServletOutputStream outputStream = resp.getOutputStream();        //5. 循环读写        byte[] bytes = new byte[1024];        int len;        while((len = bis.read(bytes)) != -1)&#123;            outputStream.write(bytes,0,len);        &#125;        //6. 释放资源        bis.close();    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;</code></pre></li></ul><h3 id="六、会话技术"><a href="#六、会话技术" class="headerlink" title="六、会话技术"></a>六、会话技术</h3><h4 id="1⃣️概述-4"><a href="#1⃣️概述-4" class="headerlink" title="1⃣️概述"></a>1⃣️概述</h4><ul><li><strong>会话</strong>是指客户端和服务器之间的<strong>多次请求和响应</strong></li><li>为了实现一些功能，浏览器和服务器可能会产生多次的请求和响应，从浏览器访问服务器开始，到访问服务器结束，这期间产生的多次请求和响应加在一起就称为浏览器和服务器之间的一次会话</li><li>为了保存会话过程中产生的数据，我们可以通过会话技术（Cookie和Session）来实现</li></ul><h4 id="2⃣️Cookie"><a href="#2⃣️Cookie" class="headerlink" title="2⃣️Cookie"></a>2⃣️Cookie</h4><ul><li><p>Cookie是一种会话技术，可以将会话过程中的数据保存在用户的<strong>浏览器</strong>中，从而使浏览器和服务器之间更好的进行数据交互</p></li><li><p>Cookie是一个类，有一些属性和方法，用于设置Cookie</p></li><li><p>发送一个Cookie是使用HttpServletResponse的<code>void addCookie(Cookie cookie)</code>方法，通过这个方法可以将Cookie添加到<strong>响应头</strong>中然后响应给浏览器</p></li><li><p>浏览器最多接收20个来自同一网站到Cookie，并且浏览器只能存放300个Cookie，每个Cookie的大小限制在4K以内</p></li><li><p>浏览器通过将Cookie添加到<strong>请求头</strong>中发送到服务器端，可以通过HttpServletRequest的<code>Cookie[] getCookie()</code>方法获取到一个Cookie数组（这些Cookie可能有相同的名称但是路径不同）</p></li><li><p>构造方法<code>public Cookie(String name,String value)</code>，name属性一旦创建不能更改，但是value可以更改</p></li><li><p>Cookie常用属性</p><table><thead><tr><th>属性</th><th>作用</th><th>重要程度</th></tr></thead><tbody><tr><td>name</td><td>Cookie名称</td><td>必须属性</td></tr><tr><td>value</td><td>Cookie值（不支持中文）</td><td>必须属性</td></tr><tr><td>path</td><td>Cookie路径</td><td>重要</td></tr><tr><td>domain</td><td>Cookie域</td><td>重要</td></tr><tr><td>maxAge</td><td>Cookie存活时间</td><td>重要</td></tr><tr><td>version</td><td>Cookie版本号</td><td>不重要</td></tr><tr><td>comment</td><td>Cookie描述</td><td>不重要</td></tr></tbody></table></li><li><p>Cookie常用方法</p><ul><li><p>Cookie常用方法是对Cookie相关属性的get或者set，但是需要注意name属性没有set方法</p></li><li><p><code>setMaxAge(int expirt)</code>和<code>getMaxAge()</code>方法解析</p><p>这两个方法用于设置和返回Cookie在浏览器上保持的有效秒数，其中设置的值有如下规则</p><ol><li>正整数表示在没有超过指定秒数之前这个Cookie会一直存在</li><li>负整数表示当浏览器关闭时Cookie信息会被清除</li><li>0表示浏览器会立即删除这个Cookie信息</li><li>默认值是-1</li></ol></li><li><p><code>setPath(String url)</code>和<code>getPath()</code>方法解析<br>这两个方法针对path属性的设置和获取</p><ol><li>如果创建的Cookie对象没有设置path属性的值，那么默认该Cookie只对<strong>当前请求路径所属的目录以及子目录</strong>有效</li><li>如果想让某个Cookie对象对站点的所有目录下的访问路径都有效，可以设置为**&#x2F;**</li><li>设置path的格式：<strong>contextPath + 自定义路径</strong></li></ol></li><li><p><code>setDomain(String pattern)</code>和<code>getDomain()</code></p><p>这两个方法是针对domain属性的设置和获取，domain属性用于指定Cookie所在的域</p><ol><li>默认为服务器主机地址，当浏览器想要访问该服务器的资源是会将该Cookie信息发送给服务器</li><li>如果想让不同的域之间都可以访问到某个Cookie，那么Cookie的domain应该是这些域的相同后缀，而且必须以 <strong>.</strong> 开头</li></ol></li></ul></li></ul><h4 id="3⃣️Session"><a href="#3⃣️Session" class="headerlink" title="3⃣️Session"></a>3⃣️Session</h4><ul><li><p>Session也是会话技术的一种，与Cookie不同的是，在客户端保存的是一个表示，而会话产生的数据保存在服务器端</p></li><li><p>当浏览器第一次请求服务器时，服务器会创建一个Session对象，该对象有唯一的一个标识，然后服务器将这个表示以Cookie的方式发送给浏览器</p></li><li><p>当浏览器再一次请求服务器时会将这个标识发送过来，服务器根据这个标识就可以找到对应的Session对象</p></li><li><p>Session也是域对象之一，可以实现数据共享</p></li><li><p>通过创建一个HttpSession对象来实现Session，HttpSession是一个接口，由服务器负责创建，使用时获取即可</p></li><li><p>获取方式：通过<code>HttpSerlvetRequest</code>对象获取</p><ol><li><code>HttpSession getSession()</code> &#x3D;&gt; 获取HttpSession对象</li><li><code>HttpSession getSession(boolean create)</code> &#x3D;&gt; 获取HttpSession对象，未获取到是否创建</li></ol></li><li><p>HttpSession常用方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getID()</td><td>返回与当前HttpSession对象关联的会话标识号</td></tr><tr><td>long getCreationTime()</td><td>返回Session创建时间</td></tr><tr><td>long getLastAccessedTime()</td><td>返回客户端最后一次发送与Session相关请求的时间</td></tr><tr><td>void setMaxInactiveInterval(int interval)</td><td>设置当前Session对象可空闲的最长时间，单位为秒</td></tr><tr><td>boolean isNew()</td><td>判断当前HttpSession对象是否是新建的</td></tr><tr><td>void invalidate()</td><td>强制使Session对象无效</td></tr><tr><td>ServletContext getServletContext()</td><td>返回当前HttpSession对象所属的ServletContext对象</td></tr><tr><td>void setAttribute(String name,Object value)</td><td>存储一个指定名称的数据对象，可以用于共享</td></tr><tr><td>String getAttribute(String name)</td><td>从当前HttpSession对象中返回指定名称的属性值</td></tr><tr><td>void removeAttribute(String name)</td><td>从当前HttpSession对象中删除指定名称的属性值</td></tr></tbody></table></li><li><p>Session生命周期</p><ul><li>Session生效<ol><li>Session在用户第一次访问服务器时创建</li><li>只有访问JSP、Servlet等程序时才会创建Session</li><li>只访问HTML、IMAGE等静态资源时不会创建Session</li></ol></li><li>Session失效<ol><li>Web服务器使用<strong>超时限制</strong>判断客户端是否还在继续访问。在一定时间内，如果某个客户端没有请求访问，那么Web服务器认为该客户端已经结束请求，并且与该客户端会话所创建的HttpSession对象会变成垃圾对象，等待垃圾收集器将其从内存中清除。如果超时后再次向服务器发出请求访问，那么Web服务器会创建一个新的HttpSession对象，并且分配一个新的标识</li><li>使用<code>invalidate()</code>方法，可以强制使得Session失效</li><li>设置失效时间：使用<code>setInactiveInterval(int interval)</code>方法可以设置Session最长空闲时间，当超过这个时间客户端没有请求访问则Session失效</li></ol></li></ul></li></ul><h3 id="七、Filter"><a href="#七、Filter" class="headerlink" title="七、Filter"></a>七、Filter</h3><h4 id="1⃣️概述-5"><a href="#1⃣️概述-5" class="headerlink" title="1⃣️概述"></a>1⃣️概述</h4><ul><li><p>Filter，过滤器，位于客户端与处理程序之间，能够对请求和响应进行检查和修改</p></li><li><p>当客户端对服务器资源发送请求时，服务器根据过滤规则进行检查，如果满足过滤规则，则对客户请求进行拦截，然后对请求头或请求数据进行修改或检查，并一次通过Filter链，最后将请求交给处理程序</p></li><li><p>请求信息可以在过滤器中被修改，也可以根据请求条件不让请求发送处理程序</p></li><li><p>拦截过程</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5809/Filter.png" alt="Filter"></p></li></ul><h4 id="2⃣️Filter接口"><a href="#2⃣️Filter接口" class="headerlink" title="2⃣️Filter接口"></a>2⃣️Filter接口</h4><ul><li><p>编写一个Filter类必须实现Filter接口</p></li><li><p>相关方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>default void init(FilterConfig filterConfig)</td><td>创建Filter后用于初始化Filter，通过参数FilterConfig对象获取配置参数</td></tr><tr><td>void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)</td><td>用于完成过滤的操作，其中Request对象时有上一个过滤器或者Web服务器传递过来的请求和响应对象，FilterChain对象代表当前过滤链对象</td></tr><tr><td>default void destroy()</td><td>用于释放过滤器中占用的资源，在对象被销毁之前调用</td></tr></tbody></table><blockquote><p>⚠️Filter接口提供了三个方法，其中<code>init()</code>方法和<code>destroy()</code>方法是默认方法，不强制重写，而<code>doFilter()</code>方法是抽象方法，在实现Filter接口时必须重写</p></blockquote></li></ul><h4 id="3⃣️Filter配置"><a href="#3⃣️Filter配置" class="headerlink" title="3⃣️Filter配置"></a>3⃣️Filter配置</h4><ul><li><p>配置Filter有两种方式</p><ul><li>通过<code>web.xml</code>文件进行配置</li><li>通过<code>@WebFilter</code>注解进行配置</li></ul></li><li><p><code>web.xml</code>配置方式</p><pre><code class="xml">&lt;!--在web.xml文件的web-app标签下写入以下内容--&gt;&lt;filter&gt;    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;    &lt;filter-class&gt;com.juzi.filter.FilterDemo&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;    &lt;url-pattern&gt;/ServletDemo&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre></li><li><p><code>@WebFilter</code>注解配置方式</p><pre><code class="java">@WebFilter(&quot;/ServletDemo&quot;)public class FilterDemo implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;FilterDemo doFilter()执行中......&quot;);    &#125;&#125;</code></pre><p><code>@WebFilter</code>常用属性</p><table><thead><tr><th>属性名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>filterName</td><td>String</td><td>指定过滤器名称</td></tr><tr><td>urlPattern</td><td>String[]</td><td>指定需要过滤的资源，比如某个Servlet</td></tr><tr><td>value</td><td>String[]</td><td>等价于urlPattern，不能同时使用</td></tr><tr><td>servletNames</td><td>String[]</td><td>指定过滤器将应用于哪些Servlet，取值是@WebFilter注解中name属性的取值</td></tr><tr><td>dispatcherTypes</td><td>DispatcherType</td><td>指定过滤器转发模式，取值有ERROR、FORWARD、INCLUDE、REQUEST</td></tr><tr><td>initParams</td><td>WebInitParam[]</td><td>指定过滤器的一组初始化参数</td></tr></tbody></table><blockquote><p>⚠️DispatcherType是枚举类，取值的作用：</p><ol><li>DispatcherType.ERROR表示过滤器拦截那些跳转到某个<strong>异常</strong>处理页面的请求</li><li>DispatcherType.FORWARD表示过滤器拦截那些通过<code>forward()</code>方法来请求的<strong>转发</strong>的请求</li><li>DispatcherType.INCLUDE表示过滤器拦截那些通过<code>include()</code>方法来请求<strong>包含</strong>的请求</li><li>DispatcherType.REQUEST表示过滤器只会拦截<strong>普通</strong>的请求，而请求转发和请求包含类的请求不会拦截</li></ol></blockquote></li><li><p>如果需要拦截用户的所有请求，可以使用*****通配符</p><pre><code class="xml">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code></pre><pre><code class="java">@WebFilter(&quot;/*&quot;)</code></pre></li></ul><h4 id="4⃣️FilterConfig接口"><a href="#4⃣️FilterConfig接口" class="headerlink" title="4⃣️FilterConfig接口"></a>4⃣️FilterConfig接口</h4><ul><li><p>FilterConfig接口用于封装Filter的配置信息，在Filter初始化时，服务器将FilterConfig对象作为参数传递给Filter对象的<code>init()</code>方法</p></li><li><p>FilterConfig相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String getFilterName()</td><td>获取Filter的名称</td></tr><tr><td>ServletContext getServletContext()</td><td>获取ServletContext对象</td></tr><tr><td>String getInitParameter(String name)</td><td>根据名称获取初始化参数值</td></tr><tr><td>Enumeration getInitParameterNames()</td><td>返回一个包含所有初始化参数的Enumeration对象</td></tr></tbody></table></li><li><p>配置初始化参数的方式</p><ul><li><p>在<code>web.xml</code>中配置，注意是在<code>&lt;filter&gt;</code>标签下方进行配置</p><pre><code class="xml">&lt;filter&gt;    &lt;init-param&gt;     &lt;param-name&gt;username&lt;/param-name&gt;     &lt;param-value&gt;juzi&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;</code></pre></li><li><p>在@WebFilter中使用<code>initParams</code>属性配置</p><pre><code class="java">@WebFilter(initParams = &#123;@WebInitParam(name=&quot;username&quot;,value=&quot;liaoxiangqian&quot;)&#125;)</code></pre><blockquote><p>⚠️<code>initParams</code>属性类型是注解型数组</p></blockquote></li><li><p>添加初始化参数后可以通过FilterConfig对象来获取这些参数</p></li></ul></li></ul><h4 id="5⃣️FilterChain接口"><a href="#5⃣️FilterChain接口" class="headerlink" title="5⃣️FilterChain接口"></a>5⃣️FilterChain接口</h4><ul><li><p>FilterChain对象表示当前过滤器所在的过滤链</p></li><li><p>一个Web应用程序中存在多个Filter，每个Filter都可以对某个请求进行拦截，如果多个Filter都对同一个请求进行拦截，那么这些Filter就组成一个Filter链，使用FilterChain对象表示</p></li><li><p>一个方法</p><p><code>void doFilter(ServletRequest req, ServletResponse resp)</code></p><p>FilterChain提供的<code>doFilter()</code>方法，作用是让Filter链上的当前过滤器放行，使请求进入下一个Filter</p></li></ul><h4 id="6⃣️Filter生命周期"><a href="#6⃣️Filter生命周期" class="headerlink" title="6⃣️Filter生命周期"></a>6⃣️Filter生命周期</h4><ul><li>Filter生命周期：创建 &#x3D;&gt; 执行 &#x3D;&gt; 销毁</li><li>创建阶段：Web服务器启动时会创建Filter对象，并调用<code>init()</code>方法，完成对象的初始化，在一次完成请求中Filter对象只会被创建一次，<code>init()</code>方法只会被调用一次</li><li>执行阶段：客户端发出请求时，服务器筛选出符合拦截条件的过滤器，按照类名的顺序一次执行<code>doFilter()</code>方法，<code>doFilter()</code>在一次完整请求中会执行多次</li><li>销毁阶段：服务器关闭时，Web服务器调用<code>destroy()</code>方法销毁对象</li></ul><h3 id="八、Listener"><a href="#八、Listener" class="headerlink" title="八、Listener"></a>八、Listener</h3><h4 id="1⃣️概述-6"><a href="#1⃣️概述-6" class="headerlink" title="1⃣️概述"></a>1⃣️概述</h4><ul><li>Web程序开发中，可以对对象的创建和销毁、域对象中属性的变化，会话相关内容进行监听</li><li>Servlet中提供八个监视器，都是以接口的形式提供，具体功能需要实现</li><li>相关概念<ol><li>事件：触发的动作</li><li>事件源：产生事件的对象</li><li>事件监听器：监听发生在事件源上的事件</li><li>事件处理器：监听器的成员方法，事件发生时会触发该方法</li></ol></li></ul><h4 id="2⃣️监听对象的创建和销毁监听器"><a href="#2⃣️监听对象的创建和销毁监听器" class="headerlink" title="2⃣️监听对象的创建和销毁监听器"></a>2⃣️监听对象的创建和销毁监听器</h4><ul><li><p>ServletContextListener接口</p><ol><li><p>用于监听ServletContext对象的创建与销毁</p></li><li><p>核心方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void contextInitialized(ServletContextEvent sce)</td><td>ServletContext对象创建时执行</td></tr><tr><td>void contextDestroyed(ServletContextEvent sce)</td><td>ServletContext对象销毁时执行</td></tr></tbody></table></li></ol></li><li><p>HttpSessionListener接口</p><ol><li><p>用于监听HttpSession对象的创建与销毁</p></li><li><p>核心方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void sessionCreated(HttpSessionEvent se)</td><td>HttpSession对象创建时执行</td></tr><tr><td>void sessionDestroy(HttpSessionEvent se)</td><td>HttpSession对象销毁时执行</td></tr></tbody></table></li></ol></li><li><p>ServletRequestListener接口</p><ol><li><p>用于监听ServletRequest对象的创建与销毁</p></li><li><p>核心方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void requestInitialized(ServletRequestEvent sre)</td><td>ServletRequest对象创建时执行</td></tr><tr><td>void requestDestroyed(ServletRequestEvent sre)</td><td>ServletRequest对象销毁时执行</td></tr></tbody></table></li></ol></li></ul><h4 id="监听域对象属性变化的监听器"><a href="#监听域对象属性变化的监听器" class="headerlink" title=".监听域对象属性变化的监听器"></a>.监听域对象属性变化的监听器</h4><ul><li><p>ServletContextAttributeListener接口</p><ol><li><p>用于监听ServletContext中属性的变化</p></li><li><p>核心方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void attributeAdded(ServletContextAttributeEvent scae)</td><td>域中添加属性时执行</td></tr><tr><td>void attributeRemoved(ServletContextAttributeEvent scae)</td><td>域中移除属性时执行</td></tr><tr><td>void attributeReplaced(ServletContextAttributeEvent scae)</td><td>域中替换属性时执行</td></tr></tbody></table></li></ol></li><li><p>HttpSessionAttributeListener接口</p><ol><li><p>用于监听HttpSession中属性的变化</p></li><li><p>核心方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void attributeAdded(HttpSessionBindingEvent se)</td><td>域中添加属性时执行</td></tr><tr><td>void attributeRemoved(HttpSessionBindingEvent se)</td><td>域中移除属性时执行</td></tr><tr><td>void attributeReplaced(HttpSessionBindingEvent se)</td><td>域中替换属性时执行</td></tr></tbody></table></li></ol></li><li><p>ServletRequestAttributeListener接口</p><ol><li><p>用于监听ServletRequest中属性的变化</p></li><li><p>核心方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void attributeAdded(ServletRequestAttributeEvent srae)</td><td>域中添加属性时执行</td></tr><tr><td>void attributeRemoved(ServletRequestAttributeEvent srae)</td><td>域中移除属性时执行</td></tr><tr><td>void attributeReplaced(ServletRequestAttributeEvent srae)</td><td>域中替换属性时执行</td></tr></tbody></table></li></ol></li></ul><h4 id="4⃣️监听会话相关的感知型监听器"><a href="#4⃣️监听会话相关的感知型监听器" class="headerlink" title="4⃣️监听会话相关的感知型监听器"></a>4⃣️监听会话相关的感知型监听器</h4><ul><li><p>HttpSessionBindingListener接口</p><ol><li><p>用于监听JavaBean对象绑定到HttpSession对像和从HttpSession对象解绑的事件</p></li><li><p>核心方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void valueBound(HttpSessionBindingEvent event)</td><td>数据绑定(添加)到会话域时执行</td></tr><tr><td>void valueUnbound(HttpSessionBindingEvent event)</td><td>数据从会话域解绑(移除)时执行</td></tr></tbody></table></li></ol></li><li><p>HttpSessionActivationListener接口</p><ol><li><p>用于监听HttpSession中对象活化(恢复到内存)和钝化(持久化到硬盘)的过程</p></li><li><p>核心方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void sessionWillPassivate(HttpSessionEvent se)</td><td>会话域中数据钝化时执行</td></tr><tr><td>void sessionDidActivate(HttpSessionEvent se)</td><td>会话域中数据活化时执行</td></tr></tbody></table></li></ol></li></ul><h4 id="5⃣️监听器的实现"><a href="#5⃣️监听器的实现" class="headerlink" title="5⃣️监听器的实现"></a>5⃣️监听器的实现</h4><ul><li><p>步骤</p><ol><li>将监听器绑定到事件源 &#x3D;&gt; 注册监听器</li><li>监听器监听到事件发生时，将事件对象作为参数传给相关的成员方法</li><li>成员方法可以根据事件对象获取事件源，然后进行处理</li></ol></li><li><p>注册监听器的方式有两种，一种是通过<code>web.xml</code>文件，一种是通过<code>@WebListener</code>注解的方式</p><ol><li><p>通过<code>web.xml</code>注册</p><pre><code class="xml">&lt;!--&lt;listener-class&gt;标签中写的是监听器的实现类的全限定名类名--&gt;&lt;listener&gt;        &lt;listener-class&gt;com.juzi.listener.MyListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre></li><li><p>通过<code>@WebListener</code>注解注册</p><pre><code class="java">//在监听器实现类上方使用该注解进行注册@WebListener</code></pre></li></ol></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2学习笔记</title>
      <link href="/2022/11/24/Vue2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/24/Vue2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue2-学习笔记"><a href="#Vue2-学习笔记" class="headerlink" title="Vue2 学习笔记"></a>Vue2 学习笔记</h1><hr><h2 id="1-Vue核心"><a href="#1-Vue核心" class="headerlink" title="1 Vue核心"></a>1 Vue核心</h2><h3 id="1-1-Vue简介"><a href="#1-1-Vue简介" class="headerlink" title="1.1 Vue简介"></a>1.1 Vue简介</h3><h4 id="1-1-1-官网"><a href="#1-1-1-官网" class="headerlink" title="1.1.1 官网"></a>1.1.1 官网</h4><ul><li>英文官网：<a href="https://vuejs.org/">https://vuejs.org/</a></li><li>中文官网：<a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></li></ul><h4 id="1-1-2-简介"><a href="#1-1-2-简介" class="headerlink" title="1.1.2 简介"></a>1.1.2 简介</h4><ul><li>动态构建用户界面的渐进式<code>JavaScript</code>框架</li></ul><h4 id="1-1-3-Vue特点"><a href="#1-1-3-Vue特点" class="headerlink" title="1.1.3 Vue特点"></a>1.1.3 Vue特点</h4><ol><li><p>采用<strong>组件化</strong>模式，提高代码复用率、且让代码更好维护</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%89%B9%E7%82%B9.png"></p></li><li><p><strong>声明式</strong>编码，让编码人员无需直接操作DOM，提高开发效率</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Vue%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A0%81%E7%89%B9%E7%82%B9.png"></p></li><li><p>使用<strong>虚拟DOM</strong>+优秀的<strong>Diff算法</strong>,京可能复用节点</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Vue%E8%99%9A%E6%8B%9FDom.png"></p></li></ol><span id="more"></span><h3 id="1-2-初始Vue"><a href="#1-2-初始Vue" class="headerlink" title="1.2 初始Vue"></a>1.2 初始Vue</h3><h4 id="1-2-1-小结"><a href="#1-2-1-小结" class="headerlink" title="1.2.1 小结"></a>1.2.1 小结</h4><ul><li><p>使用<code>Vue</code> </p><ul><li>创建<code>Vue</code>实例，传入配置对象</li><li>容器内代码符合<code>html</code>规范</li><li>容器内代码称之为【Vue模板】</li></ul></li><li><p>注意事项</p><ul><li>Vue实例和容器一一对应</li><li>开发中Vue和组件配合使用</li><li><code>&#123;&#123;XXX&#125;&#125;</code>中<code>XXX</code>写的是<strong>Js表达式</strong>，且<code>XXX</code>可以自动读取到<code>data</code>中的所有属性</li><li><code>data</code>中的数据发生改变，页面中使用该数据的地方会自动更新</li></ul><blockquote><p><strong>区分Js代码 &amp;&amp; Js表达式</strong></p><blockquote><ol><li>Js表达式：</li><li>一个表达式会产生一个值，可以放在任何一个需要值的地方</li><li>示例<ol><li>a </li><li>a + b</li><li>demo(a)</li><li>x &#x3D;&#x3D;&#x3D; y ?  ‘a’  :  ‘b’</li></ol></li><li>Js代码（语句）</li><li>if(){}</li><li>for(){}</li></ol></blockquote></blockquote></li></ul><h4 id="1-2-2-代码实例"><a href="#1-2-2-代码实例" class="headerlink" title="1.2.2 代码实例"></a>1.2.2 代码实例</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;初始Vue&lt;/title&gt;    &lt;!-- 引入Vue --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 容器准备 --&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;Hello: &#123;&#123;name&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;age: &#123;&#123;age&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //阻止 vue 在启动时生成生产提示        Vue.config.productionTip = false         //创建Vue实例 =&gt; 传入配置对象        new Vue(&#123;            //el =&gt; 指定当前Vue实例为哪个容器服务，值通常为css选择器字符串            el: &#39;#root&#39;,            //data =&gt; 存储数据，数据供el所指定的容器使用            data: &#123;                name:&#39;Vue&#39;,                age: 19            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-3-模板语法"><a href="#1-3-模板语法" class="headerlink" title="1.3 模板语法"></a>1.3 模板语法</h3><h4 id="1-3-1-分类"><a href="#1-3-1-分类" class="headerlink" title="1.3.1 分类"></a>1.3.1 分类</h4><ol><li><p>插值语法</p><ol><li>功能：用于解析<strong>标签体</strong>内容</li><li>写法：<code>&#123;&#123;XXX&#125;&#125;</code>,<code>XXX</code>写的是<strong>Js表达式</strong>，且<code>XXX</code>可以自动读取到<code>data</code>中的所有属性</li></ol></li><li><p>指令语法</p><ol><li><p>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件）</p></li><li><p>举例 </p><pre><code class="html">&lt;a v-bind:href=&quot;xxx&quot;&gt;&lt;/a&gt;&lt;!--等价于--&gt;&lt;a :href=&quot;xxx&quot;&gt;&lt;/a&gt;&lt;!--    xxx写js表达式，且可以读取data中的所有属性    Vue将xxx当成js表达式执行    --&gt;</code></pre></li></ol></li><li><p>代码实例</p></li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;模板语法&lt;/title&gt;    &lt;!-- 引入Vue --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 容器准备 --&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;!-- 标签体内 --&gt;      &lt;h1&gt;插值语法&lt;/h1&gt;      &lt;h3&gt;Hello,&#123;&#123;name&#125;&#125;&lt;/h3&gt;      &lt;hr /&gt;      &lt;!-- 标签属性 --&gt;      &lt;h1&gt;指令语法&lt;/h1&gt;      &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习啦1&lt;/a&gt;      &lt;a :href=&quot;school.url&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习啦2&lt;/a&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      //阻止 vue 在启动时生成生产提示      Vue.config.productionTip = false;      new Vue(&#123;        el: &quot;#root&quot;,        data: &#123;          name: &quot;Jack&quot;,          school: &#123;            name: &quot;bilibili&quot;,            url: &quot;https://www.bilibili.com&quot;,          &#125;,        &#125;,      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-4-数据绑定"><a href="#1-4-数据绑定" class="headerlink" title="1.4 数据绑定"></a>1.4 数据绑定</h3><ol><li><p>分类</p><ol><li>单向绑定（v-bind）:数据只能从data流向页面</li><li>双向绑定（v-model):数据不仅能从data流向页面，还可以从页面流向data。</li></ol></li><li><p>注意事项</p><ol><li>双向绑定一般都应用在表单类元素上（如：input、select等）</li><li>v-model:value可以简写为v-model,因为v-model默认收集的就是value值。</li></ol></li><li><p>代码实例</p></li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;数据绑定&lt;/title&gt;    &lt;!-- 引入Vue --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 容器准备 --&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;!-- 普通写法 --&gt;        单向数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt;        双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt;        &lt;!-- v-model只能应用在表单类元素上（输入类元素上） --&gt;            &lt;!-- 简写 --&gt;        单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt;        双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;            &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      //阻止 vue 在启动时生成生产提示      Vue.config.productionTip = false;      new Vue(&#123;        el: &quot;#root&quot;,        data: &#123;          name: &quot;Jack&quot;,        &#125;,      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><hr><blockquote><p>el 和 data的两种写法</p></blockquote><ol><li><p>el的两种写法</p><ol><li><code>new Vue()</code>的时候配置el属性</li><li>先创建Vue实例，随后通过<code>vm.$mount(’挂载的容器‘)</code>指定el的值</li></ol></li><li><p>data的两种写法</p><ol><li>对象式</li><li>函数式（写成<strong>普通函数</strong> &#x3D;&gt; this对象是当前的Vue实例）</li></ol></li><li><p>代码实例</p></li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;数据绑定&lt;/title&gt;    &lt;!-- 引入Vue --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 容器准备 --&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;Hello,&#123;&#123;name&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      //阻止 vue 在启动时生成生产提示      Vue.config.productionTip = false;    // el的两种写法    /* const v = new Vue(&#123;        //更换写法使用Vue自身的属性$mount()        // 写法一：el:&#39;#root&#39;,    //   el:&#39;#root&#39;,      data:&#123;        name:&#39;Jack&#39;      &#125;    &#125;)    // 写法二：$mount()    // $mount()写法更灵活    v.$mount(&quot;#root&quot;) */    //data的两种写法    new Vue(&#123;      el:&#39;#root&#39;,    //   第一种写法：对象式写法    //   data:&#123;    //     name:&#39;jack&#39;    //   &#125;        // 第二种写法：函数式写法(写成普通函数)    // data:function()&#123;    data()&#123;        return &#123;            name:&#39;Jack&#39;        &#125;    &#125;    &#125;)    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>小插曲（tip)</p><ul><li><p>VsCode自定义代码片段</p></li><li><p>步骤：左下角设置 &#x3D;&gt; 配置用户代码片段 &#x3D;&gt; 创建代码片段 &#x3D;&gt; 根据提供的注释创建代码片段</p></li><li><p>示例</p><pre><code class="json">&#123;    // Place your VueBasic 工作区 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and     // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope     // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is     // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:     // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders.     // Placeholders with the same ids are connected.    // Example:    // &quot;Print to console&quot;: &#123;    // &quot;scope&quot;: &quot;javascript,typescript&quot;,    // &quot;prefix&quot;: &quot;log&quot;,    // &quot;body&quot;: [    // &quot;console.log(&#39;$1&#39;);&quot;,    // &quot;$2&quot;    // ],    // &quot;description&quot;: &quot;Log output to console&quot;    // &#125;    &quot;Print to console&quot;: &#123;        &quot;scope&quot;: &quot;javascript,typescript&quot;,        &quot;prefix&quot;: &quot;v1&quot;,        &quot;body&quot;: [            &quot;new Vue(&#123;&quot;,            &quot;  el:&#39;#root&#39;,&quot;,            &quot;  data:&#123;&quot;,            &quot;    name:&#39;$0&#39;&quot;,            &quot;  &#125;&quot;,            &quot;&#125;)&quot;        ],        &quot;description&quot;: &quot;Log output to console&quot;    &#125;&#125;</code></pre></li></ul></blockquote><hr><h3 id="1-5-MVVM模型"><a href="#1-5-MVVM模型" class="headerlink" title="1.5 MVVM模型"></a>1.5 MVVM模型</h3><ol><li><p>MVVM模型解释</p><ol><li>M: 模型（Model）&#x3D;&gt; data中的数据</li><li>V: 视图（View) &#x3D;&gt; 模板</li><li>VM: 视图模型（ViewModel) &#x3D;&gt; Vue实例对象</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/MVVM%E6%A8%A1%E5%9E%8B.png"></p></li><li><p>注意事项</p><ol><li>data中的所有属性，最后都出现在vm上</li><li>vm上的所有属性及Vue原型上的所有属性，在Vue模板中都可以直接使用</li></ol></li></ol><h3 id="1-6-数据代理"><a href="#1-6-数据代理" class="headerlink" title="1.6 数据代理"></a>1.6 数据代理</h3><ol><li><p>理解：通过一个对象代理对拎一个对象中的属性的操作（读&#x2F;写）</p></li><li><p>原理解析图</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Vue%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.png"></p></li><li><p>Vm中的数据代理</p><ol><li>通过vm对象来代理data对象中属性的操作（读&#x2F;写）</li></ol></li><li><p>Vue中数据代理的好处</p><ol><li>更加方便的操作data中的数据</li></ol></li><li><p>基本原理</p><ol><li>通过<code>Object.definePorperty()</code>把data对象中所有属性添加到vm上</li><li>为每一个添加到vm上的属性指定一个<code>getter/setter</code></li><li>在<code>getter/setter</code>内部去操作（读&#x2F;写）data中对应的属性</li></ol></li></ol><h3 id="1-7-事件处理"><a href="#1-7-事件处理" class="headerlink" title="1.7 事件处理"></a>1.7 事件处理</h3><h4 id="1-7-1-事件的基本使用"><a href="#1-7-1-事件的基本使用" class="headerlink" title="1.7.1 事件的基本使用"></a>1.7.1 事件的基本使用</h4><ol><li><p>使用<code>v-on:XXX</code> 或者<code>@XXX</code>绑定事件，其中<code>XXX</code>是事件名</p></li><li><p>事件的回调需要配置在<strong>methods</strong>对象中，最终会在<strong>vm</strong>上</p></li><li><p>methods中配置的函数，使用普通函数，若使用箭头函数 &#x3D;&gt; this 不再是vm</p></li><li><p>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象</p></li><li><p><code>@click=&quot;demo&quot;</code>和<code>@click=&quot;demo($event)&quot;</code>效果一致，但是后者可以传参</p></li><li><p>代码示例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;事件的基本使用&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h1&gt;        &lt;button v-on:click=&quot;showInfo1&quot;&gt;点我提示信息(不传参)&lt;/button&gt;        &lt;!-- 简写 --&gt;        &lt;button @click=&quot;showInfo2(666,$event)&quot;&gt;点我提示信息(传参)&lt;/button&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //阻止 vue 在启动时生成生产提示        Vue.config.productionTip = false;        new Vue(&#123;          el:&#39;#root&#39;,          data:&#123;            name:&#39;hhu&#39;          &#125;,          methods: &#123;            showInfo1(event)&#123;                console.log()                console.log(this)   //此处普通函数的this是vm                alert(&quot;Hello Student!&quot;)            &#125;,            showInfo2(number,event)&#123;                console.log(event.target.innerText)                console.log(number)                alert(&quot;Hello Student!!&quot;)            &#125;          &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><h4 id="1-7-2-事件修饰符"><a href="#1-7-2-事件修饰符" class="headerlink" title="1.7.2 事件修饰符"></a>1.7.2 事件修饰符</h4><ol><li><p><code>prevent</code>: 阻止默认事件</p></li><li><p><code>stop</code>: 阻止事件冒泡</p></li><li><p><code>once</code>: 事件只触发一次</p></li><li><p><code>capture</code>: 使用事件的捕获模式</p></li><li><p><code>self</code>: 只有<code>event.target</code>是当前操作元素时才触发事件</p></li><li><p><code>passive</code>: 事件的默认行为立即执行，无需等待事件回调执行完毕</p></li><li><p>代码示例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;事件修饰符&lt;/title&gt;        &lt;!-- 引入Vue --&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;        &lt;style&gt;            *&#123;                margin-top: 20px;            &#125;            .demo1&#123;                height: 50px;                background-color: skyblue;            &#125;            .box1&#123;                padding: 5px;                background-color: skyblue;            &#125;            .box2&#123;                padding: 5px;                background-color: orange;            &#125;            .list&#123;                width: 200px;                height: 200px;                background-color: peru;                overflow: auto;            &#125;            li&#123;                height: 100px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--            1.prevent：阻止默认事件（常用）；            2.stop：阻止事件冒泡（常用）；            3.once：事件只触发一次（常用）；            4.capture：使用事件的捕获模式；            5.self：只有event.target是当前操作的元素时才触发事件；            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；        --&gt;        &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;            &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt;            &lt;!-- 阻止默认事件（常用） --&gt;            &lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;            &lt;!-- 阻止事件冒泡（常用） --&gt;            &lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;                &lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;                &lt;!-- 修饰符可以连续写 --&gt;                &lt;!-- &lt;a href=&quot;http://www.bilibili.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt; --&gt;            &lt;/div&gt;            &lt;!-- 事件只触发一次（常用） --&gt;            &lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;            &lt;!-- 使用事件的捕获模式 --&gt;            &lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(1)&quot;&gt;                div1                &lt;div class=&quot;box2&quot; @click=&quot;showMsg(2)&quot;&gt;                    div2                &lt;/div&gt;            &lt;/div&gt;            &lt;!-- 只有event.target是当前操作的元素时才触发事件； --&gt;            &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;                &lt;button @click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;            &lt;/div&gt;            &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； --&gt;            &lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;                &lt;li&gt;1&lt;/li&gt;                &lt;li&gt;2&lt;/li&gt;                &lt;li&gt;3&lt;/li&gt;                &lt;li&gt;4&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。        new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                name:&#39;hhu&#39;            &#125;,            methods:&#123;                showInfo(e)&#123;                    alert(&#39;Hello Student！&#39;)                    // console.log(e.target)                &#125;,                showMsg(msg)&#123;                    console.log(msg)                &#125;,                demo()&#123;                    for (let i = 0; i &lt; 100000; i++) &#123;                        console.log(&#39;#&#39;)                    &#125;                    console.log(&#39;累坏了&#39;)                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><h4 id="1-7-3-键盘事件"><a href="#1-7-3-键盘事件" class="headerlink" title="1.7.3 键盘事件"></a>1.7.3 键盘事件</h4><ol><li><p>Vue中常用的案件别名</p><ol><li>回车 &#x3D;&gt; <code>enter</code></li><li>删除 &#x3D;&gt; <code>delete </code>(捕获“删除”和“退格”键)</li><li>退出 &#x3D;&gt; <code>esc</code></li><li>空格 &#x3D;&gt; <code>space</code></li><li>换行 &#x3D;&gt; <code>tab </code>(特殊，必须配合keydown去使用)</li><li>上 &#x3D;&gt; <code>up</code></li><li>下 &#x3D;&gt; <code>down</code></li><li>左 &#x3D;&gt; <code>left</code></li><li>右 &#x3D;&gt; <code>right</code></li></ol></li><li><p>Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p></li><li><p>系统修饰键（用法特殊）：<code>ctrl</code>、<code>alt</code>、<code>shift</code>、<code>meta</code></p><ol><li>配合<code>keyup</code>使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发</li><li>配合<code>keydown</code>使用：正常触发事件</li></ol></li><li><p>可以使用keyCode去指定具体的按键（不推荐）</p></li><li><p><code>Vue.config.keyCodes.自定义键名 = 键码</code>  &#x3D;&gt; 定制按键别名</p></li><li><p>代码示例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;键盘事件&lt;/title&gt;        &lt;!-- 引入Vue --&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;            &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keydown.huiche=&quot;showInfo&quot;&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。        Vue.config.keyCodes.huiche = 13 //定义一个别名按键        new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                name:&#39;hhu&#39;            &#125;,            methods: &#123;                showInfo(e)&#123;                    // console.log(e.key,e.keyCode)                    console.log(e.target.value)                &#125;            &#125;,        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><blockquote><ul><li><p>修饰符可以连续写</p></li><li><p>系统修饰符后可以接其他按键 &#x3D;&gt; 按下特定案件才能触发事件</p></li></ul></blockquote><h3 id="1-8-计算属性与监视"><a href="#1-8-计算属性与监视" class="headerlink" title="1.8 计算属性与监视"></a>1.8 计算属性与监视</h3><h4 id="1-8-1-计算属性-computed"><a href="#1-8-1-计算属性-computed" class="headerlink" title="1.8.1 计算属性-computed"></a>1.8.1 计算属性-computed</h4><blockquote><p>姓名案例实现</p></blockquote><ol><li><p>插值语法实现</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;姓名案例（插值语法实现）&lt;/title&gt;        &lt;!-- 引入Vue --&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;            last name: &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br/&gt;            first name: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br/&gt;            whole name: &lt;span&gt;&#123;&#123; lastName.slice(0,3) &#125;&#125;-&#123;&#123; firstName &#125;&#125;&lt;/span&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。        new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                lastName:&#39;张&#39;,                firstName:&#39;三&#39;            &#125;        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre></li><li><p>methods实现</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;姓名案例（methods实现）&lt;/title&gt;        &lt;!-- 引入Vue --&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;            last name: &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br/&gt;            first name: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br/&gt;            whole name: &lt;span&gt;&#123;&#123; fullName() &#125;&#125;&lt;/span&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。        new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                lastName:&#39;张&#39;,                firstName:&#39;三&#39;            &#125;,            methods: &#123;                fullName() &#123;                    return this.lastName + &#39;-&#39; + this.firstName;                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre></li><li><p>计算属性实现</p></li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;姓名案例（计算属性实现）&lt;/title&gt;        &lt;!-- 引入Vue --&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;            last name: &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br/&gt;            first name: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br/&gt;            whole name: &lt;span&gt;&#123;&#123; fullName &#125;&#125;&lt;/span&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。        new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                lastName:&#39;张&#39;,                firstName:&#39;三&#39;            &#125;,            computed: &#123;                fullName:&#123;                    //get作用：当读取fullName时，get就会被调用，且返回值就作为fullName的值                    //get调用时机：                        //1、初次读取fullName时                        //2、所依赖的数据发生变化时                    get()&#123;                        return this.lastName + &#39;-&#39; + this.firstName                    &#125;,                    //set调用时机： fullName被修改时                    set(value) &#123;                        const arr = value.split(&#39;-&#39;)                        lastName = arr[0]                        firstName = arr[1]                    &#125;                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre><ol start="4"><li><p>计算属性简写(<strong>只考虑读取计算属性时</strong>)</p><pre><code class="js">new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                lastName:&#39;张&#39;,                firstName:&#39;三&#39;            &#125;,            computed: &#123;                //完整写法                /* fullName:&#123;                    get()&#123;                        return this.lastName + &#39;-&#39; + this.firstName                    &#125;,                    set(value) &#123;                        const arr = value.split(&#39;-&#39;)                        lastName = arr[0]                        firstName = arr[1]                    &#125;                &#125; */                //简写形式                fullName()&#123;                    return this.lastName + &#39;-&#39; + this.firstName                &#125;            &#125;        &#125;)</code></pre></li></ol><blockquote><p>计算属性</p></blockquote><ol><li>定义：要用的属性不存在，要通过<strong>已有属性</strong>计算得来</li><li>原理：底层借助了<code>Object.defineProperty()</code> 方法提供的<code>getter</code>和<code>setter</code></li><li><code>get()</code>函数执行时机<ol><li>初次读取数据时</li><li>当依赖的数据发生改变时会被再次调用</li></ol></li><li>优势：与<code>methods</code>实现相比，内部有缓存机制（复用），效率更高，调试方便</li><li>注意事项<ol><li>计算属性最终会出现在vm上，<strong>直接读取</strong>即可</li><li>如果计算属性要被修改，必须要写<code>set()</code>函数去响应修改，并且<code>set()</code>中要引起计算时所依赖的数据发生改变</li></ol></li></ol><h4 id="1-8-2-监视属性-watch"><a href="#1-8-2-监视属性-watch" class="headerlink" title="1.8.2 监视属性-watch"></a>1.8.2 监视属性-watch</h4><blockquote><p>天气案例</p></blockquote><ol><li>天气案例（methods实现）</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;天气案例&lt;/title&gt;        &lt;!-- 引入Vue --&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;            &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;&lt;br&gt;            &lt;button @click=&quot;changeWeather&quot;&gt;点击切换天气&lt;/button&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。        new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                isHot:true            &#125;,            computed: &#123;                info()&#123;                    return this.isHot ? &#39;炎热&#39; : &#39;寒冷&#39;                &#125;            &#125;,            methods: &#123;                changeWeather() &#123;                    this.isHot = !this.isHot                &#125;            &#125;,        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre><ol start="2"><li><p>天气案例（监视属性）</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;天气案例(监视属性)&lt;/title&gt;    &lt;!-- 引入Vue --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 准备好一个容器--&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;      &lt;br /&gt;      &lt;button @click=&quot;changeWeather&quot;&gt;点击切换天气&lt;/button&gt;    &lt;/div&gt;  &lt;/body&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false; //阻止 vue 在启动时生成生产提示。    const vm = new Vue(&#123;      el: &quot;#root&quot;,      data: &#123;        isHot: true,      &#125;,      computed: &#123;        info() &#123;          return this.isHot ? &quot;炎热&quot; : &quot;寒冷&quot;;        &#125;,      &#125;,      methods: &#123;        changeWeather() &#123;          this.isHot = !this.isHot;        &#125;,      &#125;,    //   watch: &#123;    //     isHot: &#123;    //       immediate: true, //初始化时让handler调用    //       handler(newValue, oldValue) &#123;    //         console.log(&quot;isHot被修改了&quot;, newValue, oldValue);    //       &#125;,    //     &#125;,    //   &#125;,    &#125;);    vm.$watch(&quot;isHot&quot;, &#123;      handler(newValue, oldValue) &#123;        console.log(&quot;isHot被修改了&quot;, newValue, oldValue);      &#125;,    &#125;);  &lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><blockquote><p>监视属性watch</p></blockquote><ol><li><p>当被监视的属性变化时，回调函数自动调用，进行相关操作</p></li><li><p>监事的属性必须存在，才能进行监视</p></li><li><p>监视的两种写法</p><ol><li><code>new Vue</code>时传入<code>watch</code>配置</li><li>通过<code>vm.$watch()</code> 监视</li></ol></li><li><p>深度监视</p><ol><li>Vue中的watch默认不监测对象内部值的改变</li><li>配置<code>deep:true</code>可以监测对象内部值的改变</li></ol></li><li><p>简写形式（<strong>只有handler()函数时</strong>）</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;天气案例(监视简写)&lt;/title&gt;    &lt;!-- 引入Vue --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 准备好一个容器--&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;      &lt;br /&gt;      &lt;button @click=&quot;changeWeather&quot;&gt;点击切换天气&lt;/button&gt;    &lt;/div&gt;  &lt;/body&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false; //阻止 vue 在启动时生成生产提示。    const vm = new Vue(&#123;      el: &quot;#root&quot;,      data: &#123;        isHot: true      &#125;,      computed: &#123;        info() &#123;          return this.isHot ? &quot;炎热&quot; : &quot;寒冷&quot;;        &#125;,      &#125;,      methods: &#123;        changeWeather() &#123;          this.isHot = !this.isHot;        &#125;,      &#125;,      watch: &#123;        //正常写法        /* isHot: &#123;          immediate: true, //初始化时让handler调用          deep:true,          handler(newValue, oldValue) &#123;            console.log(&quot;isHot被修改了&quot;, newValue, oldValue);          &#125;,        &#125;, */        //简写        isHot(newValue,oldValue)&#123;          console.log(&quot;isHot被修改了&quot;, newValue, oldValue);        &#125;    &#125;,    &#125;)    //正常写法        /* vm.$watch(&#39;isHot&#39;,&#123;            immediate:true, //初始化时让handler调用一下            deep:true,//深度监视            handler(newValue,oldValue)&#123;                console.log(&#39;isHot被修改了&#39;,newValue,oldValue)            &#125;        &#125;) */        //简写        /* vm.$watch(&#39;isHot&#39;,(newValue,oldValue)=&gt;&#123;            console.log(&#39;isHot被修改了&#39;,newValue,oldValue,this)        &#125;) */  &lt;/script&gt;&lt;/html&gt;</code></pre></li><li><p><strong><code>computed</code>和<code>watch</code>的区别</strong></p><ol><li><code>computed</code>能完成的功能，<code>watch</code>也可以完成</li><li><code>watch</code>能完成的功能，<code>computed</code>不一定能完成。例如：<code>watch</code>可以进行异步操作</li></ol></li><li><p><strong>两个重要的小原则</strong></p><ol><li>所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或者 组件实例对象</li><li>所有不被Vue所管理的函数（定时器的回调函数、Ajax的回调函数、Promise的回调函数等）最好写成箭头函数，这样this的指向才是vm 或者 组件实例对象</li></ol></li></ol><h3 id="1-9-绑定样式"><a href="#1-9-绑定样式" class="headerlink" title="1.9 绑定样式"></a>1.9 绑定样式</h3><ol><li><p><code>class</code>样式</p><ol><li>写法<code>:class=&quot;xxx&quot;</code>,xxx可以是字符串、对象、数组<ol><li>字符串写法适用于：类名不确定，需要动态获取</li><li>对象写法适用于：要绑定多个样式，个数不确定，名字也不确定</li><li>数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用</li></ol></li></ol></li><li><p><code>style</code>样式</p><ol><li><code>:style=&quot;&#123;fontSize:xxx&#125;&quot;</code>，其中xxx是动态值</li><li><code>:style=[a,b]</code>，其中a、b都是样式对象</li></ol></li><li><p>代码示例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;绑定样式&lt;/title&gt;        &lt;style&gt;            .basic&#123;                width: 400px;                height: 100px;                border: 1px solid black;            &#125;                        .happy&#123;                border: 4px solid red;;                background-color: rgba(255, 255, 0, 0.644);                background: linear-gradient(30deg,yellow,pink,orange,yellow);            &#125;            .sad&#123;                border: 4px dashed rgb(2, 197, 2);                background-color: gray;            &#125;            .normal&#123;                background-color: skyblue;            &#125;            .atguigu1&#123;                background-color: yellowgreen;            &#125;            .atguigu2&#123;                font-size: 30px;                text-shadow:2px 2px 10px red;            &#125;            .atguigu3&#123;                border-radius: 20px;            &#125;        &lt;/style&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--             绑定样式：                    1. class样式                                写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。                                        字符串写法适用于：类名不确定，要动态获取。                                        对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。                                        数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。                    2. style样式                                :style=&quot;&#123;fontSize: xxx&#125;&quot;其中xxx是动态值。                                :style=&quot;[a,b]&quot;其中a、b是样式对象。        --&gt;        &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;            &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;            &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;            &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt;            &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;            &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt;            &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;            &lt;!-- 绑定style样式--对象写法 --&gt;            &lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;            &lt;!-- 绑定style样式--数组写法 --&gt;            &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false                const vm = new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                name:&#39;尚硅谷&#39;,                mood:&#39;normal&#39;,                classArr:[&#39;atguigu1&#39;,&#39;atguigu2&#39;,&#39;atguigu3&#39;],                classObj:&#123;                    atguigu1:false,                    atguigu2:false,                &#125;,                styleObj:&#123;                    fontSize: &#39;40px&#39;,                    color:&#39;red&#39;,                &#125;,                styleObj2:&#123;                    backgroundColor:&#39;orange&#39;                &#125;,                styleArr:[                    &#123;                        fontSize: &#39;40px&#39;,                        color:&#39;blue&#39;,                    &#125;,                    &#123;                        backgroundColor:&#39;gray&#39;                    &#125;                ]            &#125;,            methods: &#123;                changeMood()&#123;                    const arr = [&#39;happy&#39;,&#39;sad&#39;,&#39;normal&#39;]                    const index = Math.floor(Math.random()*3)                    this.mood = arr[index]                &#125;            &#125;,        &#125;)    &lt;/script&gt;    &lt;/html&gt;</code></pre></li></ol><h3 id="1-10-条件渲染"><a href="#1-10-条件渲染" class="headerlink" title="1.10 条件渲染"></a>1.10 条件渲染</h3><ol><li><p><code>v-if</code></p><ol><li>写法：<ol><li><code>v-if=&quot;表达式&quot;</code></li><li><code>v-else-if=&quot;表达式&quot;</code></li><li><code>v-else=&quot;表达式&quot;</code></li></ol></li><li>使用场景：切换频率较低的场景</li><li>特点：不展示的DOM元素直接被移除</li><li>注意事项<ol><li><code>v-if</code>可以和<code>v-else-if</code>、<code>v-else</code>一起使用，但要求结构不能被“打断”</li></ol></li></ol></li><li><p><code>v-show</code></p><ol><li>写法：<code>v-show=&quot;表达式&quot;</code></li><li>使用场景：切换频率较高的场景</li><li>特点：不展示的DOM元素未被移除，仅仅使用样式隐藏掉</li></ol></li><li><p>注意事项</p><ol><li>使用<code>v-if</code>的时候，元素可能无法获取到，而使用<code>v-show</code>一定可以获取到</li></ol></li><li><p>代码案例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;条件渲染&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--                 条件渲染：                            1.v-if                                        写法：                                                (1).v-if=&quot;表达式&quot;                                                 (2).v-else-if=&quot;表达式&quot;                                                (3).v-else=&quot;表达式&quot;                                        适用于：切换频率较低的场景。                                        特点：不展示的DOM元素直接被移除。                                        注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。                            2.v-show                                        写法：v-show=&quot;表达式&quot;                                        适用于：切换频率较高的场景。                                        特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉                                                            3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。         --&gt;        &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;            &lt;h2&gt;当前的n值是:&#123;&#123;n&#125;&#125;&lt;/h2&gt;            &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;            &lt;!-- 使用v-show做条件渲染 --&gt;            &lt;!-- &lt;h2 v-show=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;            &lt;!-- &lt;h2 v-show=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;            &lt;!-- 使用v-if做条件渲染 --&gt;            &lt;!-- &lt;h2 v-if=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;            &lt;!-- &lt;h2 v-if=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;            &lt;!-- v-else和v-else-if --&gt;            &lt;!-- &lt;div v-if=&quot;n === 1&quot;&gt;Angular&lt;/div&gt;            &lt;div v-else-if=&quot;n === 2&quot;&gt;React&lt;/div&gt;            &lt;div v-else-if=&quot;n === 3&quot;&gt;Vue&lt;/div&gt;            &lt;div v-else&gt;哈哈&lt;/div&gt; --&gt;            &lt;!-- v-if与template的配合使用 --&gt;            &lt;template v-if=&quot;n === 1&quot;&gt;                &lt;h2&gt;你好&lt;/h2&gt;                &lt;h2&gt;hhu&lt;/h2&gt;                &lt;h2&gt;江苏&lt;/h2&gt;            &lt;/template&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false        const vm = new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                name:&#39;hhu&#39;,                n:0            &#125;        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><h3 id="1-11-列表渲染"><a href="#1-11-列表渲染" class="headerlink" title="1.11 列表渲染"></a>1.11 列表渲染</h3><h4 id="1-11-1-基本列表"><a href="#1-11-1-基本列表" class="headerlink" title="1.11.1 基本列表"></a>1.11.1 基本列表</h4><ol><li><p><code>v-for</code>指令</p><ol><li>用于展示列表数据</li><li>语法：<code>v-for=&quot;(item,index) in xxx&quot; :key=&quot;yyy&quot;</code></li><li>可遍历：数组、对象、字符串（少）、指定次数（少）</li></ol></li><li><p>代码示例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;基本列表&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt;      &lt;ul&gt;        &lt;li v-for=&quot;(person,index) in personList&quot; ::key=&quot;person.id&quot;&gt;          &#123;&#123;person.name&#125;&#125; - &#123;&#123;person.age&#125;&#125;        &lt;/li&gt;      &lt;/ul&gt;      &lt;h2&gt;汽车信息（遍历对象）&lt;/h2&gt;      &lt;ul&gt;        &lt;li v-for=&quot;(value,k) of car&quot; :key=&quot;k&quot;&gt;&#123;&#123;k&#125;&#125; - &#123;&#123;value&#125;&#125;&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      Vue.config.productionTip = false;      new Vue(&#123;        el: &quot;#root&quot;,        data: &#123;          personList: [            &#123; id: &quot;001&quot;, name: &quot;张三&quot;, age: 18 &#125;,            &#123; id: &quot;002&quot;, name: &quot;李四&quot;, age: 19 &#125;,            &#123; id: &quot;003&quot;, name: &quot;王五&quot;, age: 20 &#125;,          ],          car: &#123;            name: &quot;奥迪A8&quot;,            price: &quot;70万&quot;,            color: &quot;黑色&quot;,          &#125;,        &#125;,      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><h4 id="1-11-2-key的原理"><a href="#1-11-2-key的原理" class="headerlink" title="1.11.2 key的原理"></a>1.11.2 key的原理</h4><ol><li><p>虚拟DOM中Key的作用 &#x3D;&gt; Key是虚拟DOM对象的<strong>标识</strong>，当数据发生变化时，VUe会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】和【旧虚拟DOM】的差异比较，<strong>比较规则</strong>如下</p><ol><li>旧虚拟DOM中找到与新虚拟DOM相同的Key<ol><li>若虚拟DOM中内容没变，直接使用之前的真实DOM</li><li>若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM</li></ol></li><li>旧虚拟DOM中未找到与新虚拟DOM相同的Key<ol><li>创建新的真实DOM，随后渲染到页面</li></ol></li></ol></li><li><p>用<code>index</code>作为Key可能会引发的问题</p><ol><li>若对数据进行“逆序添加、逆序删除等”破坏顺序的操作 &#x3D;&gt; 会产生没有必要的真实DOM的更新 &#x3D;&gt; 界面渲染没有问题，但是效率低下</li><li>如果结构中还包含输入类DOM &#x3D;&gt; 会产生错误DOM更新 &#x3D;&gt; 界面有问题</li></ol></li><li><p>开发中选择Key</p><ol><li>使用每条数据的唯一标识作为Key，比如id、手机号、身份证号等</li><li>如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表展示，使用index作为Key是没有问题的</li></ol></li><li><p>示意图</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Key%E7%9A%84%E5%8E%9F%E7%90%86.png"></p></li></ol><h4 id="1-11-3-列表过滤"><a href="#1-11-3-列表过滤" class="headerlink" title="1.11.3 列表过滤"></a>1.11.3 列表过滤</h4><ol><li><p>案例展示</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;列表过滤&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;h2&gt;人员列表&lt;/h2&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keywords&quot;&gt;      &lt;ul&gt;        &lt;li v-for=&quot;(person,index) in filPerson&quot; ::key=&quot;index&quot;&gt;          &#123;&#123;person.name&#125;&#125; - &#123;&#123;person.age&#125;&#125;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      Vue.config.productionTip = false;      new Vue(&#123;        el: &quot;#root&quot;,        data: &#123;            keywords:&#39;&#39;,            personList: [                &#123;id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;&#125;,                &#123;id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;&#125;,                &#123;id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;&#125;,                &#123;id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;&#125;            ],            // filPerson:[]        &#125;,        /* watch:&#123;            keywords:&#123;                immediate: true,                handler(val) &#123;                    this.filPerson = this.personList.filter((person)=&gt;&#123;                        return person.name.indexOf(val) !== -1                    &#125;)                &#125;               &#125;        &#125; */        computed:&#123;            filPerson()&#123;                return this.personList.filter((person)=&gt;&#123;                    return person.name.indexOf(this.keywords) !== -1                &#125;)            &#125;        &#125;      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><h4 id="1-11-4-列表排序"><a href="#1-11-4-列表排序" class="headerlink" title="1.11.4 列表排序"></a>1.11.4 列表排序</h4><ol><li><p>代码案例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;列表排序&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;h2&gt;人员列表&lt;/h2&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keywords&quot; /&gt;      &lt;button @click=&quot;sortType=1&quot;&gt;降序&lt;/button&gt;      &lt;button @click=&quot;sortType=2&quot;&gt;升序&lt;/button&gt;      &lt;button @click=&quot;sortType=0&quot;&gt;原序&lt;/button&gt;      &lt;ul&gt;        &lt;li v-for=&quot;(person,index) in filPerson&quot; ::key=&quot;person.id&quot;&gt;          &#123;&#123;person.name&#125;&#125; - &#123;&#123;person.age&#125;&#125;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      Vue.config.productionTip = false;      new Vue(&#123;        el: &quot;#root&quot;,        data: &#123;          keywords: &quot;&quot;,          sortType: 0, //排序类型 0=&gt;原顺序  1=&gt;降序  2=&gt;升序          personList: [            &#123; id: &quot;001&quot;, name: &quot;马冬梅&quot;, age: 39, sex: &quot;女&quot; &#125;,            &#123; id: &quot;002&quot;, name: &quot;周冬雨&quot;, age: 24, sex: &quot;女&quot; &#125;,            &#123; id: &quot;003&quot;, name: &quot;周杰伦&quot;, age: 19, sex: &quot;男&quot; &#125;,            &#123; id: &quot;004&quot;, name: &quot;温兆伦&quot;, age: 22, sex: &quot;男&quot; &#125;,          ],        &#125;,        computed: &#123;          filPerson() &#123;            const arr = this.personList.filter((person) =&gt; &#123;              return person.name.indexOf(this.keywords) !== -1;            &#125;);            if (this.sortType) &#123;              arr.sort((p1, p2) =&gt; &#123;                return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age;              &#125;);            &#125;            return arr          &#125;,        &#125;,      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><h4 id="1-11-5-Vue监视数据的原理"><a href="#1-11-5-Vue监视数据的原理" class="headerlink" title="1.11.5 Vue监视数据的原理"></a>1.11.5 Vue监视数据的原理</h4><ol><li><p>Vue会监视<code>data</code>中所有层次的数据</p></li><li><p>监视对象中的数据 &#x3D;&gt; 通过<code>setter</code>实现监视，且要在创建Vue示例时就要传入要监视的数据</p><ol><li>对象中后追加的属性，Vue默认不做响应式处理</li><li>如需给后添加的属性做响应式 &#x3D;&gt; 使用API<ol><li><code>Vue.set(target,propertyName/index,value)</code></li><li><code>vm.$set(target,propertyName/index,value)</code></li></ol></li></ol></li><li><p>监视数组中的数据 &#x3D;&gt; 通过包裹数组更新元素的方法实现，本质做了两件事</p><ol><li>调用Js原生对应的方法对数组进行更新</li><li>重新解析模板，进而更新页面</li></ol></li><li><p>在Vue修改数组中的某个元素的方法</p><ol><li>API:<code>push()、pop()、shift()、unshift()、splice()、sort()、reverse()</code></li><li><code>Vue.set()</code> or <code>vm.$set()</code></li></ol></li><li><p>注意事项</p><ol><li><code>Vue.set()</code> 和 <code>vm.$set()</code>不能给<strong>vm</strong>或者<strong>vm的根数据对象</strong>添加属性</li></ol></li><li><p>代码案例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;数据监测&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;h1&gt;学生信息&lt;/h1&gt;      &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br/&gt;      &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt;      &lt;button @click=&quot;student.sex = &#39;none&#39;&quot;&gt;修改性别&lt;/button&gt; &lt;br/&gt;      &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br/&gt;      &lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt;      &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br/&gt;      &lt;button @click=&quot;updateHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br/&gt;      &lt;button @click=&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br/&gt;          &lt;h3&gt;name:&#123;&#123;student.name&#125;&#125;&lt;/h3&gt;      &lt;h3&gt;age:&#123;&#123;student.age&#125;&#125;&lt;/h3&gt;      &lt;h3 v-if=&quot;student.sex&quot;&gt;sex:&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt;      &lt;h3&gt;hobby:&lt;/h3&gt;      &lt;ul&gt;        &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;            &#123;&#123;h&#125;&#125;        &lt;/li&gt;      &lt;/ul&gt;      &lt;h3&gt;friends:&lt;/h3&gt;      &lt;ul&gt;        &lt;li v-for=&quot;(f,index) in student.friends&quot;&gt;            &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;    &lt;/body&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false;    new Vue(&#123;      el:&#39;#root&#39;,      data:&#123;        student:&#123;          name:&#39;tom&#39;,          age:18,          hobby:[&#39;抽烟&#39;,&#39;喝酒&#39;,&#39;烫头&#39;],          friends:[              &#123;name:&#39;jerry&#39;,age:35&#125;,              &#123;name:&#39;tony&#39;,age:36&#125;          ]        &#125;      &#125;,      methods: &#123;        addSex()&#123;            // Vue.set(this.student,&#39;sex&#39;,&#39;man&#39;)            this.$set(this.student,&#39;sex&#39;,&#39;man&#39;)        &#125;,        addFriend()&#123;            this.student.friends.unshift(&#123;name:&#39;jack&#39;,age:70&#125;)        &#125;,        updateFirstFriendName()&#123;            this.student.friends[0].name = &#39;张三&#39;        &#125;,        addHobby()&#123;            this.student.hobby.push(&#39;study&#39;)        &#125;,        updateHobby()&#123;            // this.student.hobby.splice(0,1,&#39;Drive&#39;)            // Vue.set(this.student.hobby,0,&#39;Drive&#39;)            this.$set(this.student.hobby,0,&#39;Drive&#39;)        &#125;,        removeSmoke()&#123;            this.student.hobby = this.student.hobby.filter((h)=&gt;&#123;                return h !== &#39;抽烟&#39;            &#125;)        &#125;      &#125;,    &#125;)  &lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><h3 id="1-12-收集表单数据"><a href="#1-12-收集表单数据" class="headerlink" title="1.12 收集表单数据"></a>1.12 收集表单数据</h3><ol><li><p>若：<code>&lt;input type=&quot;text&quot;/&gt;</code>，则<code>v-model</code>收集的是<code>value</code>值，用户输入的就是<code>value</code>值</p></li><li><p>若：<code>&lt;input type=&quot;radio&quot;/&gt;</code>，则<code>v-model</code>收集的是<code>value</code>值，且要给标签配置<code>value</code>值</p></li><li><p>若：<code>&lt;input type=&quot;checkbox&quot;/&gt;</code></p><ol><li>没有配置<code>input</code>的<code>value</code>属性，那么收集的就是<code>checked</code>（勾选 or 未勾选，是布尔值）</li><li>配置<code>input</code>的<code>value</code>属性<ol><li><code>v-model</code>的初始值是非数组，那么收集的就是<code>checked</code>（勾选 or 未勾选，是布尔值）</li><li><code>v-model</code>的初始值是数组，那么收集的的就是<code>value</code>组成的数组</li></ol></li></ol></li><li><p>代码示例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;收集表单数据&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;form @submit.prevent=&quot;demo&quot;&gt;            账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.userAccount&quot;&gt;&lt;br&gt;&lt;br&gt;            密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.userPassword&quot;&gt;&lt;br&gt;&lt;br&gt;            年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt;&lt;br&gt;&lt;br&gt;            性别：            男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt;            女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;famale&quot;&gt;            &lt;br&gt;&lt;br&gt;            爱好：            学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;            跑步&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;run&quot;&gt;            吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt;            &lt;br&gt;&lt;br&gt;            所在城市：            &lt;select v-model=&quot;userInfo.city&quot;&gt;              &lt;option value=&quot;&quot;&gt;请选择城市&lt;/option&gt;              &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;              &lt;option value=&quot;jiangsu&quot;&gt;江苏&lt;/option&gt;              &lt;option value=&quot;anhui&quot;&gt;安徽&lt;/option&gt;              &lt;option value=&quot;zhejiang&quot;&gt;浙江&lt;/option&gt;            &lt;/select&gt;            &lt;br&gt;&lt;br&gt;            其他信息：            &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt;            &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受 &lt;a href=&quot;https:www.github.com/CodingJuzi&quot;&gt;《用户协议》&lt;/a&gt;            &lt;br&gt;            &lt;button&gt;提交&lt;/button&gt;          &lt;/form&gt;    &lt;/div&gt;  &lt;/body&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false;    new Vue(&#123;      el: &quot;#root&quot;,      data: &#123;        userInfo:&#123;          userAccount:&#39;&#39;,          userPassword:&#39;&#39;,          age:&#39;&#39;,          sex:&#39;&#39;,          hobby:[],          city:&#39;jiangsu&#39;,          other:&#39;&#39;,          agree:&#39;&#39;        &#125;      &#125;,      methods: &#123;        demo()&#123;            console.log(JSON.stringify(this.userInfo))        &#125;      &#125;,    &#125;);  &lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><h3 id="1-13-过滤器"><a href="#1-13-过滤器" class="headerlink" title="1.13 过滤器"></a>1.13 过滤器</h3><ol><li><p>定义：对要显示的数据进行特定格式化后再显示</p></li><li><p>语法：</p><ol><li>注册过滤器：<code>Vue.filter(name,callback)</code>或者<code>new Vue&#123;filters:&#123;&#125;&#125;</code></li><li>使用过滤器：<code>&#123;&#123;xxx | 过滤器名&#125;&#125;</code> 或者<code>v-bind:属性=&quot;xxx | 过滤器名&quot;</code></li></ol></li><li><p>备注</p><ol><li>过滤器也可以接收额外参数、多个过滤器也可以串联</li><li>过滤器并未改变原本的数据，而是产生了新的对应的数据</li></ol></li><li><p>代码案例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;过滤器&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/dayjs.min.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;            &lt;h2&gt;显示格式化后的时间&lt;/h2&gt;            &lt;!-- 计算属性实现 --&gt;            &lt;h3&gt;现在是：&#123;&#123;fmtTime&#125;&#125;&lt;/h3&gt;            &lt;!-- methods实现 --&gt;            &lt;h3&gt;现在是：&#123;&#123;getFmtTime()&#125;&#125;&lt;/h3&gt;            &lt;!-- 过滤器实现 --&gt;            &lt;h3&gt;现在是：&#123;&#123;time | timeFormater&#125;&#125;&lt;/h3&gt;            &lt;!-- 过滤器实现（传参） --&gt;            &lt;h3&gt;现在是：&#123;&#123;time | timeFormater('YYYY_MM_DD') | mySlice&#125;&#125;&lt;/h3&gt;            &lt;h3 :x=&quot;msg | mySlice&quot;&gt;hhu&lt;/h3&gt;        &lt;/div&gt;        &lt;div id=&quot;root2&quot;&gt;            &lt;h2&gt;&#123;&#123;msg | mySlice&#125;&#125;&lt;/h2&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false        //全局过滤器        Vue.filter(&#39;mySlice&#39;,function(value)&#123;            return value.slice(0,4)        &#125;)                new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                time:1621561377603, //时间戳                msg:&#39;Hello,hhu&#39;            &#125;,            computed: &#123;                fmtTime()&#123;                    return dayjs(this.time).format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)                &#125;            &#125;,            methods: &#123;                getFmtTime()&#123;                    return dayjs(this.time).format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)                &#125;            &#125;,            //局部过滤器            filters:&#123;                timeFormater(value,str=&#39;YYYY年MM月DD日 HH:mm:ss&#39;)&#123;                    return dayjs(value).format(str)                &#125;            &#125;        &#125;)        new Vue(&#123;            el:&#39;#root2&#39;,            data:&#123;                msg:&#39;hello,atguigu!&#39;            &#125;        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><h3 id="1-14-内置指令"><a href="#1-14-内置指令" class="headerlink" title="1.14 内置指令"></a>1.14 内置指令</h3><blockquote><p>已经学过的指令</p><ol><li>v-bind   : 单向绑定解析表达式, 可简写为 :xxx</li><li>v-model : 双向数据绑定</li><li>v-for  : 遍历数组&#x2F;对象&#x2F;字符串</li><li>v-on   : 绑定事件监听, 可简写为@</li><li>v-if     : 条件渲染（动态控制节点是否存存在）</li><li>v-else  : 条件渲染（动态控制节点是否存存在）</li><li>v-show  : 条件渲染 (动态控制节点是否展示)</li></ol></blockquote><h4 id="1-14-1-v-text"><a href="#1-14-1-v-text" class="headerlink" title="1.14.1 v-text"></a>1.14.1 v-text</h4><ol><li>作用：向其所在的节点中渲染文本内容</li><li>与插值语法的区别：<code>v-text</code>会替换掉节点中的内容，<code>&#123;&#123;xx&#125;&#125;</code>不会</li></ol><h4 id="1-14-2-v-html"><a href="#1-14-2-v-html" class="headerlink" title="1.14.2 v-html"></a>1.14.2 v-html</h4><ol><li>作用：向指定节点中渲染包含html结构的内容</li><li>与插值语法的区别<ol><li><code>v-html</code>会替换掉节点中所有的内容，<code>&#123;&#123;xx&#125;&#125;</code>不会</li><li><code>v-html</code>可以识别html结构</li></ol></li><li>注意事项<ol><li><strong>v-html有安全性问题</strong><ol><li>在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击</li><li>一定要在可信的内容上使用<code>v-html</code>，永远不要使用在用户提交的内容上</li></ol></li></ol></li></ol><h4 id="1-14-3-v-cloak"><a href="#1-14-3-v-cloak" class="headerlink" title="1.14.3 v-cloak"></a>1.14.3 v-cloak</h4><ol><li>没有值</li><li>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉<code>v-vloak</code>属性</li><li>使用css配合<code>v-cloak</code>可以解决网速慢时页面展示出现<code>&#123;&#123;XXX&#125;&#125;</code>的问题</li></ol><h4 id="1-14-4-v-once"><a href="#1-14-4-v-once" class="headerlink" title="1.14.4 v-once"></a>1.14.4 v-once</h4><ol><li><code>v-once</code>所在的节点在初次动态渲染后，就被视为静态内容</li><li>以后数据的改变不会引起<code>v-once</code>所在结构的更新，可以用于优化性能</li></ol><h4 id="1-14-5-v-pre"><a href="#1-14-5-v-pre" class="headerlink" title="1.14.5 v-pre"></a>1.14.5 v-pre</h4><ol><li>跳过其所在节点的编译过程</li><li>可利用他跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译</li></ol><h3 id="1-15-自定义指令"><a href="#1-15-自定义指令" class="headerlink" title="1.15 自定义指令"></a>1.15 自定义指令</h3><ol><li><p>定义语法</p><ol><li><p>局部指令</p><pre><code class="html">new Vue(&#123;    directives:&#123;指令名：配置对象&#125;&#125;)&lt;!-- 或者 --&gt;new Vue(&#123;    directives:&#123;指令名：回调函数&#125;&#125;)</code></pre></li><li><p>全局指令</p><pre><code class="html">Vue.directive(指令名,配置对象)&lt;!-- 或者 --&gt;Vue.directive(指令名,回调函数)</code></pre></li></ol></li><li><p>配置对象中常用的3个回调</p><ol><li><code>bind</code>:指定与元素成功绑定时调用</li><li><code>inserted</code>:指令所在的元素被插入页面时调用</li><li><code>update</code>:指令所在的模板被重新解析时调用</li></ol></li><li><p>备注</p><ol><li>指令定义时不加v-，但是使用时要在v-</li><li>指令名如果是多个单词，要使用<code>kabab-case</code>命名方式，不要使用<code>camelCase</code>命名</li></ol></li><li><p>代码示例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;自定义指令&lt;/title&gt;    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;        &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;        &lt;button @click=&quot;n++&quot;&gt;点我n++&lt;/button&gt;        &lt;hr&gt;        &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;    &lt;/div&gt;&lt;/body&gt;    &lt;script&gt;        Vue.config.productionTip = false        //全局指令        /* Vue.directive(&#39;fbind&#39;,&#123;                //指令与元素成功绑定时                bind(element,binding)&#123;                    element.innerText = binding.value;                &#125;,                //指令所在元素被插入页面时                inserted(element,binding) &#123;                    element.focus()                &#125;,                //指令所在的模板被重新解析时                update(element,binding) &#123;                    element.innerText = binding.value                &#125;            &#125;) */        /* Vue.directive(&#39;big&#39;,function(element,binding)&#123;            element.innerText = binding.value * 10        &#125;) */        new Vue(&#123;          el:&#39;#root&#39;,          data:&#123;             n:1          &#125;,          directives:&#123;            //big函数调用时机             /*                 1.指令与元素成功绑定时                2.指令所在的模板被重新解析时            */            big(element,binding)&#123;                element.innerText = binding.value * 10            &#125;,            fbind:&#123;                //指令与元素成功绑定时                bind(element,binding)&#123;                    element.innerText = binding.value;                &#125;,                //指令所在元素被插入页面时                inserted(element,binding) &#123;                    element.focus()                &#125;,                //指令所在的模板被重新解析时                update(element,binding) &#123;                    element.innerText = binding.value                &#125;            &#125;          &#125;        &#125;)    &lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><h3 id="1-16-生命周期"><a href="#1-16-生命周期" class="headerlink" title="1.16 生命周期"></a>1.16 生命周期</h3><ol><li><p>别名：生命周期回调函数、生命周期函数、生命周期钩子</p></li><li><p>&#x3D;&gt; Vue在关键时刻调用的一些特殊名称的函数</p></li><li><p>生命周期函数的名称不可更改，但是函数的具体内容是根据需求编写的</p></li><li><p>生命周期函数中this指向是vm或者组件实例对象</p></li><li><p><strong>示意图</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p></li><li><p>常用的生命周期钩子</p><ol><li><code>mounted</code>：发送Ajax请求、启动定时器、绑定自定义事件、订阅信息等【初始化操作】</li><li><code>beforeDestroy</code>：清除定时器、解除自定义事件、取消订阅消息等【收尾工作】</li></ol></li><li><p>关于销毁Vue实例的几点说明</p><ol><li>销毁后借助Vue开发者工具看不到任何消息</li><li>销毁后自定义事件会失效，但原生DOM事件依然有效</li><li>一般不会在<code>beforeDestroy</code>操作数据，因为即便操作数据，也不会再出发更新流程</li></ol></li></ol><h2 id="2-Vue组件化编程"><a href="#2-Vue组件化编程" class="headerlink" title="2 Vue组件化编程"></a>2 Vue组件化编程</h2><h3 id="2-1-模块与组件、模块化与组件化"><a href="#2-1-模块与组件、模块化与组件化" class="headerlink" title="2.1 模块与组件、模块化与组件化"></a>2.1 模块与组件、模块化与组件化</h3><h4 id="2-1-1-模块"><a href="#2-1-1-模块" class="headerlink" title="2.1.1 模块"></a>2.1.1 模块</h4><ol><li>理解: 向外提供特定功能的 js 程序, 一般就是一个 js 文件 </li><li>为什么: js 文件很多很复杂 </li><li>作用: 复用 js, 简化 js 的编写, 提高 js 运行效率</li></ol><h4 id="2-1-2-组件"><a href="#2-1-2-组件" class="headerlink" title="2.1.2 组件"></a>2.1.2 组件</h4><ol><li>理解: 用来实现局部(特定)功能效果的代码集合(html&#x2F;css&#x2F;js&#x2F;image…..) </li><li>为什么: 一个界面的功能很复杂</li><li>作用：复用编码、简化项目编码、提高运行效率</li></ol><h4 id="2-1-3-模块化"><a href="#2-1-3-模块化" class="headerlink" title="2.1.3 模块化"></a>2.1.3 模块化</h4><p>当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用</p><h4 id="2-1-4-组件化"><a href="#2-1-4-组件化" class="headerlink" title="2.1.4 组件化"></a>2.1.4 组件化</h4><p>当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E7%BC%96%E5%86%99%E5%BA%94%E7%94%A8.png"><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Vue%E5%AE%98%E7%BD%91%E7%9A%84%E7%BB%84%E4%BB%B6%E7%90%86%E8%A7%A3.png"></p><h3 id="2-2-非单文件组件"><a href="#2-2-非单文件组件" class="headerlink" title="2.2 非单文件组件"></a>2.2 非单文件组件</h3><h4 id="2-2-1-基本使用"><a href="#2-2-1-基本使用" class="headerlink" title="2.2.1 基本使用"></a>2.2.1 基本使用</h4><ol><li><p>Vue中使用组件的三大步骤</p><ol><li>定义组件（创建组件）</li><li>注册组件</li><li>使用组件（写组件标签）</li></ol></li><li><p>定义组件</p><ol><li>使用<code>Vue.extend(options)</code>创建，其中<code>options</code>和<code>new Vue(options)</code>时传入的<code>options</code>几乎一样</li><li>区别：<ol><li>不写<code>el</code> &#x3D;&gt; 最终所有的组件都要经过一个vm的管理，由vm中的el决定</li><li>函数式<code>data</code> &#x3D;&gt; 避免组件被复用时，数据存在引用关系</li></ol></li><li>备注<ol><li>使用<code>template</code>可以配置组件结构</li></ol></li></ol></li><li><p>注册组件</p><ol><li>局部注册：靠<code>new Vue()</code>的时候传入<code>components</code>选项</li><li>全局注册：靠<code>Vue.component(&#39;组件名&#39;,组件)</code></li></ol></li><li><p>编写组件标签</p><ol><li><code>&lt;组件名&gt;&lt;/组件名&gt;</code></li></ol></li><li><p>代码示例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;组件的基本使用&lt;/title&gt;    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;hello&gt;&lt;/hello&gt;        &lt;hr&gt;        &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;        &lt;!-- 编写组件标签 --&gt;        &lt;school&gt;&lt;/school&gt;        &lt;hr&gt;        &lt;student&gt;&lt;/student&gt;    &lt;/div&gt;    &lt;hr&gt;    &lt;div id=&quot;root2&quot;&gt;        &lt;hello&gt;&lt;/hello&gt;    &lt;/div&gt;  &lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    //① 创建组件    //学校组件    const school = Vue.extend(&#123;      template: `            &lt;div class=&quot;demo&quot;&gt;                &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;                &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;            &lt;/div&gt;      `,      data() &#123;        return &#123;            schoolName: &quot;hhu&quot;,          address: &quot;江苏&quot;,        &#125;;      &#125;,      methods: &#123;        showName()&#123;            alert(this.schoolName)        &#125;      &#125;,    &#125;);    //学生组件    const student = Vue.extend(&#123;            template:`                &lt;div&gt;                    &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt;                    &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;                &lt;/div&gt;            `,            data()&#123;                return &#123;                    studentName:&#39;张三&#39;,                    age:18                &#125;            &#125;        &#125;)    //hello组件    const hello = Vue.extend(&#123;        template:`                &lt;div&gt;                    &lt;h2&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;/h2&gt;                &lt;/div&gt;            `,            data()&#123;                return &#123;                    name:&#39;Tom&#39;                &#125;            &#125;    &#125;)    //全局注册    Vue.component(&#39;hello&#39;,hello)    new Vue(&#123;      el: &quot;#root&quot;,      data: &#123;        msg: &quot;Hello&quot;,      &#125;,      //② 注册组件(局部注册)      components:&#123;        school,        student      &#125;    &#125;);    new Vue(&#123;        el:&#39;#root2&#39;    &#125;)  &lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><h4 id="2-2-2-注意事项"><a href="#2-2-2-注意事项" class="headerlink" title="2.2.2 注意事项"></a>2.2.2 注意事项</h4><ol><li><p>关于组件名:</p><ol><li><p>一个单词组成</p><ol><li>第一种写法(首字母小写)：school</li><li>第二种写法(首字母大写)：School</li></ol></li><li><p>多个单词组成：</p><ol><li><p>第一种写法(kebab-case命名)：my-school</p></li><li><p>第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)</p></li></ol></li><li><p>备注：</p><ol><li><p>组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。</p></li><li><p>可以使用name配置项指定组件在开发者工具中呈现的名字</p></li></ol></li></ol></li><li><p>关于组件标签:</p><ol><li><p>第一种写法：<school></school></p></li><li><p>第二种写法：<school/></p></li><li><p>备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。</p></li></ol></li><li><p>一个简写方式</p><ol><li><code>const school = Vue.extend(options) </code> &#x3D;&gt; <code>const school = options</code></li></ol></li></ol><h4 id="2-2-3-组件的嵌套"><a href="#2-2-3-组件的嵌套" class="headerlink" title="2.2.3 组件的嵌套"></a>2.2.3 组件的嵌套</h4><ol><li><p>代码示例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;组件的嵌套&lt;/title&gt;    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;hr /&gt;  &lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    //① 创建组件    //学生组件    const student = Vue.extend(&#123;      template: `                &lt;div&gt;                    &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt;                    &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;                &lt;/div&gt;            `,      data() &#123;        return &#123;          studentName: &quot;张三&quot;,          age: 18,        &#125;;      &#125;,    &#125;);    //学校组件    const school = Vue.extend(&#123;      template: `            &lt;div&gt;                &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt;                &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;                &lt;student&gt;&lt;/student&gt;            &lt;/div&gt;      `,      data() &#123;        return &#123;          schoolName: &quot;hhu&quot;,          address: &quot;江苏&quot;,        &#125;;      &#125;,      //注册组件（局部）      components: &#123;        student,      &#125;,    &#125;);    //hello组件    const hello = Vue.extend(&#123;      template: `                &lt;div&gt;                    &lt;h2&gt;Welcome to &#123;&#123;msg&#125;&#125;&lt;/h2&gt;                &lt;/div&gt;            `,      data() &#123;        return &#123;          msg: &quot;hhu&quot;,        &#125;;      &#125;,    &#125;);    //定义App组件    const app = &#123;      template: `            &lt;div&gt;                &lt;hello&gt;&lt;/hello&gt;                &lt;school&gt;&lt;/school&gt;                &lt;/div&gt;        `,      components: &#123;        school,        hello,      &#125;,    &#125;;    //全局注册    Vue.component(&quot;hello&quot;, hello);    new Vue(&#123;      template: `        &lt;div&gt;            &lt;app&gt;&lt;/app&gt;        &lt;/div&gt;      `,      el: &quot;#root&quot;,      //② 注册组件(局部注册)      components: &#123;        app,      &#125;,    &#125;);  &lt;/script&gt;&lt;/html&gt;</code></pre></li><li><p>嵌套示意图</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B5%8C%E5%A5%97.png"></p></li></ol><h4 id="2-2-4-VueComponent"><a href="#2-2-4-VueComponent" class="headerlink" title="2.2.4 VueComponent"></a>2.2.4 VueComponent</h4><ol><li><p>组件的本质是一个名为<code>VueComponent</code>的构造函数，不是由程序员定义，是<code>Vue.extend</code>生成的 </p></li><li><p>编写组件标签时，<code>Vue</code>解析时会帮我们创建组件的实例对象，即<code>Vue</code>帮我们执行的：<code>new VueComponent(options)</code></p></li><li><p>特别注意：每次调用<code>Vue.extend</code>，返回的都是一个全新的<code>VueComponent</code></p><pre><code class="js">Vue.extend = function (extendOptions) &#123;          /*………………*/          var Sub = function VueComponent(options) &#123;              this._init(options);          &#125;;          /*………………*/          return Sub;      &#125;;</code></pre></li><li><p>关于this指向</p><ol><li><p>组件配置中</p><p>data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是【<strong>VueComponent实例对象</strong>】</p></li><li><p><code>new Vue(options)</code>配置中</p><p>data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是【<strong>Vue实例对象</strong>】</p></li></ol></li><li><p>VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）</p><p>Vue的实例对象，以后简称vm</p></li></ol><h4 id="2-2-5-一个重要的内置关系"><a href="#2-2-5-一个重要的内置关系" class="headerlink" title="2.2.5 一个重要的内置关系"></a>2.2.5 一个重要的内置关系</h4><ol><li><code>VueComponent.prototype.__proto__ === Vue.prototype</code></li><li>作用 &#x3D;&gt; 让组件实例对象能够访问到Vue原型上的属性、方法</li><li>分析示意图</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%88%86%E6%9E%90Vue%E5%92%8CVueComponent%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><h3 id="2-3-单文件组件"><a href="#2-3-单文件组件" class="headerlink" title="2.3 单文件组件"></a>2.3 单文件组件</h3><ol><li><p><code>xxx.vue</code>文件 &#x3D;&gt; 内部书写组件 </p><ol><li><code>template</code> &#x3D;&gt; 组件的结构</li><li><code>script</code> &#x3D;&gt; 组件相关交互的代码</li><li><code>style</code> &#x3D;&gt; 组件的样式</li></ol></li><li><p>代码示例 （练习下格式  没有脚手架，不能运行）</p><p><strong>School.vue</strong></p><pre><code class="vue">&lt;template&gt;    &lt;!-- 组件的结构 --&gt;    &lt;div class=&quot;demo&quot;&gt;        &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;        &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    //组件相关交互的代码    export default &#123;        name:&#39;School&#39;,        data()&#123;            return &#123;                name:&#39;hhu&#39;,                address:&#39;江苏&#39;            &#125;        &#125;,        methods: &#123;            showName()&#123;                alert(this.name)            &#125;        &#125;,    &#125;&lt;/script&gt;&lt;style&gt;    /*  组件的样式  */    .demo&#123;        background-color: orange;    &#125;&lt;/style&gt;</code></pre><p><strong>Student.vue</strong></p><pre><code class="vue">&lt;template&gt;    &lt;div&gt;        &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#39;Student&#39;,        data()&#123;            return &#123;                name:&#39;jack&#39;,                age:18            &#125;        &#125;,    &#125;&lt;/script&gt;</code></pre><p><strong>App.vue</strong></p><pre><code class="vue">&lt;template&gt;    &lt;div&gt;        &lt;School&gt;&lt;/School&gt;        &lt;Student&gt;&lt;/Student&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    // 引入组件    import School from &#39;./School&#39;    import Student from &#39;./Student&#39;export default &#123;    name:&#39;App&#39;,    components:&#123;        School,        Student    &#125;&#125;&lt;/script&gt;</code></pre><p><strong>main.js</strong></p><pre><code class="js">import App from &#39;./App.vue&#39;new Vue(&#123;    el:&#39;#root&#39;,    template:`&lt;App&gt;&lt;/App&gt;`,    components:&#123;App&#125;&#125;)</code></pre><p><strong>index.html</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;练习单文件组件的语法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;    &lt;/div&gt;    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><h2 id="3-使用Vue脚手架"><a href="#3-使用Vue脚手架" class="headerlink" title="3 使用Vue脚手架"></a>3 使用Vue脚手架</h2><h3 id="3-1-初始化脚手架"><a href="#3-1-初始化脚手架" class="headerlink" title="3.1 初始化脚手架"></a>3.1 初始化脚手架</h3><h4 id="3-1-1-说明"><a href="#3-1-1-说明" class="headerlink" title="3.1.1 说明"></a>3.1.1 说明</h4><ol><li>Vue脚手架是Vue官方提供的标准化开发工具（开发平台）</li><li>最新的版本是4.x</li><li>文档地址：<a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></li></ol><h4 id="3-1-2-具体步骤"><a href="#3-1-2-具体步骤" class="headerlink" title="3.1.2 具体步骤"></a>3.1.2 具体步骤</h4><ul><li>官方文档：<a href="https://cli.vuejs.org/zh/">Home | Vue CLI (vuejs.org)</a></li></ul><ol><li><p>安装&#x3D;&#x3D;nodejs&#x3D;&#x3D; 环境</p><p>参考文档：<a href="https://www.cnblogs.com/netcore5/p/15259499.html">https://www.cnblogs.com/netcore5/p/15259499.html</a></p></li><li><p>（仅第一次执行）：全局安装<code>@vue/cli</code></p><pre><code class="sh">npm install -g @vue/cli# ORyarn global add @vue/cli</code></pre></li><li><p><strong>切换到要创建项目的目录</strong>，执行命令</p><pre><code class="sh">vue create my-project# ORvue ui</code></pre></li></ol><ul><li><p>示意图</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAvue%E9%A1%B9%E7%9B%AE.png"></p></li><li><p>备注</p><ul><li><p>创建项目过程如果报错，使用管理员权限打开<code>cmd</code></p></li><li><p>运行过程出现名称错误</p><ul><li>解决方案一： <code>ctrl + p</code> &#x3D;&gt; <code>vue.config.js</code> &#x3D;&gt; 添加配置 <code>lintOnSave:false</code></li></ul></li><li><p>Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，执行</p><pre><code class="sh">vue inspect &gt; output.js</code></pre></li></ul></li></ul><h4 id="3-1-3-脚手架文件结构"><a href="#3-1-3-脚手架文件结构" class="headerlink" title="3.1.3 脚手架文件结构"></a>3.1.3 脚手架文件结构</h4><pre><code>├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><h4 id="3-1-4-render-函数"><a href="#3-1-4-render-函数" class="headerlink" title="3.1.4 render()函数"></a>3.1.4 render()函数</h4><p><em>特殊的函数</em></p><p>关于不同版本的Vue</p><ol><li><p><code>vue.js</code>与<code>vue.runtime.xxx.js</code>的区别：</p><ol><li><p><code>vue.js</code>是完整版的Vue，包含：<strong>核心功能</strong>+<strong>模板解析器</strong></p></li><li><p><code>vue.runtime.xxx.js</code>是运行版的Vue，<strong>只</strong>包含：核心功能；没有模板解析器</p></li></ol></li><li><p>因为<code>vue.runtime.xxx.js</code>没有模板解析器，所以不能使用template配置项，需要使用</p></li></ol><p>​      <code>render</code>函数接收到的<code>createElement</code>函数去指定具体内容</p><h4 id="3-1-5-脚手架默认配置"><a href="#3-1-5-脚手架默认配置" class="headerlink" title="3.1.5 脚手架默认配置"></a>3.1.5 脚手架默认配置</h4><ul><li><p>官方文档：<a href="https://cli.vuejs.org/zh/config/">配置参考 | Vue CLI (vuejs.org)</a></p></li><li><p>查看Vue脚手架默认配置</p><pre><code class="sh">vue inspect &gt; output.js</code></pre></li></ul><h3 id="3-2-ref-和-props"><a href="#3-2-ref-和-props" class="headerlink" title="3.2 ref 和 props"></a>3.2 ref 和 props</h3><h4 id="3-2-1-ref属性"><a href="#3-2-1-ref属性" class="headerlink" title="3.2.1 ref属性"></a>3.2.1 ref属性</h4><ol><li><p>作用：给元素或者子组件注册引用信息（id的替代）</p></li><li><p>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象</p></li><li><p>使用方式</p><ol><li>标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;...&lt;/h1&gt;</code>或者<code>&lt;School ref=&quot;xxx&gt;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ol></li></ol><h4 id="3-2-2-props配置项"><a href="#3-2-2-props配置项" class="headerlink" title="3.2.2 props配置项"></a>3.2.2 props配置项</h4><ol><li><p>作用：让组件接收外部传入的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;XXX&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>方式一（只接收）：<code>props:[&#39;name&#39;]</code></p></li><li><p>方式二（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>方式三（限制类型、限制必要性、指定默认值）：</p><pre><code class="js">props:&#123;    name:&#123;        type:String, //类型        required:true, //必要性        default:&#39;老王&#39; //默认值        &#125;&#125;</code></pre></li></ol><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据</p></blockquote></li></ol><h3 id="3-3-mixin（混入）"><a href="#3-3-mixin（混入）" class="headerlink" title="3.3 mixin（混入）"></a>3.3 mixin（混入）</h3><ol><li><p>作用：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：<em>需要导出和引入</em></p><ol><li><p>定义混合</p><pre><code class="js">&#123;    data()&#123;...&#125;,    methods:&#123;...&#125;    ...&#125;</code></pre></li><li><p>使用混入</p><ol><li>全局混入：<code>Vue.mixin(XXX)</code></li><li>局部混入：<code>mixins:[&#39;XXX&#39;]</code></li></ol></li></ol></li></ol><h3 id="3-4-插件"><a href="#3-4-插件" class="headerlink" title="3.4 插件"></a>3.4 插件</h3><ol><li><p>作用：增强Vue</p></li><li><p>本质：包含<code>install()</code> 方法的一个对象，<code>install</code>的第一个参数是Vue原型对象，第二个以后的参数是插件使用者传递的数据</p></li><li><p>定义插件</p><pre><code class="js">对象.install = function(Vue,options) &#123;    // 1.添加全局过滤器    Vue.filter(...)                   // 2.添加全局指令    Vue.directive(...)        // 3.配置全局混入    Vue.mixin(....)        // 4.添加实例方法    Vue.prototype.$myMethod = function()&#123;...&#125;    Vue.prototype.$myProperty = xxx&#125;</code></pre></li><li><p>使用插件：<code>Vue.use(..)</code></p></li></ol><h3 id="3-5-scoped样式"><a href="#3-5-scoped样式" class="headerlink" title="3.5 scoped样式"></a>3.5 scoped样式</h3><ol><li>作用：让样式在局部生效，防止冲突</li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><hr><h3 id="总结TODOList案例"><a href="#总结TODOList案例" class="headerlink" title="总结TODOList案例"></a>总结TODOList案例</h3><ol><li><p>组件化编码流程：</p></li><li><p>拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p></li><li><p>实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p></li><li><p>一个组件在用：放在组件自身即可</p></li><li><p>一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）</p></li><li><p>实现交互：从绑定事件开始</p></li><li><p>props适用于：</p><ol><li>父组件 &#x3D;&#x3D;&gt; 子组件 通信</li><li>子组件 &#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）</li></ol></li><li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p></li><li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p></li></ol><hr><h3 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h3><ol><li>存储内容大小一般支持5MB左右（依照浏览器）</li><li>浏览器端通过<code>Window.sessionStorage</code>和<code>window.localStorage</code>属性来实现本地存储机制</li><li>相关API<ol><li><code>xxxStorage.setItem(&#39;key&#39;,&#39;value&#39;)</code> &#x3D;&gt; 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值</li><li><code>xxxStorage.getItem(&#39;key&#39;)</code> &#x3D;&gt; 该方法接受一个键名作为参数，返回键名对应的值</li><li><code>xxxStorage.removeItem(&#39;key&#39;)</code> &#x3D;&gt; 该方法接受一个键名作为参数，并把该键名从存储中删除</li><li><code>xxxStorage.clear()</code> &#x3D;&gt; 该方法会清空存储中的所有数据</li></ol></li><li>备注<ol><li>SessionStorage存储的内容会随着浏览器窗口关闭而消失</li><li>LocalStorage的存储的内容需要手动清除才会消失</li><li><code>xxxStorage.getItem(&#39;key&#39;)</code>如果key对应的Value获取不到，则此方法的返回值为null</li><li><code>Json.parse(null)</code>的结果依然是null</li></ol></li></ol><hr><h3 id="3-6-组件的自定义事件"><a href="#3-6-组件的自定义事件" class="headerlink" title="3.6 组件的自定义事件"></a>3.6 组件的自定义事件</h3><ol><li><p>一种组件间的通信方式，适用于: <strong style="color:red">子组件&#x3D;&#x3D;&#x3D;&gt;父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）</p></li><li><p>绑定自定义事件</p><ol><li><p>方式一：在父组件中：<code>&lt;Demo @mystyle=&quot;test&quot;/&gt;</code> 或者 <code>&lt;Demo v-on:mystyle=&quot;test&quot;/&gt;</code></p></li><li><p>方式二：在父组件中：</p><pre><code class="js">&lt;Demo ref=&quot;demo&quot;/&gt;.......mounted()&#123;    this.$refs.xxx.$on(&#39;mystyle&#39;,this.test)&#125;</code></pre></li><li><p>​若想让自定义事件只触发一次，可以使用<code>once</code>修饰符或者<code>$once</code>方法</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;mystyle&#39;,数据)</code></p></li><li><p>解绑自定义事件：<code>this.$off(&#39;mystyle&#39;)</code></p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;mystyle&#39;,回调)</code>绑定自定义事件时，<strong>回调</strong><span style="color:red">要么配置在methods中，要么用箭头函数</span>，否则this指向会有问题</p></li></ol><h3 id="3-7-全局事件总线-GlobalEventBus"><a href="#3-7-全局事件总线-GlobalEventBus" class="headerlink" title="3.7 全局事件总线(GlobalEventBus)"></a>3.7 全局事件总线(GlobalEventBus)</h3><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间的通信</span></p></li><li><p>安装全局事件总线</p><pre><code class="js">new Vue(&#123;    ......    beforeCreate()&#123;        Vue.prototype.$bus = this // 安装全局事件总线，$bus就是当前应用的vm    &#125;,    .....&#125;)</code></pre></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想要接收数据，则在A组件中给<code>$bus</code>绑定自定义事件，事件的<span style="color:red">回调留在A组件自身</span></p><pre><code class="js">methods:&#123;    demo(data) &#123;.......&#125;,    .......    mounted()&#123;        this.$bus.$on(&#39;xxx&#39;,this.demo)    &#125;&#125;</code></pre></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxx&#39;,数据)</code></p></li></ol></li><li><p>注意事项</p><ol><li>最好在<code>beforeDestroy</code>钩子中，用<code>$off</code>去解绑<span style="color:red">当前组件所用到的</span>事件</li></ol></li></ol><hr><h3 id="消息订阅与发布（pubsub"><a href="#消息订阅与发布（pubsub" class="headerlink" title="消息订阅与发布（pubsub)"></a>消息订阅与发布（pubsub)</h3><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间的通信</span></p></li><li><p>使用步骤</p><ol><li><p>安装pubsub:<code>npm i pubsub-js</code></p></li><li><p>引入： <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想要接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A中</span></p><pre><code class="js">methods:&#123;    demo(data) &#123;......&#125;&#125;......mounted()&#123;    this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo)&#125;</code></pre></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>注意事项</p><ol><li>最好在<code>beforeDestroy</code>钩子中，用<code>pubsub.unsubscribe(pid)</code>去<span style="color:red">取消订阅</span></li></ol></li></ol></li></ol><hr><h3 id="3-8-nextTick"><a href="#3-8-nextTick" class="headerlink" title="3.8 nextTick"></a>3.8 nextTick</h3><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次DOM更新结束后执行其制定的回调</li><li>使用时机：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行</li></ol><h3 id="3-9-Vue封装的过渡和动画"><a href="#3-9-Vue封装的过渡和动画" class="headerlink" title="3.9 Vue封装的过渡和动画"></a>3.9 Vue封装的过渡和动画</h3><ol><li><p>作用：在插入、更新或者移除DOM元素时，在合适的时候给元素添加样式类名</p></li><li><p>图示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Vue%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB.png"></p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式<ol><li><code>v-enter</code>:进入的起点</li><li><code>v-enter-active</code>:进入过程中</li><li><code>v-enter-to</code>:进入的终点</li></ol></li><li>元素离开的样式<ol><li><code>v-leave</code>:离开的起点</li><li><code>v-leave-active</code>:离开过程中</li><li><code>v-leave-to</code>:离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过渡的元素，并配置name属性</p><pre><code class="html">&lt;transition name=&quot;hello&quot;&gt;    &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;&lt;/transition&gt;</code></pre></li><li><p>备注：若有多个元素需要过渡，则需要使用:<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值</p></li></ol></li></ol><h2 id="4-Vue中的Ajax"><a href="#4-Vue中的Ajax" class="headerlink" title="4 Vue中的Ajax"></a>4 Vue中的Ajax</h2><h3 id="4-1-Vue脚手架配置代理-x3D-gt-解决跨域问题"><a href="#4-1-Vue脚手架配置代理-x3D-gt-解决跨域问题" class="headerlink" title="4.1 Vue脚手架配置代理 &#x3D;&gt; 解决跨域问题"></a>4.1 Vue脚手架配置代理 &#x3D;&gt; 解决跨域问题</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>​在<code>vue.config.js</code>中添加如下配置</p><pre><code class="js">devServer:&#123;  proxy:&quot;http://localhost:5000&quot;&#125;</code></pre><p>说明：</p><ul><li>优点：配置简单，请求资源时直接发送给前端即可</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配服务器）</li></ul><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>​编写<code>vue.config.js</code>配置具体代理规则</p><pre><code class="js">module.exports = &#123;    devServer: &#123;      proxy: &#123;      &#39;/api1&#39;: &#123;// 匹配所有以 &#39;/api1&#39;开头的请求路径        target: &#39;http://localhost:port&#39;,// 代理目标的基础路径        changeOrigin: true,        pathRewrite: &#123;&#39;^/api1&#39;: &#39;&#39;&#125;      &#125;,      &#39;/api2&#39;: &#123;// 匹配所有以 &#39;/api2&#39;开头的请求路径        target: &#39;http://localhost:port&#39;,// 代理目标的基础路径        changeOrigin: true,        pathRewrite: &#123;&#39;^/api2&#39;: &#39;&#39;&#125;      &#125;    &#125;  &#125;&#125;/*   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080   changeOrigin默认值为true*/</code></pre><p>说明：</p><ul><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理</li><li>缺点：配置略微繁琐，请求资源时必须加前缀</li></ul><p>###4.2 slot插槽</p><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于<strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong></p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><pre><code class="html">&lt;!-- 父组件中 --&gt;        &lt;Category&gt;           &lt;div&gt;html结构1&lt;/div&gt;        &lt;/Category&gt;&lt;!-- 子组件中 --&gt;         &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;</code></pre></li><li><p>具名插槽</p><pre><code class="html">&lt;!-- 父组件中 --&gt;        &lt;Category&gt;            &lt;template slot=&quot;center&quot;&gt;              &lt;div&gt;html结构1&lt;/div&gt;            &lt;/template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;&lt;!-- 子组件中 --&gt;        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;</code></pre></li><li><p>作用域插槽</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定</span>(game数据在Category组件中，但使用数据所遍历出来的结构有App组件决定)</p></li><li><p>具体编码</p><pre><code class="html">&lt;!-- 父组件中 --&gt;        &lt;Category&gt;            &lt;template scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是ul列表 --&gt;                &lt;ul&gt;                    &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;template slot-scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是h4标题 --&gt;                &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;            &lt;/template&gt;        &lt;/Category&gt;&lt;!-- 子组件中 --&gt;        &lt;template&gt;            &lt;div&gt;                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;                &lt;script&gt;            export default &#123;                name:&#39;Category&#39;,                props:[&#39;title&#39;],                //数据在子组件自身                data() &#123;                    return &#123;                        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;]                    &#125;                &#125;,            &#125;        &lt;/script&gt;</code></pre></li></ol></li></ol></li></ol><h2 id="5-Vuex"><a href="#5-Vuex" class="headerlink" title="5 Vuex"></a>5 Vuex</h2><h3 id="5-1-Vuex理解"><a href="#5-1-Vuex理解" class="headerlink" title="5.1 Vuex理解"></a>5.1 Vuex理解</h3><ol><li><p>是什么？专门在 Vue 中实现集中式状态（数据）管理的一个 Vue <strong>插件</strong>，对 vue 应 用中多个组件的<strong>共享</strong>状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方 式，且适用于任意组件间通信</p></li><li><p>工作原理图</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Vuex%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p></li></ol><h3 id="5-2-搭建Vuex环境"><a href="#5-2-搭建Vuex环境" class="headerlink" title="5.2 搭建Vuex环境"></a>5.2 搭建Vuex环境</h3><ol><li><p>安装Vuex</p><ol><li><p>Vue2 &#x3D;&gt; Vuex3 版本</p><pre><code class="sh">npm i vuex@3</code></pre></li></ol></li><li><p>创建文件：<code>src/store/index.js</code></p><pre><code class="js">// 引入Vue核心import Vue from &#39;Vue&#39;// 引入Vueximport Vuex from &#39;vuex&#39;// 应用Vuex插件Vue.use(Vuex)// 准备actions对象 =&gt; 响应组件中用户的动作const actions = &#123;&#125;// 准备mutations对象 =&gt; 修改state中的数据const mutations = &#123;&#125;// 准备state对象 =&gt; 保存具体的数据const state = &#123;&#125;// 创建并暴露storeexport default new Vuex.Store(&#123;    actions,    mutations,    state&#125;)</code></pre></li><li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p><pre><code class="js">.......// 引入storeimport store from &#39;./store&#39;.......// 创建vmnew Vue(&#123;  render: h =&gt; h(App),  store&#125;).$mount(&#39;#app&#39;)</code></pre></li></ol><h3 id="5-3-基本使用"><a href="#5-3-基本使用" class="headerlink" title="5.3 基本使用"></a>5.3 基本使用</h3><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>、操作文件<code>store.js</code></p><pre><code class="js">//引入Vue核心库import Vue from &#39;vue&#39;//引入Vueximport Vuex from &#39;vuex&#39;//引用VuexVue.use(Vuex)const actions = &#123;    //响应组件中加的动作    jia(context,value)&#123;        // console.log(&#39;actions中的jia被调用了&#39;,miniStore,value)        context.commit(&#39;JIA&#39;,value)    &#125;,&#125;const mutations = &#123;    //执行加    JIA(state,value)&#123;        // console.log(&#39;mutations中的JIA被调用了&#39;,state,value)        state.sum += value    &#125;&#125;//初始化数据const state = &#123;   sum:0&#125;//创建并暴露storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,&#125;)</code></pre></li><li><p>组件中读取vuex中的数据：<code>$store.state.xxx</code></p></li><li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;actions中的方法名&#39;,数据)</code>或者<code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p>备注：若没有网络请求或者其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h3 id="5-4-getters的使用"><a href="#5-4-getters的使用" class="headerlink" title="5.4 getters的使用"></a>5.4 getters的使用</h3><ol><li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><pre><code class="js">......const getters = &#123;    bigSum(state)&#123;        return state.sum * 10    &#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;    ......    getters&#125;)</code></pre></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h3 id="5-5-map方法使用"><a href="#5-5-map方法使用" class="headerlink" title="5.5 map方法使用"></a>5.5 map方法使用</h3><ol><li><p><strong>mapState方法</strong>  &#x3D;&gt; 用于帮助我们映射<code>state</code>中的数据为计算属性</p><pre><code class="js">computed: &#123;    //借助mapState生成计算属性：sum、school、subject（对象写法）     ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),             //借助mapState生成计算属性：sum、school、subject（数组写法）    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),&#125;,</code></pre></li><li><p><strong>mapGetters方法</strong> &#x3D;&gt; 用于帮助我们映射<code>getters</code>中的数据为计算属性</p><pre><code class="js">computed: &#123;    //借助mapGetters生成计算属性：bigSum（对象写法）    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),    //借助mapGetters生成计算属性：bigSum（数组写法）    ...mapGetters([&#39;bigSum&#39;])&#125;,</code></pre></li><li><p><strong>mapActions方法</strong> &#x3D;&gt; 用于帮助我们生成与<code>actions</code>对话的方法，即包含<code>$state.dispatch(xxx)的函数</code></p><pre><code class="js">methods:&#123;    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])&#125;</code></pre></li><li><p><strong>mapMutations方法</strong> &#x3D;&gt; 用于帮助我们生成与<code>mutations</code>对话的方法，即包含<code>$state.commit(xxx)的函数</code></p><pre><code class="js">methods:&#123;    //靠mapActions生成：increment、decrement（对象形式）    ...mapMutations(&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),        //靠mapMutations生成：JIA、JIAN（对象形式）    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),&#125;</code></pre></li></ol><blockquote><p>备注：mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象</p></blockquote><h3 id="5-6-模块化-命名空间"><a href="#5-6-模块化-命名空间" class="headerlink" title="5.6 模块化 + 命名空间"></a>5.6 模块化 + 命名空间</h3><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确</p></li><li><p>修改<code>store.js</code></p><pre><code class="js">const countAbout = &#123;  namespaced:true,//开启命名空间  state:&#123;x:1&#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123;    bigSum(state)&#123;       return state.sum * 10    &#125;  &#125;&#125;const personAbout = &#123;  namespaced:true,//开启命名空间  state:&#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    countAbout,    personAbout  &#125;&#125;)</code></pre></li><li><p>开启命名空间后，组件中读取<code>state</code>数据</p><pre><code class="js">//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),</code></pre></li><li><p>开启命名空间后，组件中读取<code>getters</code>数据</p><pre><code class="js">//方式一：自己直接读取this.$store.getters[&#39;personAbout/firstPersonName&#39;]//方式二：借助mapGetters读取：...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])</code></pre></li><li><p>开启命名空间后，组件中调用<code>dispatch</code></p><pre><code class="js">//方式一：自己直接dispatchthis.$store.dispatch(&#39;personAbout/addPersonWang&#39;,person)//方式二：借助mapActions：...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)</code></pre></li><li><p>开启命名空间后，组件中调用<code>commit</code></p><pre><code class="js">//方式一：自己直接committhis.$store.commit(&#39;personAbout/ADD_PERSON&#39;,person)//方式二：借助mapMutations：...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),</code></pre></li></ol><h2 id="6-vue-router"><a href="#6-vue-router" class="headerlink" title="6 vue-router"></a>6 vue-router</h2><ol><li><p>理解：一个路由(route)就是一组映射关系(key - value)，多个路由需要路由器(router)进行管理</p></li><li><p>前端路由：key是路径，value是组件</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%90%86%E8%A7%A3%E6%A1%88%E4%BE%8B.png"></p></li></ol><h3 id="6-1-基本使用"><a href="#6-1-基本使用" class="headerlink" title="6.1 基本使用"></a>6.1 基本使用</h3><ol><li><p>安装vue-router（Vue2 &#x3D;&gt; vue-router3)</p><pre><code class="sh">npm i vue-router@3</code></pre></li><li><p>应用插件：<code>Vue.user(VueRouter)</code></p></li><li><p>编写router配置项:<code>src/router/index.js</code></p><pre><code class="js">// 专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;// 引入组件import About from &#39;@/components/About&#39;import Home from &#39;@/components/Home&#39;// 创建并暴露路由export default new VueRouter(&#123;    routes:[        &#123;            path:&#39;/about&#39;,            component:About        &#125;,        &#123;            path:&#39;/home&#39;,            component:Home        &#125;    ]&#125;)</code></pre></li><li><p>实现切换(<code>active-class</code>可以配置高亮样式)</p><pre><code class="vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</code></pre></li><li><p>指定展示位置</p><pre><code class="vue">&lt;router-view&gt;&lt;/router-view&gt;</code></pre></li></ol><h3 id="6-2-注意事项"><a href="#6-2-注意事项" class="headerlink" title="6.2 注意事项"></a>6.2 注意事项</h3><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到</li></ol><h3 id="6-3-多级路由（嵌套路由）"><a href="#6-3-多级路由（嵌套路由）" class="headerlink" title="6.3 多级路由（嵌套路由）"></a>6.3 多级路由（嵌套路由）</h3><ol><li><p>配置路由规则，使用<code>children</code>配置项</p><pre><code class="js">routes:[        &#123;            path:&#39;/about&#39;,            component:About        &#125;,        &#123;            path:&#39;/home&#39;,            component:Home,            children:[                &#123;                    path:&#39;news&#39;,                    component:News                &#125;,                &#123;                    path:&#39;message&#39;,                    component:Message                &#125;            ]        &#125;    ]</code></pre></li><li><p>跳转（<strong>完整路径</strong>）</p><pre><code class="vue">&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</code></pre></li></ol><h3 id="6-4-路由的query参数"><a href="#6-4-路由的query参数" class="headerlink" title="6.4 路由的query参数"></a>6.4 路由的query参数</h3><ol><li><p>传递参数</p><pre><code class="Vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;                &lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link     :to=&quot;&#123;        path:&#39;/home/message/detail&#39;,        query:&#123;           id:666,            title:&#39;你好&#39;        &#125;    &#125;&quot;&gt;跳转&lt;/router-link&gt;</code></pre></li><li><p>接收参数</p><pre><code class="js">$route.query.id$route.query.title</code></pre></li></ol><h3 id="6-5-命名路由"><a href="#6-5-命名路由" class="headerlink" title="6.5 命名路由"></a>6.5 命名路由</h3><ol><li><p>作用：可以简化路由的跳转</p></li><li><p>使用方法：</p><ol><li><p>给路由命名</p><pre><code class="js">&#123;    path:&#39;/demo&#39;,    component:Demo,    children:[        &#123;            path:&#39;test&#39;,            component:Test,            children:[                &#123;                      name:&#39;hello&#39; //给路由命名                    path:&#39;welcome&#39;,                    component:Hello,                &#125;            ]        &#125;    ]&#125;</code></pre></li><li><p>简化跳转</p><pre><code class="vue">&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link     :to=&quot;&#123;        name:&#39;hello&#39;,        query:&#123;           id:666,            title:&#39;你好&#39;        &#125;    &#125;&quot;&gt;跳转&lt;/router-link&gt;</code></pre></li></ol></li></ol><h3 id="6-6-路由的params参数"><a href="#6-6-路由的params参数" class="headerlink" title="6.6 路由的params参数"></a>6.6 路由的params参数</h3><ol><li><p>配置路由，声明接收<code>params</code>参数</p><pre><code class="js">&#123;    path:&#39;/home&#39;,    component:Home,    children:[        &#123;            path:&#39;news&#39;,            component:News        &#125;,        &#123;            component:Message,            children:[                &#123;                    name:&#39;xiangqing&#39;,                    path:&#39;detail/:id/:title&#39;, //使用占位符声明接收params参数                    component:Detail                &#125;            ]        &#125;    ]&#125;</code></pre></li><li><p>传递参数</p><pre><code class="vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;                &lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link     :to=&quot;&#123;        name:&#39;xiangqing&#39;,        params:&#123;           id:666,            title:&#39;你好&#39;        &#125;    &#125;&quot;&gt;跳转&lt;/router-link&gt;</code></pre></li></ol><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p></blockquote><ol start="3"><li><p>接收参数</p><pre><code class="js">$route.params.id$route.params.title</code></pre></li></ol><h3 id="6-7-路由的props参数"><a href="#6-7-路由的props参数" class="headerlink" title="6.7 路由的props参数"></a>6.7 路由的props参数</h3><ul><li><p>作用：让路由组件更方便的接收参数</p><pre><code class="js">&#123;    name:&#39;xiangqing&#39;,    path:&#39;detail/:id&#39;,    component:Detail,    //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件    // props:&#123;a:900&#125;    //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件    // props:true        //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件    props(route)&#123;        return &#123;            id:route.query.id,            title:route.query.title        &#125;    &#125;&#125;</code></pre></li></ul><h3 id="6-8-lt-router-link-gt-的replace属性"><a href="#6-8-lt-router-link-gt-的replace属性" class="headerlink" title="6.8 &lt;router-link&gt;的replace属性"></a>6.8 <code>&lt;router-link&gt;</code>的replace属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录的写入模式：<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录，路由跳转时候默认是<code>push</code></li><li>开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="6-9-编程式路由导航"><a href="#6-9-编程式路由导航" class="headerlink" title="6.9 编程式路由导航"></a>6.9 编程式路由导航</h3><ol><li><p>作用：不借助<code>&lt;router-link&gt;</code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>代码示例</p><pre><code class="js">//$router的两个APIthis.$router.push(&#123;    name:&#39;xiangqing&#39;,        params:&#123;            id:xxx,            title:xxx        &#125;&#125;)this.$router.replace(&#123;    name:&#39;xiangqing&#39;,        params:&#123;            id:xxx,            title:xxx        &#125;&#125;)this.$router.forward() //前进this.$router.back() //后退this.$router.go() //可前进也可后退(传入正数前进，负数后退)</code></pre></li></ol><h3 id="6-10-缓存路由组件"><a href="#6-10-缓存路由组件" class="headerlink" title="6.10 缓存路由组件"></a>6.10 缓存路由组件</h3><ol><li><p>组件：让不展示的路由组件保持挂载，不被销毁(在展示组件的地方挂载)</p></li><li><p>代码示例</p><pre><code class="vue">&lt;keep-alive include=&quot;News&quot;&gt;       &lt;!--         缓存多个        &lt;keep-alive :include=&quot;[&#39;News&#39;,&#39;Message&#39;]&quot;&gt;--&gt;     &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;</code></pre><p><strong>include</strong> &#x3D;&gt; 组件名</p></li></ol><h3 id="6-11-两个新的生命周期钩子"><a href="#6-11-两个新的生命周期钩子" class="headerlink" title="6.11 两个新的生命周期钩子"></a>6.11 两个新的生命周期钩子</h3><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态</li><li>具体名字：<ol><li><code>activated</code> &#x3D;&gt; 路由组件被激活时触发</li><li><code>deactivated</code> &#x3D;&gt; 路由组件失活时触发</li></ol></li></ol><h3 id="6-12-路由守卫"><a href="#6-12-路由守卫" class="headerlink" title="6.12 路由守卫"></a>6.12 路由守卫</h3><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类</p><ul><li>全局守卫</li><li>独享守卫</li><li>组件内守卫</li></ul></li><li><p>代码示例</p><ul><li><p>全局守卫</p><pre><code class="js">//全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach((to,from,next)=&gt;&#123;    console.log(&#39;beforeEach&#39;,to,from)    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123; //权限控制的具体规则            next() //放行        &#125;else&#123;            alert(&#39;暂无权限查看&#39;)            // next(&#123;name:&#39;guanyu&#39;&#125;)        &#125;    &#125;else&#123;        next() //放行    &#125;&#125;)//全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&gt;&#123;    console.log(&#39;afterEach&#39;,to,from)    if(to.meta.title)&#123;         document.title = to.meta.title //修改网页的title    &#125;else&#123;        document.title = &#39;vue_test&#39;    &#125;&#125;)</code></pre></li><li><p>独享守卫</p><pre><code class="js">beforeEnter(to,from,next)&#123;    console.log(&#39;beforeEnter&#39;,to,from)    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123;            next()        &#125;else&#123;            alert(&#39;暂无权限查看&#39;)            // next(&#123;name:&#39;guanyu&#39;&#125;)        &#125;    &#125;else&#123;        next()    &#125;&#125;</code></pre></li><li><p>组件内守卫</p><pre><code class="js">//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125;</code></pre></li></ul><h3 id="6-13-路由器的两种工作方式"><a href="#6-13-路由器的两种工作方式" class="headerlink" title="6.13 路由器的两种工作方式"></a>6.13 路由器的两种工作方式</h3></li><li><p>对于一个<code>url</code>，<code>hash</code> &#x3D;&gt; #及其之后的内容</p></li><li><p><code>hash</code>值不会包含在HTTP请求中，即<code>hash</code>值不会带给服务器</p></li><li><p><code>hash</code>模式：</p><ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li><p><code>history</code>模式：</p><ol><li>地址干净，美观 。</li><li>兼容性和<code>hash</code>模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li><li><p>开启方式：创建路由器时配置</p><pre><code class="vue">mode:&#39;history&#39;mode:&#39;hash&#39;</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记</title>
      <link href="/2022/11/24/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/24/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis学习笔记"><a href="#Redis学习笔记" class="headerlink" title="Redis学习笔记"></a>Redis学习笔记</h1><h2 id="1-Redis简介"><a href="#1-Redis简介" class="headerlink" title="1.Redis简介"></a>1.Redis简介</h2><p>Redis是一种<strong>键值型</strong>的<strong>NoSql</strong>数据库，关键字：</p><ul><li>键值型 &#x3D;&gt; Redis中存储的数据是以<code>key-value</code>对形式存储，value形式可以是字符串、数值、json……</li><li>NoSql &#x3D;&gt; 对于存储的数据，没有类似MySQL那样严格的约束，结构较松散</li></ul><span id="more"></span><h2 id="2-Redis初识"><a href="#2-Redis初识" class="headerlink" title="2.Redis初识"></a>2.Redis初识</h2><h3 id="2-1-NoSql"><a href="#2-1-NoSql" class="headerlink" title="2.1 NoSql"></a>2.1 NoSql</h3><p><strong>NoSql</strong>（Not Only Sql &#x2F; No Sql)，相对于传统关系型数据库而言，有很大差异，因此也称为<strong>非关系型数据库</strong></p><h4 id="2-1-1-结构化和非结构化"><a href="#2-1-1-结构化和非结构化" class="headerlink" title="2.1.1 结构化和非结构化"></a>2.1.1 结构化和非结构化</h4><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息（字段名，字段数据类型，字段约束等），插入的数据必须遵守这些约束</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%BE%E7%A4%BA.png"></p><p>NoSql对于数据库格式没有严格约束，往往形式松散、自由</p><ul><li><p>键值型</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/NoSql%E9%94%AE%E5%80%BC%E5%9E%8B.png"></p></li><li><p>文档型</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/NoSql%E6%96%87%E6%A1%A3%E5%9E%8B.png"></p></li><li><p>图格式</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/NoSql%E5%9B%BE%E6%A0%BC%E5%BC%8F.png"></p></li></ul><h4 id="2-1-2-关联与非关联"><a href="#2-1-2-关联与非关联" class="headerlink" title="2.1.2 关联与非关联"></a>2.1.2 关联与非关联</h4><ul><li>传统数据库的表与表之间往往存在关联，比如外键</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E8%81%94%E6%A1%88%E4%BE%8B.png"></p><ul><li>非关系型数据库不存在关联关系，维护关系 &#x3D;&gt; 代码中的业务逻辑 Or 数据之间的耦合</li></ul><h4 id="2-1-3-查询方式"><a href="#2-1-3-查询方式" class="headerlink" title="2.1.3 查询方式"></a>2.1.3 查询方式</h4><ul><li><p>传统关系型数据库会基于Sql语句查询，语法有统一标准</p></li><li><p>不同非关系型数据库查询语法差异极大</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E6%9F%A5%E8%AF%A2%E5%B7%AE%E5%BC%82.png"></p></li></ul><h4 id="2-1-4-事务"><a href="#2-1-4-事务" class="headerlink" title="2.1.4 事务"></a>2.1.4 事务</h4><ul><li>传统关系型数据库能满足事务<strong>ACID</strong>原则<ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul></li><li>非关系型数据库往往不支持事务，或者不能严格保证ACID特性，只能实现基本的一致性</li></ul><h4 id="2-1-5-小结"><a href="#2-1-5-小结" class="headerlink" title="2.1.5 小结"></a>2.1.5 小结</h4><p>关系型数据库和非关系型数据库差异性除了上述四点，在存储方式、扩展性、查询性能上也有着显著差异</p><table><thead><tr><th></th><th align="center">SQL</th><th align="center">NoSQL</th></tr></thead><tbody><tr><td><strong>数据结构</strong></td><td align="center">结构化(Structured)</td><td align="center">非结构化</td></tr><tr><td>数据关联</td><td align="center">关联的(Relational)</td><td align="center">非关联的</td></tr><tr><td>查询方式</td><td align="center">SQL查询</td><td align="center">非SQL</td></tr><tr><td>事物特性</td><td align="center">ACID</td><td align="center">BASE</td></tr><tr><td>存储方式</td><td align="center">磁盘</td><td align="center">内存</td></tr><tr><td>扩展性</td><td align="center">垂直</td><td align="center">水平</td></tr><tr><td>使用场景</td><td align="center">数据结构固定，相关业务数据安全性、一致性要求较高</td><td align="center">数据结构不固定，对一致性、安全性要求不高，对性能要求</td></tr></tbody></table><ul><li>存储方式<ul><li>关系型数据库基于<strong>磁盘</strong>进行存储，会有大量的磁盘IO，对性能有一定的影响</li><li>非关系型数据库操作更多依赖于<strong>内存</strong>来操作，内存的读写速度非常快，由此性能好</li></ul></li><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用 &#x3D;&gt; <strong>垂直扩展</strong></li><li>费关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题 &#x3D;&gt; <strong>水平扩展</strong></li><li>关系型数据库因为表之间存在关联，做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h3 id="2-2-认识Redis"><a href="#2-2-认识Redis" class="headerlink" title="2.2 认识Redis"></a>2.2 认识Redis</h3><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库</p><p><strong>特征</strong></p><ul><li>键值型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟、速度快（基于内存、IO多路复用、良好的编码）</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><p>Redis官网网址：<a href="https://redis.io/">https://redis.io</a></p><h3 id="2-3-安装Redis"><a href="#2-3-安装Redis" class="headerlink" title="2.3 安装Redis"></a>2.3 安装Redis</h3><ul><li>操作系统：Linux （版本：CentOS 7）</li><li>虚拟机VMware</li><li>客户端 XShell7、Xftp7</li></ul><h4 id="2-3-1-安装依赖库"><a href="#2-3-1-安装依赖库" class="headerlink" title="2.3.1 安装依赖库"></a>2.3.1 安装依赖库</h4><p>Redis是基于C语言编写 &#x3D;&gt; 安装gcc依赖</p><pre><code class="sh">yum install -y gcc tcl</code></pre><h4 id="2-3-2-上传依赖包并解压"><a href="#2-3-2-上传依赖包并解压" class="headerlink" title="2.3.2 上传依赖包并解压"></a>2.3.2 上传依赖包并解压</h4><blockquote><p>版本：6.2.6</p><p>压缩包上传位置：&#x2F;usr&#x2F;local&#x2F;src</p></blockquote><ul><li>解压</li></ul><pre><code class="sh">tar -zxvf redis-6.2.6.tar.gz</code></pre><ul><li>进入redis目录</li></ul><pre><code class="sh">cd redis-6.2.6</code></pre><ul><li>运行编译命令</li></ul><pre><code class="sh">make &amp;&amp; make install</code></pre><blockquote><p>默认安装路径：&#x2F;usr&#x2F;local&#x2F;bin</p><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul></blockquote><h4 id="2-3-3-启动"><a href="#2-3-3-启动" class="headerlink" title="2.3.3 启动"></a>2.3.3 启动</h4><p>启动方式</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h4 id="2-3-4-默认启动"><a href="#2-3-4-默认启动" class="headerlink" title="2.3.4 默认启动"></a>2.3.4 默认启动</h4><p>安装完成后，在任意目录输入<code>redis-server</code>命令即可启动Redis</p><pre><code class="sh">redis-server</code></pre><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用</p><h4 id="2-3-5-指定配置启动"><a href="#2-3-5-指定配置启动" class="headerlink" title="2.3.5 指定配置启动"></a>2.3.5 指定配置启动</h4><p>要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫<code>redis.conf</code></p><blockquote><p>建议先将配置文件备份一份</p><pre><code class="sh">cp redis.conf redis.conf.bck</code></pre></blockquote><p>然后修改<code>redis-conf</code>文件中的一些配置</p><pre><code class="properties"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0bind 0.0.0.0# 守护进程，修改为yes后即可后台运行daemonize yes # 密码，设置后访问Redis必须输入密码requirepass 123321</code></pre><p>Redis的其他常见配置</p><pre><code class="properties"># 监听的端口port 6379# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志.持久化等文件会保存在这个目录dir .# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15databases 1# 设置redis能够使用的最大内存maxmemory 512mb# 日志文件，默认为空，不记录日志，可以指定日志文件名logfile &quot;redis.log&quot;</code></pre><p>启动Redis</p><pre><code class="sh"># 进入redis安装目录 cd /usr/local/src/redis-6.2.6# 启动redis-server redis.conf</code></pre><p>停止服务</p><pre><code class="sh"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -u 来指定密码redis-cli -u 123321 shutdown</code></pre><h4 id="2-3-6-开机自启"><a href="#2-3-6-开机自启" class="headerlink" title="2.3.6 开机自启"></a>2.3.6 开机自启</h4><p>新建系统服务文件</p><pre><code class="sh">vi /etc/systemd/system/redis.service</code></pre><p>文件内容</p><pre><code class="sh">[Unit]Description=redis-serverAfter=network.target[Service]Type=forking# 重点是ExecStart后面指定的路径ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target</code></pre><p>重载系统服务</p><pre><code class="sh">systemctl daemon-reload</code></pre><p>&#x3D;&gt; 以下命令可以操作redis</p><pre><code class="sh"># 启动systemctl start redis# 停止systemctl stop redis# 重启systemctl restart redis# 查看状态systemctl status redis</code></pre><p>开机自启</p><pre><code class="sh">systemctl enable redis</code></pre><h3 id="2-4-Redis桌面客户端"><a href="#2-4-Redis桌面客户端" class="headerlink" title="2.4 Redis桌面客户端"></a>2.4 Redis桌面客户端</h3><p>安装完成Redis，需要Redis的客户端进行数据的CRUD，客户端包括</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h4 id="2-4-1-Redis命令行客户端"><a href="#2-4-1-Redis命令行客户端" class="headerlink" title="2.4.1 Redis命令行客户端"></a>2.4.1 Redis命令行客户端</h4><p>Redis安装完成后自带命令行客户端：<code>redis-cli</code>，使用方式</p><pre><code class="sh">redis-cli [options] [commonds]</code></pre><p>常见的<code>options</code>:</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码 (自定)</li></ul><p><code>commonds</code>是Redis的操作命令，例如</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定<code>commonds</code>时，会进入<code>redis-cli</code>的交互控制台</p><h4 id="2-4-2-图形化桌面客户端"><a href="#2-4-2-图形化桌面客户端" class="headerlink" title="2.4.2 图形化桌面客户端"></a>2.4.2 图形化桌面客户端</h4><p>安装包地址：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><h2 id="3-Redis常见命令"><a href="#3-Redis常见命令" class="headerlink" title="3.Redis常见命令"></a>3.Redis常见命令</h2><h3 id="3-1-Redis数据结构"><a href="#3-1-Redis数据结构" class="headerlink" title="3.1 Redis数据结构"></a>3.1 Redis数据结构</h3><p>Redis是一个<code>key-value</code>的数据库，<code>key</code>一般是String类型，不过<code>value</code>的类型多种多样</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><blockquote><p>命令不用死记，学会查询</p><ul><li>官方文档： <a href="https://redis.io/commands">https://redis.io/commands</a></li><li><code>help</code>命令</li></ul></blockquote><h3 id="3-2-Redis通用命令"><a href="#3-2-Redis通用命令" class="headerlink" title="3.2 Redis通用命令"></a>3.2 Redis通用命令</h3><p>通用命令不区分数据类型 &#x3D;&gt; 都可以使用的指令，常见的有：</p><ul><li><code>KEYS</code>：查看符合模板的所有key</li><li><code>DEL</code>：删除一个指定的key</li><li><code>EXISTS</code>：判断key是否存在</li><li><code>EXPIRE</code>：给一个key设置有效期，有效期到期时该key会被自动删除</li><li><code>TTL</code>：查看一个KEY的剩余有效期</li></ul><blockquote><p>通过<code>help [command]</code>可以查看一个命令的具体用法，例如</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/help%E6%8C%87%E4%BB%A4%E6%A1%88%E4%BE%8B.png"></p></blockquote><p>指令案例</p><ul><li>KEYS</li></ul><pre><code class="sh">127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt;# 查询以a开头的key127.0.0.1:6379&gt; keys a*1) &quot;age&quot;127.0.0.1:6379&gt;</code></pre><blockquote><p><strong>tips：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不</strong></p></blockquote><ul><li>DEL</li></ul><pre><code class="sh">127.0.0.1:6379&gt; help del  DEL key [key ...]  summary: Delete a key  since: 1.0.0  group: generic127.0.0.1:6379&gt; del name #删除单个(integer) 1  #成功删除1个127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;4) &quot;age&quot;127.0.0.1:6379&gt; del k1 k2 k3 k4(integer) 3   #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回127.0.0.1:6379&gt;127.0.0.1:6379&gt; keys * #再查询全部的key1) &quot;age&quot;#只剩下一个了127.0.0.1:6379&gt;</code></pre><ul><li>EXISTS</li></ul><pre><code class="sh">127.0.0.1:6379&gt; help EXISTS  EXISTS key [key ...]  summary: Determine if a key exists  since: 1.0.0  group: generic127.0.0.1:6379&gt; exists age(integer) 1127.0.0.1:6379&gt; exists name(integer) 0</code></pre><ul><li>EXPIRE</li></ul><blockquote><p><strong>tips:内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~</strong></p></blockquote><pre><code class="sh">127.0.0.1:6379&gt; expire age 10(integer) 1127.0.0.1:6379&gt; ttl age(integer) 8127.0.0.1:6379&gt; ttl age(integer) 6127.0.0.1:6379&gt; ttl age(integer) -2127.0.0.1:6379&gt; ttl age(integer) -2  #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间OK127.0.0.1:6379&gt; ttl age(integer) -1  # ttl的返回值就是-1</code></pre><h3 id="3-3-Redis命令-String命令"><a href="#3-3-Redis命令-String命令" class="headerlink" title="3.3 Redis命令-String命令"></a>3.3 Redis命令-String命令</h3><p>String类型是Redis中最简单的存储类型，其value是字符串。根据句字符串格式的不同，可以分成3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">msg</td><td align="center">hello world</td></tr><tr><td align="center">num</td><td align="center">10</td></tr><tr><td align="center">score</td><td align="center">92.5</td></tr></tbody></table><p>String常见命令：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p>指令案例</p><ul><li>SET和GET：如果KEY不存在是新增，存在则是修改</li></ul><pre><code class="sh">127.0.0.1:6379&gt; set name Rose  #原来不存在OK127.0.0.1:6379&gt; get name &quot;Rose&quot;127.0.0.1:6379&gt; set name Jack #原来存在，就是修改OK127.0.0.1:6379&gt; get name&quot;Jack&quot;</code></pre><ul><li>MSET和MGET</li></ul><pre><code class="sh">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; MGET name age k1 k2 k31) &quot;Jack&quot; #之前存在的name2) &quot;10&quot;   #之前存在的age3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v3&quot;</code></pre><ul><li>INCR和INCRBY和DECY</li></ul><pre><code class="sh">127.0.0.1:6379&gt; get age &quot;10&quot;127.0.0.1:6379&gt; incr age #增加1(integer) 11    127.0.0.1:6379&gt; get age #获得age&quot;11&quot;127.0.0.1:6379&gt; incrby age 2 #一次增加2(integer) 13 //返回目前的age的值    127.0.0.1:6379&gt; incrby age 2(integer) 15    127.0.0.1:6379&gt; incrby age -1 #也可以增加负数，相当于减(integer) 14    127.0.0.1:6379&gt; incrby age -2 #一次减少2个(integer) 12    127.0.0.1:6379&gt; DECR age #相当于 incr 负数，减少正常用法(integer) 11    127.0.0.1:6379&gt; get age &quot;11&quot;</code></pre><ul><li>SETNX</li></ul><pre><code class="sh">127.0.0.1:6379&gt; help setnx  SETNX key value  summary: Set the value of a key, only if the key does not exist  since: 1.0.0  group: string127.0.0.1:6379&gt; set name Jack  #设置名称OK127.0.0.1:6379&gt; setnx name lisi #如果key不存在，则添加成功(integer) 0127.0.0.1:6379&gt; get name #由于name已经存在，所以lisi的操作失败&quot;Jack&quot;127.0.0.1:6379&gt; setnx name2 lisi #name2 不存在，所以操作成功(integer) 1127.0.0.1:6379&gt; get name2 &quot;lisi&quot;</code></pre><ul><li>SETNX</li></ul><pre><code class="sh">127.0.0.1:6379&gt; setex name 10 jackOK127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; ttl name(integer) 7127.0.0.1:6379&gt; ttl name(integer) 5</code></pre><h3 id="3-4-Redis命令-Key的层级结构"><a href="#3-4-Redis命令-Key的层级结构" class="headerlink" title="3.4 Redis命令-Key的层级结构"></a>3.4 Redis命令-Key的层级结构</h3><p>Redis的Key允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Key%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%BC%E5%BC%8F.png"></p><blockquote><p>格式并非固定，可以根据自己的修来删除或者添加词条</p></blockquote><p>案例：</p><table><thead><tr><th align="center">KEYS</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">juzi:user:1</td><td align="center">{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td align="center">juzi:product:1</td><td align="center">{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><h3 id="3-5-Redis命令-Hash命令"><a href="#3-5-Redis命令-Hash命令" class="headerlink" title="3.5 Redis命令-Hash命令"></a>3.5 Redis命令-Hash命令</h3><p>Hash类型，也叫散列，其value是一个无需字典，类似于java中的HashMap结构</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Hash%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png"></p><p>Hash类型常见命令</p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><p>指令案例</p><ul><li>HSET和HGET</li></ul><pre><code class="sh">127.0.0.1:6379&gt; HSET heima:user:3 name Lucy#大key是 heima:user:3 小key是name，小value是Lucy(integer) 1127.0.0.1:6379&gt; HSET heima:user:3 age 21 #如果操作不存在的数据，则是新增(integer) 1127.0.0.1:6379&gt; HSET heima:user:3 age 17 #如果操作存在的数据，则是修改(integer) 0127.0.0.1:6379&gt; HGET heima:user:3 name &quot;Lucy&quot;127.0.0.1:6379&gt; HGET heima:user:3 age&quot;17&quot;</code></pre><ul><li>HMSET和HMGET</li></ul><pre><code class="sh">127.0.0.1:6379&gt; HMSET heima:user:4 name HanMeiMeiOK127.0.0.1:6379&gt; HMSET heima:user:4 name LiLei age 20 sex manOK127.0.0.1:6379&gt; HMGET heima:user:4 name age sex1) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot;</code></pre><ul><li>HGETALL</li></ul><pre><code class="sh">127.0.0.1:6379&gt; HGETALL heima:user:41) &quot;name&quot;2) &quot;LiLei&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;sex&quot;6) &quot;man&quot;</code></pre><ul><li>HKEYS和HVALS</li></ul><pre><code class="sh">127.0.0.1:6379&gt; HKEYS heima:user:41) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;127.0.0.1:6379&gt; HVALS heima:user:41) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot;</code></pre><ul><li>HINCRBY</li></ul><pre><code class="sh">127.0.0.1:6379&gt; HINCRBY  heima:user:4 age 2(integer) 22127.0.0.1:6379&gt; HVALS heima:user:41) &quot;LiLei&quot;2) &quot;22&quot;3) &quot;man&quot;127.0.0.1:6379&gt; HINCRBY  heima:user:4 age -2(integer) 20</code></pre><ul><li>HSETNX</li></ul><pre><code class="sh">127.0.0.1:6379&gt; HSETNX heima:user4 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL heima:user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;127.0.0.1:6379&gt; HSETNX heima:user:3 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL heima:user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;5) &quot;sex&quot;6) &quot;woman&quot;</code></pre><h3 id="3-6-Redis命令-List命令"><a href="#3-6-Redis命令-List命令" class="headerlink" title="3.6 Redis命令-List命令"></a>3.6 Redis命令-List命令</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><blockquote><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p></blockquote><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Redis-List%E7%A4%BA%E4%BE%8B.png"></p><p>指令案例</p><ul><li>LPUSH和RPUSH</li></ul><pre><code class="sh">127.0.0.1:6379&gt; LPUSH users 1 2 3(integer) 3127.0.0.1:6379&gt; RPUSH users 4 5 6(integer) 6</code></pre><ul><li>LPOP和RPOP</li></ul><pre><code class="sh">127.0.0.1:6379&gt; LPOP users&quot;3&quot;127.0.0.1:6379&gt; RPOP users&quot;6&quot;</code></pre><ul><li>LRANGE</li></ul><pre><code class="sh">127.0.0.1:6379&gt; LRANGE users 1 21) &quot;1&quot;2) &quot;4&quot;</code></pre><h3 id="3-7-Redis命令-Set命令"><a href="#3-7-Redis命令-Set命令" class="headerlink" title="3.7 Redis命令-Set命令"></a>3.7 Redis命令-Set命令</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><p>Set类型的常见命令</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><blockquote><p>区分交集和差集</p><ul><li>两个集合：s1 和 s2</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88.png"><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/%E4%BA%A4%E9%9B%86%E5%92%8C%E5%B7%AE%E9%9B%86%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p></blockquote><p>指令案例</p><blockquote><p>将下列数据用Redis的Set集合来存储：</p></blockquote><ul><li>张三的好友有：李四.王五.赵六</li><li>李四的好友有：王五.麻子.二狗</li><li>利用Set的命令实现下列功能：</li><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><pre><code class="sh">127.0.0.1:6379&gt; SADD zs lisi wangwu zhaoliu(integer) 3    127.0.0.1:6379&gt; SADD ls wangwu mazi ergou(integer) 3    127.0.0.1:6379&gt; SCARD zs(integer) 3    127.0.0.1:6379&gt; SINTER zs ls1) &quot;wangwu&quot;    127.0.0.1:6379&gt; SDIFF zs ls1) &quot;zhaoliu&quot;2) &quot;lisi&quot;    127.0.0.1:6379&gt; SUNION zs ls1) &quot;wangwu&quot;2) &quot;zhaoliu&quot;3) &quot;lisi&quot;4) &quot;mazi&quot;5) &quot;ergou&quot;    127.0.0.1:6379&gt; SISMEMBER zs lisi(integer) 1    127.0.0.1:6379&gt; SISMEMBER ls zhangsan(integer) 0    127.0.0.1:6379&gt; SREM zs lisi(integer) 1    127.0.0.1:6379&gt; SMEMBERS zs1) &quot;zhaoliu&quot;2) &quot;wangwu&quot;</code></pre><h3 id="3-8-Redis命令-SortedSet命令"><a href="#3-8-Redis命令-SortedSet命令" class="headerlink" title="3.8 Redis命令-SortedSet命令"></a>3.8 Redis命令-SortedSet命令</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><blockquote><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p></blockquote><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><h2 id="4-Redis的Java客户端-Jedis"><a href="#4-Redis的Java客户端-Jedis" class="headerlink" title="4.Redis的Java客户端-Jedis"></a>4.Redis的Java客户端-Jedis</h2><p>在Redis官网提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p>其中Java的客户端有很多</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/Redis-Java%E5%AE%A2%E6%88%B7%E7%AB%AF.png"></p><p>标记为❤的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求</li></ul><h3 id="4-1-Jedis快速入门"><a href="#4-1-Jedis快速入门" class="headerlink" title="4.1 Jedis快速入门"></a>4.1 Jedis快速入门</h3><p><strong>详细步骤</strong></p><ol start="0"><li>创建Maven工程</li><li>引入依赖</li></ol><pre><code class="xml">&lt;!--jedis--&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--单元测试--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;    &lt;version&gt;5.7.0&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li><p>建立连接</p><p>创建一个单元测试类</p></li></ol><pre><code class="java">private Jedis jedis;@BeforeEachvoid setUp() &#123;    // 1.建立连接    jedis = new Jedis(&quot;192.168.19.136&quot;, 6379);    // 2.设置密码    jedis.auth(&quot;123321&quot;);    // 3.选择库    jedis.select(0);&#125;</code></pre><ol start="3"><li>测试</li></ol><pre><code class="java">@Testvoid testString() &#123;    // 存入数据    String result = jedis.set(&quot;name&quot;, &quot;虎哥&quot;);    System.out.println(&quot;result = &quot; + result);    // 获取数据    String name = jedis.get(&quot;name&quot;);    System.out.println(&quot;name = &quot; + name);&#125;@Testvoid testHash() &#123;    // 插入hash数据    jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Jack&quot;);    jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;21&quot;);    // 获取    Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;);    System.out.println(map);&#125;</code></pre><ol start="4"><li>释放资源</li></ol><pre><code class="java">@AfterEachvoid tearDown() &#123;    if (jedis != null) &#123;        jedis.close();    &#125;&#125;</code></pre><h3 id="4-2-Jedis连接池"><a href="#4-2-Jedis连接池" class="headerlink" title="4.2 Jedis连接池"></a>4.2 Jedis连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，</p><p>因此推荐使用<code>Jedis连接池</code>代替<code>Jedis直连方式</code></p><h4 id="4-2-1-创建Jedis的连接池"><a href="#4-2-1-创建Jedis的连接池" class="headerlink" title="4.2.1 创建Jedis的连接池"></a>4.2.1 创建Jedis的连接池</h4><pre><code class="java">public class JedisConnectionFacotry &#123;     private static final JedisPool jedisPool;     static &#123;         //配置连接池         JedisPoolConfig poolConfig = new JedisPoolConfig();         poolConfig.setMaxTotal(8);         poolConfig.setMaxIdle(8);         poolConfig.setMinIdle(0);         poolConfig.setMaxWaitMillis(1000);         //创建连接池对象         jedisPool = new JedisPool(poolConfig,                 &quot;192.168.19.136&quot;,6379,1000,&quot;123321&quot;);     &#125;     public static Jedis getJedis()&#123;          return jedisPool.getResource();     &#125;&#125;</code></pre><p>代码说明</p><ul><li><p>JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li><li><p>静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p></li><li><p>最后提供返回连接池中连接的方法.</p></li></ul><h4 id="4-2-2-改造原始代码"><a href="#4-2-2-改造原始代码" class="headerlink" title="4.2.2 改造原始代码"></a>4.2.2 改造原始代码</h4><pre><code class="java">    @BeforeEach    void setUp()&#123;        //建立连接        /*jedis = new Jedis(&quot;192.168.19.136&quot;, 6379);*/        jedis = JedisConnectionFacotry.getJedis();         //选择库        jedis.select(0);    &#125;   @AfterEach    void tearDown() &#123;        if (jedis != null) &#123;            jedis.close();        &#125;    &#125;</code></pre><p>代码说明</p><ul><li>使用工厂设计模式来完成代码时，获取连接通过工厂来获得，降低耦合</li><li>使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的</li></ul><h2 id="5-Redis的Java客户端-SpringDataRedis"><a href="#5-Redis的Java客户端-SpringDataRedis" class="headerlink" title="5.Redis的Java客户端-SpringDataRedis"></a>5.Redis的Java客户端-SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis</p><p>官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/SpringDataRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C.png"></p><h3 id="5-1-快速入门"><a href="#5-1-快速入门" class="headerlink" title="5.1 快速入门"></a>5.1 快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单</p><h4 id="6-1-1-导入Pom坐标"><a href="#6-1-1-导入Pom坐标" class="headerlink" title="6.1.1 导入Pom坐标"></a>6.1.1 导入Pom坐标</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.7&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.juzi&lt;/groupId&gt;    &lt;artifactId&gt;redis-demo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;redis-demo&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--redis依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--common-pool--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--Jackson依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h4 id="5-1-2-配置文件"><a href="#5-1-2-配置文件" class="headerlink" title="5.1.2 配置文件"></a>5.1.2 配置文件</h4><pre><code class="properties">spring:  redis:    host: 192.168.19.136    port: 6379    password: 123321    lettuce:      pool:        max-active: 8  #最大连接        max-idle: 8   #最大空闲连接        min-idle: 0   #最小空闲连接        max-wait: 1000ms #连接等待时间</code></pre><h4 id="5-1-3-测试代码"><a href="#5-1-3-测试代码" class="headerlink" title="5.1.3 测试代码"></a>5.1.3 测试代码</h4><pre><code class="java">@SpringBootTestclass RedisDemoApplicationTests &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Test    void testString() &#123;        // 写入一条String数据        redisTemplate.opsForValue().set(&quot;name&quot;, &quot;虎哥&quot;);        // 获取string数据        Object name = redisTemplate.opsForValue().get(&quot;name&quot;);        System.out.println(&quot;name = &quot; + name);    &#125;&#125;</code></pre><h3 id="5-2-数据序列化器"><a href="#5-2-数据序列化器" class="headerlink" title="5.2 数据序列化器"></a>5.2 数据序列化器</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/RedisTemplate%E5%86%99%E5%85%A5.png"></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/JDK%E9%BB%98%E8%AE%A4%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%9C.png"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>解决方案：自定义<code>RedisTemplate</code>的序列化方式</p><pre><code class="java">@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123;        // 创建RedisTemplate对象        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 设置连接工厂        template.setConnectionFactory(connectionFactory);        // 创建JSON序列化工具        GenericJackson2JsonRedisSerializer jsonRedisSerializer =                                         new GenericJackson2JsonRedisSerializer();        // 设置Key的序列化        template.setKeySerializer(RedisSerializer.string());        template.setHashKeySerializer(RedisSerializer.string());        // 设置Value的序列化        template.setValueSerializer(jsonRedisSerializer);        template.setHashValueSerializer(jsonRedisSerializer);        // 返回        return template;    &#125;&#125;</code></pre><p>这是采用了JSON序列化来代替默认的JDK序列化方式，结果：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/JSON%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%9C.png"></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销</p><h3 id="5-3-StringRedisTemplate"><a href="#5-3-StringRedisTemplate" class="headerlink" title="5.3 StringRedisTemplate"></a>5.3 StringRedisTemplate</h3><p>JSON序列化存在的问题</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/JSON%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%9C.png"></p><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>为了减少内存的消耗，我们可以采用<strong>手动序列化</strong>的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/StringRedisTemplate%E7%A4%BA%E6%84%8F.png"></p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/StringRedisTemplate%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.png"></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用</p><pre><code class="java">@SpringBootTestclass RedisStringTests &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void testString() &#123;        // 写入一条String数据        stringRedisTemplate.opsForValue().set(&quot;verify:phone:13600527634&quot;, &quot;124143&quot;);        // 获取string数据        Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;);        System.out.println(&quot;name = &quot; + name);    &#125;    private static final ObjectMapper mapper = new ObjectMapper();    @Test    void testSaveUser() throws JsonProcessingException &#123;        // 创建对象        User user = new User(&quot;虎哥&quot;, 21);        // 手动序列化        String json = mapper.writeValueAsString(user);        // 写入数据        stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json);        // 获取数据        String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;);        // 手动反序列化        User user1 = mapper.readValue(jsonUser, User.class);        System.out.println(&quot;user1 = &quot; + user1);    &#125;&#125;</code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5143/StringRedisTemplate%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%9C.png"></p><p><strong>小结</strong></p><p>RedisTemplate的两种序列化实践方案：</p><ul><li><p>方案一：</p><ul><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ul></li><li><p>方案二：</p><ul><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ul></li></ul><h3 id="5-4-Hash结构操作"><a href="#5-4-Hash结构操作" class="headerlink" title="5.4 Hash结构操作"></a>5.4 Hash结构操作</h3><pre><code class="java">@SpringBootTestclass RedisStringTests &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void testHash() &#123;        stringRedisTemplate.opsForHash().put(&quot;user:400&quot;, &quot;name&quot;, &quot;虎哥&quot;);        stringRedisTemplate.opsForHash().put(&quot;user:400&quot;, &quot;age&quot;, &quot;21&quot;);        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;user:400&quot;);        System.out.println(&quot;entries = &quot; + entries);    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> NoSql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/24/hello-world/"/>
      <url>/2022/11/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
